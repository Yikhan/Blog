<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Javascript题目心得</title>
    <link href="/2020/June/Javascript-exp/"/>
    <url>/2020/June/Javascript-exp/</url>
    
    <content type="html"><![CDATA[<h2 id="map函数和parseInt之间的故事"><a href="#map函数和parseInt之间的故事" class="headerlink" title="map函数和parseInt之间的故事"></a>map函数和parseInt之间的故事</h2><p>这也是一道经典的题目了</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">'23'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'10'</span>]<span class="hljs-built_in">console</span>.log(array.map(<span class="hljs-built_in">parseInt</span>))<span class="hljs-comment">//! 结果是[ 23, NaN, 2 ]</span></code></pre></div><p>这是因为map函数在传递形参时，一共会传递三个参数 <code>callback(currentValue[, index[, array]])</code> 第二个是索引，第三个是数组本身<br>而parseInt其实可以接受两个参数string, radix，第二个radix表示进制，取值范围是2-36。</p><p>有意思的地方来了，radix大部分时候都没有人用，一般都会被留空，而当radix为 <code>0, undefined, null</code> 时，并不是默认以10进制来解析的：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt#%E6%8F%8F%E8%BF%B0" target="_blank" rel="noopener">根据MDN的资料</a></p><ul><li><p>如果输入的 string以 “0x”或 “0x”（一个0，后面是小写或大写的X）开头，那么radix被假定为16，字符串的其余部分被解析为十六进制数。</p></li><li><p>如果输入的 string以 “0”（0）开头， radix被假定为8（八进制）或10（十进制）。具体选择哪一个radix取决于实现。ECMAScript 5 澄清了应该使用 10 (十进制)，但不是所有的浏览器都支持。因此，在使用 parseInt 时，一定要指定一个 radix。</p></li><li><p>如果输入的 string 以任何其他值开头， radix 是 10 (十进制)。</p></li></ul><p>所以上面的例子，其真实的执行情况是：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'23'</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// parseInt没有第三个参数，所以map传递进来第三个参数array可以被忽略</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'8'</span>, <span class="hljs-number">1</span>)<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'10'</span>, <span class="hljs-number">2</span>)</code></pre></div><p>第一个’23’是字符串，且不是以0x开头的特殊情况，所以使用默认10进制解析，答案为23<br>第二个因为parseInt的radix取值是2-36，1是非法值，所以结果为NaN<br>第三个’10’是字符串，以2进制解析，答案是2</p><p>这里的细节确实是普通程序猿绝对不会留意到的，这个题目出的的确刁钻</p><h2 id="为什么不能把Promise-resolve当做函数变量来使用"><a href="#为什么不能把Promise-resolve当做函数变量来使用" class="headerlink" title="为什么不能把Promise.resolve当做函数变量来使用"></a>为什么不能把Promise.resolve当做函数变量来使用</h2><p>如果试图直接调用：</p><div class="hljs"><pre><code class="hljs js">FunctionThatNeedsCallback(Prmose.resolve) <span class="hljs-comment">// TypeError: PromiseResolve called on non-object</span></code></pre></div><p>最简单的复现方法是：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>).then(<span class="hljs-built_in">Promise</span>.resolve) <span class="hljs-comment">// TypeError: PromiseResolve called on non-object</span></code></pre></div><p>因为Promise.resolve是一个需要context的函数，好比一个里面使用了this的函数，是不允许脱离context使用的。<br>所以要么直接在一个对象上使用 <code>v =&gt; Prmose.resolve(v)</code>，要么就要手动绑定 <code>Promise.resolve.bind(Promise)</code></p><h2 id="Promise中的值穿透"><a href="#Promise中的值穿透" class="headerlink" title="Promise中的值穿透"></a>Promise中的值穿透</h2><p>和上面那个例子相关，假如有下面这样的代码，结果会打印出什么呢？</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>).then(<span class="hljs-number">2</span>).then(<span class="hljs-built_in">console</span>.log)</code></pre></div><p>答案是1，这是因为如果then的参数不是一个函数，就会把上一层传入的值直接传递给下一层 (类似直接 <code>return this</code>)，这就是值穿透现象。</p>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建总结</title>
    <link href="/2020/June/blog-build/"/>
    <url>/2020/June/blog-build/</url>
    
    <content type="html"><![CDATA[<p>折腾了一番，博客顺利搭建完毕。不得不说到了2020年的今天Hexo确实很强大了，以往个人博客比较难配置的一些站长功能都已经有了现成的集成，特别是主流的几个Theme模版都囊括了常用的几乎所有博客功能，只要自己愿意玩玩技术，不需要多少编程能力就能独立搭好不弱于任何主流社区的个人博客了，巴适得很。</p><p>总结一下几个比较容易踩坑的地方：</p><h3 id="git-repo-嵌套问题"><a href="#git-repo-嵌套问题" class="headerlink" title="git repo 嵌套问题"></a>git repo 嵌套问题</h3><p>推荐直接下载主题到本地，解压放到theme目录下，不要使用submodule，就不用折腾了……</p><p>这个问题应该所有想用git管理博客的blogger都会遇到，而且如果不擅长查资料的话会非常坑，因为官方基本没怎么提这个问题。</p><p>当我们搭建博客项目的时候，一般博客本身就是一个repo，而Hexo会把你下载的主题放在themes这个子文件中，如果你是用 git clone 来下载的话，就会发现当你试图build博客的时候，本地运行一切正常，但一旦你deploy到Github Pages就会收到下面的邮件：</p><blockquote><p>You are attempting to use a Jekyll theme, which is not supported by GitHub Pages. Please visit <a href="https://pages.github.com/themes/" target="_blank" rel="noopener">https://pages.github.com/themes/</a> for a list of supported themes. If you are using the “theme” configuration variable for something other than a Jekyll theme, we recommend you rename this variable throughout your site. For more information, see <a href="https://help.github.com/en/articles/adding-a-jekyll-theme-to-your-github-pages-site." target="_blank" rel="noopener">https://help.github.com/en/articles/adding-a-jekyll-theme-to-your-github-pages-site.</a></p></blockquote><p>这个问题乍一看好像是Github不识别Jekyll主题，但很明显我们用的是Hexo而不是Jekyll模版，如果你直接搜索这些关键词会找到很多几年前很类似的问题。当时Github会默认使用Jekyll去解析网页项目，所以需要在项目里放一个空的 .nojekyll 文件来让Github知道不需要进行解析，但这个问题已经被解决了。</p><p>真正导致这一问题的关键在于repo的嵌套导致的deploy失败，由于你clone的主题本身就是一个repo，而你的博客项目是另外一个repo，两个repo有了嵌套关系就会导致Github不知道如何处理deploy上来的文件。</p><p>所以要用 git submodule 来导入主题，而不是 git clone</p><div class="hljs"><pre><code class="hljs bash">git submodule add https://github.com/geektutu/hexo-theme-geektutu.git themes/geektutu</code></pre></div><p>这样theme模版项目作为一个子模块加载到博客项目里面来，层次逻辑就不会混乱了。</p><p>当你要更新模版时也很简单：</p><div class="hljs"><pre><code class="hljs bash">git submodule upate</code></pre></div><h3 id="css等资源加载失败"><a href="#css等资源加载失败" class="headerlink" title="css等资源加载失败"></a>css等资源加载失败</h3><p>deploy成功之后可能还会发现下面的情况：</p><p><img src="https://raw.githubusercontent.com/Yikhan/ImageHost/master/blog/1564116640441.png" srcset="/img/loading.gif" alt="css error"></p><p>css和js等资源文件统统加载失败，博客只有内容而没有样式。</p><p>404问题一般都是由于访问路径错误导致的，可以看一下这些文件是在访问什么路径的时候失败的，比如:</p><div class="hljs"><pre><code class="hljs bash">正确的:yourname.github.io/blog/css/1.css实际访问:yourname.github.io/css/1.css</code></pre></div><p>其实Hexo文档里面已经提示过你了：</p><blockquote><p>If your site is put in a subdirectory, set url as ‘<a href="http://yoursite.com/child&#39;">http://yoursite.com/child&#39;</a> and root as ‘/child/‘</p></blockquote><p>当你的博客网址不是第一路径时（就是网址中带有/，有/就表示你的博客在一个子路径里面），你要密切注意子路径的配置方式。很多人的博客项目实际网址是 yourname.github.io/blog/ 这样的形式，这时候你就必须要在 _config.yml 文件里面严格按照下面的方式来配置:</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">url:</span> <span class="hljs-string">https://yourname.github.io/blog/</span><span class="hljs-attr">root:</span> <span class="hljs-string">/blog/</span></code></pre></div><p>这是我在搭建博客时候碰到的两个坑，总结一下方便其他朋友绕坑。</p><h3 id="如何删除submodule"><a href="#如何删除submodule" class="headerlink" title="如何删除submodule"></a>如何删除submodule</h3><p>如果想停止使用submodule的方式引入主题，可以使用下面的命令：</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># Remove the submodule entry from .git/config</span>git submodule deinit -f path/to/submodule<span class="hljs-comment"># Remove the submodule directory from the superproject's .git/modules directory</span>rm -rf .git/modules/path/to/submodule<span class="hljs-comment"># Remove the entry in .gitmodules and remove the submodule directory located at path/to/submodule</span>git rm -f path/to/submodule</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
