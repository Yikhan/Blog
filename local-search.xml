<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端学习笔记 (chap.1) - 函数式编程和Promise</title>
    <link href="/2020/June/Javascript-exp/"/>
    <url>/2020/June/Javascript-exp/</url>
    
    <content type="html"><![CDATA[<h1 id="1-函数式编程"><a href="#1-函数式编程" class="headerlink" title="1. 函数式编程"></a>1. 函数式编程</h1><h2 id="1-1-柯里化"><a href="#1-1-柯里化" class="headerlink" title="1.1 柯里化"></a>1.1 柯里化</h2><p>函数式编程的基础，使用了高阶函数的思想，利用闭包把接受多个参数的函数封装成单参数函数，配合组合使用函数compose构成了函数式编程的重点技术</p><p>如何实现curry</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curriedFunc</span>(<span class="hljs-params">...args</span>) </span>&#123;    <span class="hljs-comment">//* 使用fn.length获得fn定义时的参数数量，fn通过闭包被缓存</span>    <span class="hljs-keyword">if</span> (args.length &lt; fn.length) &#123;      <span class="hljs-comment">//* 参数数量不够，应该返回柯里化后的函数</span>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...localArgs</span>) </span>&#123;        <span class="hljs-comment">//* 继续递归返回</span>        <span class="hljs-comment">//* 把上一层递归的args和这个函数会接收到的参数合并</span>        <span class="hljs-keyword">return</span> curriedFunc(...args.concat([ ...localArgs ]))      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//* 参数数量够了，可以运行fn了</span>      <span class="hljs-keyword">return</span> fn(...args)    &#125;  &#125;&#125;</code></pre></div><h2 id="1-2-组合函数"><a href="#1-2-组合函数" class="headerlink" title="1.2 组合函数"></a>1.2 组合函数</h2><p>把一组需要组合的函数按照从右到左的顺序依次执行，注意要组合的函数必须都是单参数函数，也就是一元函数，所以常常需要和curry化配合使用</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//* 组合函数原理模拟</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params">...funcs</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;    <span class="hljs-keyword">return</span> funcs.reduceRight(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">acc, func</span>) </span>&#123;      <span class="hljs-keyword">return</span> func(acc)    &#125;, value)  &#125;&#125;<span class="hljs-keyword">const</span> reverse = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> arr.reverse()<span class="hljs-keyword">const</span> first = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> arr[<span class="hljs-number">0</span>]<span class="hljs-keyword">const</span> toUpperCase = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> str.toUpperCase()<span class="hljs-keyword">const</span> f = compose(toUpperCase, first, reverse)<span class="hljs-built_in">console</span>.log(f([ <span class="hljs-string">'ant'</span>, <span class="hljs-string">'bat'</span>, <span class="hljs-string">'cab'</span> ])) <span class="hljs-comment">// C B A</span></code></pre></div><h2 id="1-3-Point-free"><a href="#1-3-Point-free" class="headerlink" title="1.3 Point-free"></a>1.3 Point-free</h2><p>在组合函数的基础上，为了使函数更方便组合，可以约定让函数的第一个参数接受方法，第二个参数接受数据，这种方法优先的模式使得组合函数非常简单直接</p><p>当我们组合一系列的函数时，我们实际上就是在按一定的步骤组合方法，并没有提及数据，这和传统的过程式编程完全不同，也是函数式编程个人觉得最有魅力的地方，其简洁和老程序猿嗤之以鼻的面条代码刚好是两个极端</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 可以很直观地知道我们先要执行的步骤，而完全没有提及变量或者数据本身</span><span class="hljs-keyword">const</span> firstLetterToUpper = fp.flowRight(  fp.join(<span class="hljs-string">'. '</span>),  fp.map(fp.flowRight(fp.toUpper, fp.first())),  fp.split(<span class="hljs-string">' '</span>))</code></pre></div><p>lodash/fp这个库里实现了lodash里功能函数的Point-free版本(所以专门放在了fp这个模块下)</p><h2 id="1-4-函子Functor"><a href="#1-4-函子Functor" class="headerlink" title="1.4 函子Functor"></a>1.4 函子Functor</h2><h3 id="1-4-1-基本概念"><a href="#1-4-1-基本概念" class="headerlink" title="1.4.1 基本概念"></a>1.4.1 基本概念</h3><p>函子是我以前比较陌生的概念，基本从未看到其真正的使用</p><p>函子的本质类似面向对象里面的私有变量封装，传统的函数式编程要求函数为纯函数(Pure Function)，也就是没有任何副作用的函数</p><blockquote><p>副作用：函数执行时不引起其他变量的变化，函数没有中间中间状态</p></blockquote><p>在实际应用中，除了功能单一的功能性函数，大部分业务函数都不是纯函数，副作用无可避免，所以函子的概念应运而生</p><p>函子把要被改变的变量和改变它的方法封装为一个class，和面向对象不同的是，这个改变它的方法并不是一个确定的函数，而是从外部传入一个函数</p><p>同时每次操作都会返回一个新的函子，这样就可以进行链式操作</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//* SECTION 容器 - 用于封装会被改变的值，以及改变它的方法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(value) &#123;    <span class="hljs-keyword">this</span>._value = value  &#125;  <span class="hljs-comment">//* 使用静态函数封装构造函数，这样外面调用的时候就不需要使用new</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span>(value) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Container(value)  &#125;  <span class="hljs-comment">//* map封装了任何试图改动_value的行为，并且总是返回一个新的容器</span>  map(fn) &#123;    <span class="hljs-keyword">return</span> Container.of(fn(<span class="hljs-keyword">this</span>._value))  &#125;&#125;<span class="hljs-comment">//* !SECTION</span><span class="hljs-comment">//* 测试 基本的函子</span><span class="hljs-keyword">let</span> r = Container.of(<span class="hljs-number">5</span>) <span class="hljs-comment">// 初始化</span>  .map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x + <span class="hljs-number">1</span>) <span class="hljs-comment">// map会返回一个新的容器，所以可以链式调用</span>  .map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x * x) <span class="hljs-comment">// 结果应该是36</span></code></pre></div><h3 id="1-4-2-Maybe函子"><a href="#1-4-2-Maybe函子" class="headerlink" title="1.4.2 Maybe函子"></a>1.4.2 Maybe函子</h3><p>基本的函子里面没有判断value和传入的修改方法是否兼容，所以我们可以在容器内加入判断，比如value为空值的时候直接返回一个新函子(value值还是原来的)，并不进行计算</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MayBe</span> </span>&#123;  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span>(value) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MayBe(value)  &#125;  <span class="hljs-keyword">constructor</span>(value) &#123;    <span class="hljs-keyword">this</span>._value = value  &#125;   <span class="hljs-comment">// 如果对空值变形的话直接返回 值为 null 的函子</span>  map(fn) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNothing() ? MayBe.of(<span class="hljs-literal">null</span>) : MayBe.of(fn(<span class="hljs-keyword">this</span>._value))  &#125;  isNothing() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._value === <span class="hljs-literal">null</span> || <span class="hljs-keyword">this</span>._value === <span class="hljs-literal">undefined</span>  &#125;&#125; <span class="hljs-comment">// 传入具体值</span>MayBe.of(<span class="hljs-string">'Hello World'</span>).map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.toUpperCase())<span class="hljs-comment">// 传入 null 的情况</span>MayBe.of(<span class="hljs-literal">null</span>).map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.toUpperCase())<span class="hljs-comment">// =&gt; MayBe &#123; _value: null &#125;</span></code></pre></div><h3 id="1-4-3-其他函子"><a href="#1-4-3-其他函子" class="headerlink" title="1.4.3 其他函子"></a>1.4.3 其他函子</h3><p>常用的函子还有Either函子，IO函子，Task函子等</p><p>尤其是Task函子也是一种异步机制，具体可参考folktale函数式编程库</p><p><a href="https://folktale.origamitower.com/" target="_blank" rel="noopener">folktale</a></p><h2 id="1-5-一些题目"><a href="#1-5-一些题目" class="headerlink" title="1.5 一些题目"></a>1.5 一些题目</h2><h3 id="1-5-1-map函数和parseInt之间的故事"><a href="#1-5-1-map函数和parseInt之间的故事" class="headerlink" title="1.5.1 map函数和parseInt之间的故事"></a>1.5.1 map函数和parseInt之间的故事</h3><p>这也是一道经典的题目了</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">'23'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'10'</span>]<span class="hljs-built_in">console</span>.log(array.map(<span class="hljs-built_in">parseInt</span>))<span class="hljs-comment">//! 结果是[ 23, NaN, 2 ]</span></code></pre></div><p>这是因为map函数在传递形参时，一共会传递三个参数 <code>callback(currentValue[, index[, array]])</code> 第二个是索引，第三个是数组本身<br>而parseInt其实可以接受两个参数string, radix，第二个radix表示进制，取值范围是2-36。</p><p>有意思的地方来了，radix大部分时候都没有人用，一般都会被留空，而当radix为 <code>0, undefined, null</code> 时，并不是默认以10进制来解析的：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt#%E6%8F%8F%E8%BF%B0" target="_blank" rel="noopener">根据MDN的资料</a></p><ul><li><p>如果输入的 string以 “0x”或 “0x”（一个0，后面是小写或大写的X）开头，那么radix被假定为16，字符串的其余部分被解析为十六进制数。</p></li><li><p>如果输入的 string以 “0”（0）开头， radix被假定为8（八进制）或10（十进制）。具体选择哪一个radix取决于实现。ECMAScript 5 澄清了应该使用 10 (十进制)，但不是所有的浏览器都支持。因此，在使用 parseInt 时，一定要指定一个 radix。</p></li><li><p>如果输入的 string 以任何其他值开头， radix 是 10 (十进制)。</p></li></ul><p>所以上面的例子，其真实的执行情况是：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'23'</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// parseInt没有第三个参数，所以map传递进来第三个参数array可以被忽略</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'8'</span>, <span class="hljs-number">1</span>)<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'10'</span>, <span class="hljs-number">2</span>)</code></pre></div><p>第一个’23’是字符串，且不是以0x开头的特殊情况，所以使用默认10进制解析，答案为23<br>第二个因为parseInt的radix取值是2-36，1是非法值，所以结果为NaN<br>第三个’10’是字符串，以2进制解析，答案是2</p><p>这里的细节确实是普通程序猿绝对不会留意到的，这个题目出的的确刁钻</p><h1 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2. Promise"></a>2. Promise</h1><h2 id="2-1-为什么不能把Promise-resolve当做函数变量来使用"><a href="#2-1-为什么不能把Promise-resolve当做函数变量来使用" class="headerlink" title="2.1 为什么不能把Promise.resolve当做函数变量来使用"></a>2.1 为什么不能把Promise.resolve当做函数变量来使用</h2><p>如果试图直接调用：</p><div class="hljs"><pre><code class="hljs js">FunctionThatNeedsCallback(Prmose.resolve) <span class="hljs-comment">// TypeError: PromiseResolve called on non-object</span></code></pre></div><p>最简单的复现方法是：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>).then(<span class="hljs-built_in">Promise</span>.resolve) <span class="hljs-comment">// TypeError: PromiseResolve called on non-object</span></code></pre></div><p>因为Promise.resolve是一个需要context的函数，好比一个里面使用了this的函数，是不允许脱离context使用的。<br>所以要么直接在一个对象上使用 <code>v =&gt; Prmose.resolve(v)</code>，要么就要手动绑定 <code>Promise.resolve.bind(Promise)</code></p><h2 id="2-2-Promise中的值穿透"><a href="#2-2-Promise中的值穿透" class="headerlink" title="2.2 Promise中的值穿透"></a>2.2 Promise中的值穿透</h2><p>和上面那个例子相关，假如有下面这样的代码，结果会打印出什么呢？</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>).then(<span class="hljs-number">2</span>).then(<span class="hljs-built_in">console</span>.log)</code></pre></div><p>答案是1，这是因为如果then的参数不是一个函数，就会把上一层传入的值直接传递给下一层 (类似直接 <code>return this</code>)，这就是值穿透现象。</p><p>通过具体的代码实现，可以比较容易地理解：</p><div class="hljs"><pre><code class="hljs js">successCallback =  <span class="hljs-keyword">typeof</span> successCallback === <span class="hljs-string">'function'</span>    ? successCallback    : <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value <span class="hljs-comment">// 如果callback不是函数，则返回传入的值</span>failCallback =  <span class="hljs-keyword">typeof</span> failCallback === <span class="hljs-string">'function'</span>    ? failCallback    : <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> reason <span class="hljs-comment">// 如果callback不是函数，则返回传入的值</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建总结</title>
    <link href="/2020/June/blog-build/"/>
    <url>/2020/June/blog-build/</url>
    
    <content type="html"><![CDATA[<p>折腾了一番，博客顺利搭建完毕。不得不说到了2020年的今天Hexo确实很强大了，以往个人博客比较难配置的一些站长功能都已经有了现成的集成，特别是主流的几个Theme模版都囊括了常用的几乎所有博客功能，只要自己愿意玩玩技术，不需要多少编程能力就能独立搭好不弱于任何主流社区的个人博客了，巴适得很。</p><p>总结一下几个比较容易踩坑的地方：</p><h3 id="git-repo-嵌套问题"><a href="#git-repo-嵌套问题" class="headerlink" title="git repo 嵌套问题"></a>git repo 嵌套问题</h3><p>推荐直接下载主题到本地，解压放到theme目录下，不要使用submodule，就不用折腾了……</p><p>这个问题应该所有想用git管理博客的blogger都会遇到，而且如果不擅长查资料的话会非常坑，因为官方基本没怎么提这个问题。</p><p>当我们搭建博客项目的时候，一般博客本身就是一个repo，而Hexo会把你下载的主题放在themes这个子文件中，如果你是用 git clone 来下载的话，就会发现当你试图build博客的时候，本地运行一切正常，但一旦你deploy到Github Pages就会收到下面的邮件：</p><blockquote><p>You are attempting to use a Jekyll theme, which is not supported by GitHub Pages. Please visit <a href="https://pages.github.com/themes/" target="_blank" rel="noopener">https://pages.github.com/themes/</a> for a list of supported themes. If you are using the “theme” configuration variable for something other than a Jekyll theme, we recommend you rename this variable throughout your site. For more information, see <a href="https://help.github.com/en/articles/adding-a-jekyll-theme-to-your-github-pages-site." target="_blank" rel="noopener">https://help.github.com/en/articles/adding-a-jekyll-theme-to-your-github-pages-site.</a></p></blockquote><p>这个问题乍一看好像是Github不识别Jekyll主题，但很明显我们用的是Hexo而不是Jekyll模版，如果你直接搜索这些关键词会找到很多几年前很类似的问题。当时Github会默认使用Jekyll去解析网页项目，所以需要在项目里放一个空的 .nojekyll 文件来让Github知道不需要进行解析，但这个问题已经被解决了。</p><p>真正导致这一问题的关键在于repo的嵌套导致的deploy失败，由于你clone的主题本身就是一个repo，而你的博客项目是另外一个repo，两个repo有了嵌套关系就会导致Github不知道如何处理deploy上来的文件。</p><p>所以要用 git submodule 来导入主题，而不是 git clone</p><div class="hljs"><pre><code class="hljs bash">git submodule add https://github.com/geektutu/hexo-theme-geektutu.git themes/geektutu</code></pre></div><p>这样theme模版项目作为一个子模块加载到博客项目里面来，层次逻辑就不会混乱了。</p><p>当你要更新模版时也很简单：</p><div class="hljs"><pre><code class="hljs bash">git submodule upate</code></pre></div><h3 id="css等资源加载失败"><a href="#css等资源加载失败" class="headerlink" title="css等资源加载失败"></a>css等资源加载失败</h3><p>deploy成功之后可能还会发现下面的情况：</p><p><img src="https://raw.githubusercontent.com/Yikhan/ImageHost/master/blog/1564116640441.png" srcset="/img/loading.gif" alt="css error"></p><p>css和js等资源文件统统加载失败，博客只有内容而没有样式。</p><p>404问题一般都是由于访问路径错误导致的，可以看一下这些文件是在访问什么路径的时候失败的，比如:</p><div class="hljs"><pre><code class="hljs bash">正确的:yourname.github.io/blog/css/1.css实际访问:yourname.github.io/css/1.css</code></pre></div><p>其实Hexo文档里面已经提示过你了：</p><blockquote><p>If your site is put in a subdirectory, set url as ‘<a href="http://yoursite.com/child&#39;">http://yoursite.com/child&#39;</a> and root as ‘/child/‘</p></blockquote><p>当你的博客网址不是第一路径时（就是网址中带有/，有/就表示你的博客在一个子路径里面），你要密切注意子路径的配置方式。很多人的博客项目实际网址是 yourname.github.io/blog/ 这样的形式，这时候你就必须要在 _config.yml 文件里面严格按照下面的方式来配置:</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">url:</span> <span class="hljs-string">https://yourname.github.io/blog/</span><span class="hljs-attr">root:</span> <span class="hljs-string">/blog/</span></code></pre></div><p>这是我在搭建博客时候碰到的两个坑，总结一下方便其他朋友绕坑。</p><h3 id="如何删除submodule"><a href="#如何删除submodule" class="headerlink" title="如何删除submodule"></a>如何删除submodule</h3><p>如果想停止使用submodule的方式引入主题，可以使用下面的命令：</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># Remove the submodule entry from .git/config</span>git submodule deinit -f path/to/submodule<span class="hljs-comment"># Remove the submodule directory from the superproject's .git/modules directory</span>rm -rf .git/modules/path/to/submodule<span class="hljs-comment"># Remove the entry in .gitmodules and remove the submodule directory located at path/to/submodule</span>git rm -f path/to/submodule</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
