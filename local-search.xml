<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端学习笔记 (chap.2.4) - Webpack进阶</title>
    <link href="/2020/July/Javascript-webpack-advance/"/>
    <url>/2020/July/Javascript-webpack-advance/</url>
    
    <content type="html"><![CDATA[<h1 id="Webpack进阶"><a href="#Webpack进阶" class="headerlink" title="Webpack进阶"></a>Webpack进阶</h1><h2 id="1-Dev-Server"><a href="#1-Dev-Server" class="headerlink" title="1. Dev-Server"></a>1. <code>Dev-Server</code></h2><p><code>webpack-dev-server</code>是使用率最高的webpack插件之一，其主要特点就是集成了打包和浏览器加载以及热更新这一套组合拳，特别是其打包后的文件是在内存中的，并不会真正生成到dist目录，避免了大量的重复磁盘读写。</p><p>安装：</p><div class="hljs"><pre><code class="hljs bash">yarn add webpack-dev-server --dev</code></pre></div><p>启动方式：</p><div class="hljs"><pre><code class="hljs bash">yarn webpack-dev-server // 默认从根目录打包</code></pre></div><p>老样子，安装后需要在<code>webpack.config.js</code>里配置</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  devServer: &#123;    contentBase: <span class="hljs-string">'./public'</span>,    proxy: &#123;      <span class="hljs-string">'/api'</span>: &#123;        <span class="hljs-comment">// http://localhost:8080/api/users -&gt; https://api.github.com/api/users</span>        target: <span class="hljs-string">'https://api.github.com'</span>,        <span class="hljs-comment">// http://localhost:8080/api/users -&gt; https://api.github.com/users</span>        pathRewrite: &#123;          <span class="hljs-string">'^/api'</span>: <span class="hljs-string">''</span>        &#125;,        <span class="hljs-comment">// 不能使用 localhost:8080 作为请求 GitHub 的主机名</span>        changeOrigin: <span class="hljs-literal">true</span>      &#125;    &#125;  &#125;&#125;</code></pre></div><p><code>contentBase</code>表示静态资源路径，这个目录下的文件不会被打包，有利于提高开发时的打包效率（静态文件一般只在最后打包上线时才应该被真正打包处理）</p><p><code>proxy</code>表示代理转发，这是一个非常有用的配置。在本地开发阶段时，一般本地我们的网站都是以<code>localhost:8080</code>这类网址来运行的，当需要请求一些api接口时就会出现跨域问题，这时就要通过<code>proxy</code>来转发。</p><h2 id="2-source-map"><a href="#2-source-map" class="headerlink" title="2. source-map"></a>2. <code>source-map</code></h2><p><code>source-map</code>是一种位置信息文件，主要保存了打包后的代码与源代码之间的对应关系，在调试的时候极为有用。</p><p>在webpack里配置<code>source-map</code>，主要使用devtool这个属性</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  devtool: <span class="hljs-string">'source-map'</span> <span class="hljs-comment">// 可以换成其他生成模式</span>&#125;</code></pre></div><p>然后就会生成<code>source-map</code>文件，比如<code>bundle.js.map</code></p><p>webpack支持多种<code>source-map</code>的生成方式，其性能和效率各有不同</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200715191338417.png" srcset="/img/loading.gif" alt="image-20200715191338417"></p><p>不同的模式从命名上就能看出基本的特点</p><ul><li>eval - 是否使用eval实行模块代码</li><li>cheap - 是否包含行信息</li><li>module - 是否能得到Loader处理之前的源代码</li><li>inline - 将<code>source-map</code>以data-url的形式嵌入到代码中（会增大代码文件体积）</li><li>hidden - 生成<code>source-map</code> 但是不在打包后的代码文件中引入（也就是提供<code>source-map</code>但是不用）</li><li>nosources - 不显示源代码（会显示错误位置的行列信息），主要用于生产环境里保护源代码不暴露</li></ul><hr><p>在开发环境下首先推荐使用的是<code>cheap-module-eval-source-map</code>这个模式</p><p>其优势如下：</p><ol><li><p>因为一般只要代码风格控制得当，每行不长，行信息就足够了，不需要列信息。</p></li><li><p>现在项目都会使用多个Loader多次打包，所以显示原始的源代码是有必要的。</p></li><li><p>这个模式首次打包慢但是rebuild很快，符合我们经常调试时频繁重新打包的需要</p></li></ol><p>而在生产环境下，建议选择<code>none</code>，不要提供<code>source-map</code></p><h2 id="3-Hot-Module-Replacement"><a href="#3-Hot-Module-Replacement" class="headerlink" title="3. Hot Module Replacement"></a>3. Hot Module Replacement</h2><p>HMR可以算是webpack中最为好用的功能之一，所谓HMR就是只替换有改动的文件而不用刷新整个页面，这极大地提高了开发效率。</p><p><code>webpack-dev-server</code>本身就支持HMR，可以通过命令参数开启</p><div class="hljs"><pre><code class="hljs bash">yarn webpack-dev-server --hot</code></pre></div><p>也可以通过配置，这时还需要引入webpack内置的<code>HotModuleReplacementPlugin</code>插件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)<span class="hljs-built_in">module</span>.exports = &#123;  devServer: &#123;    hot: <span class="hljs-literal">true</span>  &#125;,  plugins: [    <span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin()  ]&#125;</code></pre></div><p>但是这还不够，这只能保证css等样式代码自动HMR，js代码却不行，页面依然会刷新。</p><p>这是因为js代码过于灵活，webpack无法判断要如何执行HMR，必须要用户来指定更新方法。</p><p>我们需要使用<code>HotModuleReplacementPlugin</code>提供的<code>module.hot</code>API</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> createEditor <span class="hljs-keyword">from</span> <span class="hljs-string">'./editor'</span><span class="hljs-keyword">import</span> background <span class="hljs-keyword">from</span> <span class="hljs-string">'./better.png'</span><span class="hljs-keyword">import</span> <span class="hljs-string">'./global.css'</span><span class="hljs-keyword">const</span> editor = createEditor()<span class="hljs-built_in">document</span>.body.appendChild(editor)<span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> Image()img.src = background<span class="hljs-built_in">document</span>.body.appendChild(img)<span class="hljs-comment">// ============ 以下用于处理 HMR，与业务代码无关 ============</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>.hot) &#123;  <span class="hljs-comment">// js模块的HMR</span>  <span class="hljs-keyword">let</span> lastEditor = editor <span class="hljs-comment">// 保存之前的页面数据</span>  <span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">'./editor'</span>, () =&gt; &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'editor 模块更新了，需要这里手动处理热替换逻辑'</span>)    <span class="hljs-keyword">const</span> value = lastEditor.innerHTML    <span class="hljs-built_in">document</span>.body.removeChild(lastEditor)    <span class="hljs-keyword">const</span> newEditor = createEditor()    newEditor.innerHTML = value <span class="hljs-comment">// 恢复更新前的页面数据</span>    <span class="hljs-built_in">document</span>.body.appendChild(newEditor)    lastEditor = newEditor  &#125;)  <span class="hljs-comment">// 图片的HMR</span>  <span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">'./better.png'</span>, () =&gt; &#123;    img.src = background    <span class="hljs-built_in">console</span>.log(background)  &#125;)&#125;</code></pre></div><p>这些代码在webpack打包后会被移除，所以并不用担心影响生产环境。</p><p>但依然会发现原生的HMR虽然强大但是要编写这些替换逻辑比较繁琐，而这也是开发者现在更愿意使用<code>vue-cli</code>，<code>create-react-app</code>这些现成的集合框架，它们已经内置了替换逻辑，可以直接进行HMR</p><h2 id="4-多配置文件"><a href="#4-多配置文件" class="headerlink" title="4. 多配置文件"></a>4. 多配置文件</h2><p>在实际项目中，往往需要针对不对的环境配置相应的<code>webpack.config</code>文件</p><div class="hljs"><pre><code class="hljs reStructuredText">-- webpack.common.js-- webpack.dev.js-- webpack.prod.js</code></pre></div><p>比较常用的方法是将通用的部分抽出为<code>webpack.common.js</code>文件，然后在各自的配置里使用合并，这时我们可以使用<code>webpack-merge</code>这个插件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-merge'</span>)<span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'clean-webpack-plugin'</span>)<span class="hljs-keyword">const</span> CopyWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'copy-webpack-plugin'</span>)<span class="hljs-keyword">const</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpack.common'</span>)<span class="hljs-built_in">module</span>.exports = merge(common, &#123;  mode: <span class="hljs-string">'production'</span>,  plugins: [    <span class="hljs-keyword">new</span> CleanWebpackPlugin(),    <span class="hljs-keyword">new</span> CopyWebpackPlugin([<span class="hljs-string">'public'</span>])  ]&#125;)</code></pre></div><p>其提供的<code>merge</code>函数可以把不同配置的属性针对性地合并，比如这里的<code>plugins</code>，我们并不想覆盖掉common里的插件数组，而是合并。</p><p>然后运行webpack的时候就要指定配置文件</p><div class="hljs"><pre><code class="hljs bash">yarn webpack --config webpack.prod.js</code></pre></div><p>也可以把这个命令集成到<code>package.json</code>的<code>scripts</code>里简化</p><div class="hljs"><pre><code class="hljs json">&#123;  <span class="hljs-attr">"scripts"</span>: &#123;    <span class="hljs-attr">"builid"</span>: <span class="hljs-string">"webpack --config webpack.prod.js"</span>  &#125;&#125;</code></pre></div><h2 id="4-Tree-Shaking"><a href="#4-Tree-Shaking" class="headerlink" title="4. Tree-Shaking"></a>4. Tree-Shaking</h2><p>Tree-Shaking可以在打包是去除未被使用到的代码，有效减小代码体积。webpack默认在production会自动进行Tree-Shaking，其他模式下要手动开启，主要就是使用<code>optimazation</code>属性。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  mode: <span class="hljs-string">'none'</span>， <span class="hljs-comment">// 非production模式</span>  entry: <span class="hljs-string">'./src/index.js'</span>,  output: &#123;   filename: <span class="hljs-string">'bundle.js'</span>  &#125;,  optimization: &#123;    usedExports: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 在打包时仅导出使用到的成员变量</span>    minimize: <span class="hljs-literal">true</span> <span class="hljs-comment">// 压缩移除掉未被引用到的代码</span>  &#125;&#125;</code></pre></div><p><code>usedExports</code>可以在打包阶段找到哪些是被引用到的成员，将其导出，而剩下的未被引用成员就会在<code>minimize</code>阶段被移除。</p><p><code>optimization</code>里还有一个<code>concatenateModules</code>选项，可以尽可能把代码合并到一个模块函数内，提升运行效率和再次减小代码体积，这个功能是webpack3加入的，也被称作<code>scope hoisting</code></p><div class="hljs"><pre><code class="hljs js">optimization: &#123;  concatenateModules: <span class="hljs-literal">true</span>&#125;</code></pre></div><hr><p>Tree-Shaking只能对ES Module起效，这点尤其需要注意，如果使用了Babel的话可能会因为js被编译成了CommonJS而导致Tree-Shaking失效。</p><p>目前新版的Babel不会导致这个问题，我们也可以通过强制指定编译模式来确保：</p><div class="hljs"><pre><code class="hljs js">rules: [  &#123;    test: <span class="hljs-regexp">/\.js$/</span>,    use: &#123;      loader: <span class="hljs-string">'babel-loader'</span>,      options: &#123;        presets: [          [<span class="hljs-string">'@babel/preset-env'</span>, &#123; <span class="hljs-attr">modules</span>: <span class="hljs-literal">false</span> &#125;]        ]      &#125;    &#125;  &#125;]</code></pre></div><p>注意presets的配置，添加选项对象时要嵌套两层数组</p><h2 id="5-SideEffect"><a href="#5-SideEffect" class="headerlink" title="5. SideEffect"></a>5. SideEffect</h2><p>Side-Effect顾名思义表示副总用，如果一个模块没有副作用，就表示除了export，其余代码不会造成任何额外变化（类似纯函数的概念），我们可以在模块对应的<code>package.json</code>里标注<code>sideEffects: false</code>来表示这点，然后webpack就会进一步移除掉未被引用的代码（这个功能在开发npm库时可能使用更多）</p><p>production环境下是默认开启的</p><div class="hljs"><pre><code class="hljs js">optimization: &#123;  sideEffects: <span class="hljs-literal">true</span>&#125;</code></pre></div><p>这个功能的意义在于Tree-Shaking是通过代码是否被引用来判断优化的，但有些时候代码可能被import了却并没有真正使用，比如下面这种整合了局部组件的情况，虽然最后可能只有Button被真正使用了，但Link由于也被引入了所以也会被一起打包进来。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> Button &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./button.js'</span><span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> Link &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./link.js'</span></code></pre></div><h2 id="6-代码分割-分包"><a href="#6-代码分割-分包" class="headerlink" title="6. 代码分割/分包"></a>6. 代码分割/分包</h2><p>在项目越来越大以后，我们不希望把所有代码都打包到一个bundle.js里面，这会严重拖慢加载速度。理想情况是用户打开了哪个页面就加载哪个部分，因此代码分割打包就势在必行。</p><h3 id="6-1-多入口打包"><a href="#6-1-多入口打包" class="headerlink" title="6.1 多入口打包"></a>6.1 多入口打包</h3><p>很简单，从多个js文件入口开始打包，生成各自的打包文件。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  entry: &#123;    index: <span class="hljs-string">'./src/index.js'</span>,    album: <span class="hljs-string">'./src/album.js'</span>  &#125;,  output: &#123;    filename: <span class="hljs-string">'[name].bundle.js'</span>  &#125;,&#125;</code></pre></div><p>这样之后还有个问题，假如我们使用了<code>HtmlWebpackPlugin</code>，每个生成的html都会把所有的打包js文件都导入一次，这显然不是我们所期望的。</p><p>所以我们还设置一个属性，就是chunks</p><div class="hljs"><pre><code class="hljs js">plugins: [  <span class="hljs-keyword">new</span> CleanWebpackPlugin(),  <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;    title: <span class="hljs-string">'Multi Entry'</span>,    template: <span class="hljs-string">'./src/index.html'</span>,    filename: <span class="hljs-string">'index.html'</span>,    chunks: [<span class="hljs-string">'index'</span>]  &#125;),  <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;    title: <span class="hljs-string">'Multi Entry'</span>,    template: <span class="hljs-string">'./src/album.html'</span>,    filename: <span class="hljs-string">'album.html'</span>,    chunks: [<span class="hljs-string">'album'</span>]  &#125;)]</code></pre></div><p>这样每个html都只会引入自己的bundle.js打包文件了。</p><p>我们还可以让webpack帮我们提取各个模块的公共部分，避免分割以后重复打包。</p><div class="hljs"><pre><code class="hljs js">optimization: &#123;  splitChunks: &#123;    chunks: <span class="hljs-string">'all'</span>  &#125;&#125;</code></pre></div><p>这样webpack会自动把公共部分打包到一个新文件里。</p><h3 id="6-2-动态导入"><a href="#6-2-动态导入" class="headerlink" title="6.2 动态导入"></a>6.2 动态导入</h3><p>也就是真正意义上的按需加载，使用ES Module的<code>import</code>函数，而不是在文件开头使用<code>import from</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// import posts from './posts/posts'</span><span class="hljs-comment">// import album from './album/album'</span><span class="hljs-keyword">const</span> render = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">const</span> hash = <span class="hljs-built_in">window</span>.location.hash || <span class="hljs-string">'#posts'</span>  <span class="hljs-keyword">const</span> mainElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.main'</span>)  mainElement.innerHTML = <span class="hljs-string">''</span>  <span class="hljs-keyword">if</span> (hash === <span class="hljs-string">'#posts'</span>) &#123;    <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: 'components' */</span><span class="hljs-string">'./posts/posts'</span>).then(<span class="hljs-function">(<span class="hljs-params">&#123; <span class="hljs-keyword">default</span>: posts &#125;</span>) =&gt;</span> &#123;      mainElement.appendChild(posts())    &#125;)  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hash === <span class="hljs-string">'#album'</span>) &#123;    <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: 'components' */</span><span class="hljs-string">'./album/album'</span>).then(<span class="hljs-function">(<span class="hljs-params">&#123; <span class="hljs-keyword">default</span>: album &#125;</span>) =&gt;</span> &#123;      mainElement.appendChild(album())    &#125;)  &#125;&#125;</code></pre></div><p>上面代码里在<code>import</code>内部还使用了注释代码</p><blockquote><p>/* webpackChunkName: ‘components’ */</p></blockquote><p>这样可以指定把动态导入的模块打包到哪里，不指定的话生成的bundle文件会以数字为序号。如果指定名一样的话就会打包到同一个文件里。</p><hr><p>然后我们还可以让css文件也按需加载，通过安装使用一个插件<code>MiniCssExtractPlugin</code>把css从打包中抽取出来单独构成一个文件。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>)<span class="hljs-built_in">module</span>.exports = &#123;  plugins: [    <span class="hljs-keyword">new</span> MiniCssExtractPlugin()  ]&#125;</code></pre></div><p>使用这个插件之后原来的<code>style-loader</code>就不需要了（因为css已经不在打包后的js里面了），我们要使用<code>MiniCssExtractPlugin</code>自带的loader</p><div class="hljs"><pre><code class="hljs js">&#123;  test: <span class="hljs-regexp">/\.css$/</span>,  use: [    MiniCssExtractPlugin.loader,    <span class="hljs-string">'css-loader'</span>  ]&#125;</code></pre></div><p>要注意的，如果css不是很大（未超过150kb），就没有必要单独提取出来，和js打包在一起的性能会更好一些。</p><p>最后我们还需要压缩这个独立的css文件（webpack默认只能压缩js文件）</p><p>需要使用官方推荐的<code>optimize-css-assets-webpack-plugin</code></p><p>安装后按照惯例配置插件：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>)<span class="hljs-keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'optimize-css-assets-webpack-plugin'</span>)<span class="hljs-built_in">module</span>.exports = &#123;  plugins: [    <span class="hljs-keyword">new</span> MiniCssExtractPlugin(),    <span class="hljs-keyword">new</span> OptimizeCssAssetsWebpackPlugin()  ]&#125;</code></pre></div><p>有意思的是，webpack其实建议把这个插件配置到minimizer数组里，而不是plugins数组。所有的压缩有关的插件都可以放到minimizer里面，使用参数统一控制是否压缩。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  optimization: &#123;    minimizer: &#123;      <span class="hljs-keyword">new</span> OptimizeCssAssetsWebpackPlugin()    &#125;  &#125;&#125;</code></pre></div><p>production打包时minimizer会自动开启</p><p>不过这样一来js就没法自动压缩了，因为minimizer这个自定义压缩配置会覆盖默认，所以还需要配置一个js的默认压缩插件</p><p>安装<code>terser-webpack-plugin</code>，这是webpack默认使用的js压缩插件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> TerserWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'terser-webpack-plugin'</span>)<span class="hljs-built_in">module</span>.exports = &#123;   optimization: &#123;    minimizer: &#123;      <span class="hljs-keyword">new</span> TerserWebpackPlugin(),      <span class="hljs-keyword">new</span> OptimizeCssAssetsWebpackPlugin()    &#125;  &#125;&#125;</code></pre></div><h2 id="7-Hash命名"><a href="#7-Hash命名" class="headerlink" title="7. Hash命名"></a>7. Hash命名</h2><p>我们可以看到很多项目打包后的bundle名字里都带了一串hash，这主要是为文件缓存服务的，hash编号可以区分文件是否有更新，如果不同则当做新文件缓存。这样可以解决新老文件同名时文件缓存不更新的问题。</p><p>一般常用的有三种hash命名方式：</p><table><thead><tr><th align="center">命名方式</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">‘[name]-[hash].bundle.js’</td><td align="center">每次打包整体重设hash</td></tr><tr><td align="center">‘[name]-[chunkhash].bundle.js’</td><td align="center">以chunk为单位，一个chunk共享一个hash</td></tr><tr><td align="center">‘[name]-[contenthash].bundle.js’</td><td align="center">文件级hash，最适合解决缓存问题</td></tr></tbody></table><p>基本上配置里配置文件输出名的地方都可以使用hash:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 打包输出</span>output: &#123;  filename: <span class="hljs-string">'[name]-[contenthash:8].bundle.js'</span>&#125;<span class="hljs-comment">// 插件里面也可以</span>plugins: [  <span class="hljs-keyword">new</span> MiniCssExtractPlugin(&#123;    filename: <span class="hljs-string">'[name]-[contenthash:8].bundle.css'</span>  &#125;)]</code></pre></div><p>可以在hash属性后面增加<code>:number</code>来控制生成hash的长度，默认是20位。</p>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习笔记 (chap.2.3) - Webpack基础</title>
    <link href="/2020/July/Javascript-webpack-basic/"/>
    <url>/2020/July/Javascript-webpack-basic/</url>
    
    <content type="html"><![CDATA[<h1 id="Webpack基础"><a href="#Webpack基础" class="headerlink" title="Webpack基础"></a>Webpack基础</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>很简单，主要就是webpack和webpack-cli两个模块</p><div class="hljs"><pre><code class="hljs bash">yarn add webpack webpack-cli --dev</code></pre></div><p>然后就可以使用命令打包了</p><div class="hljs"><pre><code class="hljs bash">yarn webpack</code></pre></div><p>默认情况下webpack会把<code>src/index.html</code>作为打包入口，打包结果存放在dist文件夹下</p><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><p>在项目根目录下添加<code>webpack.config.js</code>，注意这个文件默认是在node环境下运行，所以采用CommonJS规范</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)<span class="hljs-built_in">module</span>.exports = &#123;  entry: <span class="hljs-string">'./src/main.js'</span>, <span class="hljs-comment">// 打包入口文件，可以是相对路径</span>  output: &#123;    filename: <span class="hljs-string">'bundle.js'</span>, <span class="hljs-comment">// 输出文件名称</span>    path: path.join(__dirname, <span class="hljs-string">'dist'</span>) <span class="hljs-comment">// 输出文件目录，必须是绝对路径</span>  &#125;&#125;</code></pre></div><p>webpack默认的打包模式为production，会自动进行代码合并压缩等优化操作</p><p>可以通过<code>--mode</code>来设置打包模式</p><p>除了production还有devlopment和none两种模式</p><div class="hljs"><pre><code class="hljs bash">yarn webpack --mode development/none</code></pre></div><ul><li><p>development模式下webpack会优化打包速度和添加一些辅助调试的代码</p></li><li><p>none模式是最原始基础的打包</p></li></ul><p>当然也可以在配置中预先设置打包模式</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  mode: <span class="hljs-string">'development'</span>&#125;</code></pre></div><h2 id="3-loader加载器"><a href="#3-loader加载器" class="headerlink" title="3. loader加载器"></a>3. loader加载器</h2><p><strong>webpack默认只能处理js文件</strong>，其他文件需要安装对应的loader来处理，这也是webpack的核心所在。</p><p>loader的工作机制类似管道，所以可以把不同的loader组合起来使用，但要注意的是webpack要求最后的Result一定要是js代码。</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200714154649412.png" srcset="/img/loading.gif" alt="image-20200714154649412"></p><h3 id="3-1-loader分类"><a href="#3-1-loader分类" class="headerlink" title="3.1 loader分类"></a>3.1 loader分类</h3><p>基本上webpack的loader有三类</p><ul><li>把代码转换为js格式，比如<code>css-loader</code></li><li>处理拷贝文件，导出文件路径，比如<code>file-loader</code></li><li>辅助功能，代码校验，比如<code>eslint-loader</code></li></ul><h3 id="3-2-css-loader-style-loader"><a href="#3-2-css-loader-style-loader" class="headerlink" title="3.2 css-loader/style-loader"></a>3.2 <code>css-loader</code>/<code>style-loader</code></h3><p>比如要处理css文件就需要安装<code>css-loader</code></p><div class="hljs"><pre><code class="hljs bash">yarn add css-loader --dev</code></pre></div><p>然后需要在module属性的rules里配置规则，rules是一个数组，一个rule需要包括两个属性：</p><ul><li><code>test</code> 匹配目标文件路径，一般使用regex</li><li><code>use</code> 需要使用的loader，不仅可以是名字，也可以是路径，和require类似</li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-built_in">module</span>: &#123;    rules: [      &#123;        test: <span class="hljs-regexp">/.css$/</span>,        use: <span class="hljs-string">'css-loader'</span>      &#125;    ]  &#125;&#125;</code></pre></div><p>然后还需要安装<code>style-loader</code>，因为<code>css-loader</code>只是把css转换为js数组，我们还需要一个loader来把转换好的css加载到页面上。</p><div class="hljs"><pre><code class="hljs bash">yarn add style-loader --dev</code></pre></div><p>然后更改use为一个数组</p><div class="hljs"><pre><code class="hljs js">rules: [  &#123;    test: <span class="hljs-regexp">/.css$/</span>,    use: [      <span class="hljs-string">'style-loader'</span>,      <span class="hljs-string">'css-loader'</span>    ]  &#125;]</code></pre></div><p>注意当use为数组时，执行顺序为从下往上</p><p>这里我们希望先执行<code>css-loader</code>之后再执行<code>style-loader</code>，所以把<code>style-loader</code>放上面。</p><p>webpack推荐以js文件为打包入口，在js里import引入css等其他所需的文件，这样有利于tree-shaking清理未被使用的代码，同时也符合webpack的设计思想—<code>围绕js来进行打包服务，当js需要使用其他资源时，应该就地引入</code>。这更贴近于现代组件化的前端开发模式（比如React，Vue等都是把css样式和组件放在一起，甚至直接使用css-in-js）</p><h3 id="3-3-file-loader"><a href="#3-3-file-loader" class="headerlink" title="3.3 file-loader"></a>3.3 <code>file-loader</code></h3><p>打包图片等静态文件资源需要安装<code>file-loader</code></p><div class="hljs"><pre><code class="hljs bash">yarn add file-loader --dev</code></pre></div><p>然后同样的，需要设置rule</p><div class="hljs"><pre><code class="hljs js">&#123;  test: <span class="hljs-regexp">/.png$/</span>,  use: <span class="hljs-string">'file-loader'</span>&#125;</code></pre></div><p>要注意的是webpack默认的资源路径是项目的根目录，并不是我们设置输出目录dist。也就是说，webpack默认打包文件输出的地方就应该是项目运行的根目录（很好理解，理想情况下dist就是最后部署运行的唯一目录）</p><p>所以一些情况下如果dist不是根目录，比如本地开发时我们可能仍然在原来的目录下去引用dist里面的打包文件，这时就要告诉webpack这个打包目录相对于真正的根目录在哪。</p><p>否则一些需要使用这些资源的地方就会报错。</p><p>打包过的bundle.js里可以看到图片文件的路径：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = __webpack_require__.p + <span class="hljs-string">"aaa0e8af..3e18.png"</span> <span class="hljs-comment">// 文件名被替换成了hash，可以防止名字重复</span></code></pre></div><p>里面的<code>__webpack_require__.p</code>就是我们需要设置的资源路径publicPath</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  output: &#123;    filename: <span class="hljs-string">'bundle.js'</span>,    path: path.join(__dirname, <span class="hljs-string">'dist'</span>),    publicPath: <span class="hljs-string">'dist/'</span> <span class="hljs-comment">// 注意斜杠不能省略，因为会直接被拼接到路径里</span>  &#125;&#125;</code></pre></div><p>publicPath是很有用的属性，可以结合env来设置不同的值，比如有些时候我们希望发布后托管资源到云端或者其他地方，就可以根据需求修改publicPath</p><h3 id="3-4-url-loader"><a href="#3-4-url-loader" class="headerlink" title="3.4 url-loader"></a>3.4 <code>url-loader</code></h3><p><code>url-loader</code>可以把资源文件直接转换为url，这样就可以避免使用http的方式去请求文件。</p><p>这是因为url本身也是可以保存数据的</p><div class="hljs"><pre><code class="hljs html">data: [<span class="hljs-tag">&lt;<span class="hljs-name">mediatype</span>&gt;</span>][;base64],<span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span> 协议     媒体类型编码文件内容</code></pre></div><p>比如下面的一个url，就直接传输了一个html页面数据</p><div class="hljs"><pre><code class="hljs html">data:text/html;charset=UTF-8,<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>html content<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre></div><p>把小文件转换为url是很有用的（大文件不应该使用url，因为转换后的js文件也会过大），比较好的方式是把10kb以下的文件转化为url，超过的则照常使用<code>file-loader</code></p><p>首先安装<code>url-loader</code></p><div class="hljs"><pre><code class="hljs bash">yarn add url-loader --dev</code></pre></div><p>然后配置rule，不过这次use既不是字符串也不是一个数组，我们要使用一个对象，这样就可以在里面使用options来配置细节。</p><div class="hljs"><pre><code class="hljs js">&#123;  test: <span class="hljs-regexp">/.png$/</span>,  use: &#123;    loader: <span class="hljs-string">'url-loader'</span>,    options: &#123;      limit: <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> <span class="hljs-comment">// 单位是字节，这里表示10kb</span>    &#125;  &#125;&#125;</code></pre></div><p>现在<code>url-loader</code>就回自动对10kb以下的文件进行url转换了，不过要注意的是，<code>url-loader</code>对超过大小的文件默认还是会调用<code>file-loader</code>，所以仍然需要安装<code>file-loader</code></p><h3 id="3-5-babel-loader"><a href="#3-5-babel-loader" class="headerlink" title="3.5 babel-loader"></a>3.5 <code>babel-loader</code></h3><p>由于webpack本身并不能识别ES6的新特性（除了import/export这两个打包必需的），当需要转换兼容js代码时，就又轮到了大名鼎鼎的<code>babel</code>出场（<code>bable</code>可能会迟到，但永远不会缺席…）</p><p><code>babel-loader</code>还需要依赖<code>babel</code>的核心组件和插件，所以我们要安装以下三个：</p><div class="hljs"><pre><code class="hljs bash">yarn add babel-loader @babel/core @babel/preset-env --dev</code></pre></div><p>然后当然还是要配置</p><div class="hljs"><pre><code class="hljs js">&#123;  test: <span class="hljs-regexp">/.js$/</span>,  use: &#123;    loader: <span class="hljs-string">'babel-loader'</span>,    options: &#123;      presets: [<span class="hljs-string">'@babel/preset-env'</span>]    &#125;  &#125;,  include: [ path.resolve(__dirname, <span class="hljs-string">'src'</span>) ]&#125;</code></pre></div><p>这里的配置基本和模块化一章中一样，关键依然是要指定presets，也就是告诉<code>babel</code>要使用什么插件（<code>preset-env</code>本身就是包含了新特性的一组插件集合）</p><p>注意还要使用<code>include/exclude</code>限定要处理的js文件路径，官方推荐的配置里使用了<code>exclude</code>来排除node_modules。在实际测试中，不使用限定的话运行打包后的代码时会报错。</p><blockquote><p>exclude: /(node_modules|bower_components)/</p></blockquote><h3 id="3-6-html-loader"><a href="#3-6-html-loader" class="headerlink" title="3.6 html-loader"></a>3.6 <code>html-loader</code></h3><p><code>html-loader</code>用于打包html文件</p><div class="hljs"><pre><code class="hljs bash">yarn add html-loader --dev</code></pre></div><p>要注意的是，webpack的任何loader或者多个loader管道式运行后最后生成的一定是js代码，所以<code>html-loader</code>的目的是把js中引用的html文件打包到js里面。</p><p>我们还需要配置如何处理html里面的资源引用问题。</p><div class="hljs"><pre><code class="hljs js">&#123;  test: <span class="hljs-regexp">/.html$/</span>,  use: &#123;    loader: <span class="hljs-string">'html-loader'</span>,    options: &#123;      attr: [<span class="hljs-string">'img:src'</span>, <span class="hljs-string">'a:href'</span>]    &#125;  &#125;&#125;</code></pre></div><p>默认情况下，<code>html-loader</code>只会对img的src属性进行处理，href里面引用的资源是不会被打包的，所以需要按照上面的格式来配置。</p><h3 id="3-7-Webpack资源打包原理"><a href="#3-7-Webpack资源打包原理" class="headerlink" title="3.7 Webpack资源打包原理"></a>3.7 Webpack资源打包原理</h3><p>webpack的资源打包也是有规则的，它类似一个爬虫，从入口文件开始爬取需要加载进来的资源。</p><p>默认情况下webpack会自动打包：</p><ul><li>ES Modules的import声明</li><li>CommonJS的require</li><li>AMD的define和require</li><li>样式代码(css)中的@import和url函数</li><li>html代码中图片标签的src属性</li></ul><h3 id="4-插件Plugin"><a href="#4-插件Plugin" class="headerlink" title="4. 插件Plugin"></a>4. 插件Plugin</h3><p>插件是让webpack变得如此强大的另一个重要原因。插件可以解决打包任务之外的很多自动化操作需求，让webpack开始抢占gulp等传统自动化工具的地盘。</p><h4 id="4-1-clean-webpack-plugin"><a href="#4-1-clean-webpack-plugin" class="headerlink" title="4.1 clean-webpack-plugin"></a>4.1 <code>clean-webpack-plugin</code></h4><p>我们先来试试<code>clean-webpack-plugin</code>，它的作用是在每次打包前清理dist目录</p><div class="hljs"><pre><code class="hljs bash">yarn add clean-webpack-plugin --dev</code></pre></div><p>在<code>webpack.config.js</code>里进行配置</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'clean-webpack-plugin'</span>)<span class="hljs-built_in">module</span>.exports = &#123;  plugins: [    <span class="hljs-keyword">new</span> CleanWebpackPlugin()  ]&#125;</code></pre></div><p>现在每次打包前dist目录就会被自动清理了</p><h4 id="4-2-html-webpack-plugin"><a href="#4-2-html-webpack-plugin" class="headerlink" title="4.2 html-webpack-plugin"></a>4.2 <code>html-webpack-plugin</code></h4><p><code>html-webpack-plugin</code>可以在打包目录下生成一个自动导入所有打包模块的html文件，</p><div class="hljs"><pre><code class="hljs bash">yarn add html-webpack-plugin --dev</code></pre></div><p>然后配置</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>) <span class="hljs-comment">// 直接使用default导出即可</span><span class="hljs-built_in">module</span>.exports = &#123;  plugins: [    <span class="hljs-keyword">new</span> HtmlWebpackPlugin()  ]&#125;</code></pre></div><p>在打包后，dist目录下会自动生成一个html文件，有一点要注意的是，生成的html里对资源的引用路径和配置里的<code>publicPath</code>有关，对这个生成的html来说，因为已经在dist目录下了，就不需要<code>publicPath</code>了，需要删除这项配置。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"&lt;publicPath&gt; + bundle.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>这个插件的好处在于可以动态生成导入了bundle.js的html文件，方便直接从dist目录启动项目。</p><p>如果想要进一步配置这个html文件，可以传参给<code>HtmlWebpackPlugin</code>函数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  plugins: [    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;      title: <span class="hljs-string">'Webpack Plugin Sample'</span>,      meta: &#123;        viewport: <span class="hljs-string">'width=device-width'</span>      &#125;,      template: <span class="hljs-string">'./src/index.html'</span> <span class="hljs-comment">// 可以使用自定义的html模板</span>    &#125;)  ]&#125;</code></pre></div><p>在自定义的模板里可以使用模板语法添加属性</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%=</span> <span class="hljs-attr">htmlWebpackPlugin.options.title</span> %&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre></div><p>同时，如果想要生成多个html文件也是可以的，只要再增加一个<code>HtmlWebpackPlugin</code>插件实例就行了。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  plugins: [    <span class="hljs-comment">// 默认的index.html文件</span>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;      title: <span class="hljs-string">'Webpack Plugin Sample'</span>,      meta: &#123;        viewport: <span class="hljs-string">'width=device-width'</span>      &#125;,      template: <span class="hljs-string">'./src/index.html'</span>    &#125;),    <span class="hljs-comment">// 再生成一个about.html文件</span>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;      filename: <span class="hljs-string">'about.html'</span> <span class="hljs-comment">// 默认值就是index.html</span>    &#125;)  ]&#125;</code></pre></div><p>其他配置详见官网</p><p><a href="https://github.com/jantimon/html-webpack-plugin#options" target="_blank" rel="noopener">https://github.com/jantimon/html-webpack-plugin#options</a></p><h4 id="4-3-copy-webpack-plugin"><a href="#4-3-copy-webpack-plugin" class="headerlink" title="4.3 copy-webpack-plugin"></a>4.3 <code>copy-webpack-plugin</code></h4><p>这个插件用于拷贝静态文件到dist目录</p><div class="hljs"><pre><code class="hljs bash">yarn add copy-webpack-plugin --dev</code></pre></div><p>进行配置，要注意的是<code>CopyWebpackPlugin()</code>接受的是一个数组，成员是要拷贝文件的路径，可以是通配符或者文件夹，也可以是相对路径。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> CopyWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'copy-webpack-plugin'</span>)<span class="hljs-built_in">module</span>.exports = &#123;  plugins: [   <span class="hljs-keyword">new</span> CopyWebpackPlugin(&#123;      patterns: [ &#123; <span class="hljs-attr">from</span>: <span class="hljs-string">'public/**/*'</span> &#125; ]    &#125;)  ]&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习笔记 (chap.2.2) - JS模块化</title>
    <link href="/2020/July/Javascript-module/"/>
    <url>/2020/July/Javascript-module/</url>
    
    <content type="html"><![CDATA[<h1 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h1><h2 id="1-ES-Module基本特性"><a href="#1-ES-Module基本特性" class="headerlink" title="1. ES Module基本特性"></a>1. ES Module基本特性</h2><ul><li>自动采用严格模式，忽略<code>use strict</code></li><li>每个ESM模块都是单独的私有作用域</li><li>ESM是通过CORS去请求外部JS模块的（所以使用链接请求远程JS时要注意对方是否支持）</li><li>ESM的script标签会延迟执行脚本（类似html的defer属性）</li></ul><p>如下就是在html里使用ES Module，就是把type定义为module</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>&gt;</span><span class="actionscript"><span class="hljs-keyword">var</span> foo = <span class="hljs-number">100</span></span><span class="javascript">    <span class="hljs-built_in">console</span>.log(foo)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h2 id="2-ES-Module导入导出"><a href="#2-ES-Module导入导出" class="headerlink" title="2. ES Module导入导出"></a>2. ES Module导入导出</h2><p>基本的export/import用法网上很多，这里仅总结几个容易用错的地方。</p><h3 id="2-1-export导出的并非对象字面量"><a href="#2-1-export导出的并非对象字面量" class="headerlink" title="2.1 export导出的并非对象字面量"></a>2.1 export导出的并非对象字面量</h3><p>最常见的错误就是认为export就是导出一个对象：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'Yihan'</span><span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span><span class="hljs-keyword">export</span> &#123;name, age&#125;</code></pre></div><p>其实<code>export {}</code>只是一种语法，同理<code>import {}</code>也是，并非对象字面量，<strong>导入的时候也不是ES6的对象解构</strong></p><p>所以如果试图像下面那么用就会报错：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> &#123; <span class="hljs-attr">a</span>:<span class="hljs-number">11</span> &#125; <span class="hljs-comment">// Uncaught SyntaxError: Unexpected token ':'</span></code></pre></div><p>但如果使用export default就可以，这时相当于导出了default这个对象，而default等于后面跟的那个对象：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; <span class="hljs-attr">a</span>:<span class="hljs-number">11</span> &#125; <span class="hljs-comment">// it works</span></code></pre></div><h3 id="2-2-default作为导出名"><a href="#2-2-default作为导出名" class="headerlink" title="2.2 default作为导出名"></a>2.2 default作为导出名</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 基本的default使用</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; foo &#125;<span class="hljs-comment">// 或者使用as</span><span class="hljs-keyword">export</span> &#123;foo <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>,    bar <span class="hljs-keyword">as</span> baz&#125;</code></pre></div><p>如果希望在导入时重命名默认导出default，那么就需要在<code>import {}</code>括号内使用as</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span></code></pre></div><h3 id="2-3-导出的是变量引用，而且只读"><a href="#2-3-导出的是变量引用，而且只读" class="headerlink" title="2.3 导出的是变量引用，而且只读"></a>2.3 导出的是变量引用，而且只读</h3><p>import进来的变量或者方法只是对模块内导出对象的引用，而不是拷贝。所以当模块内发生变化时，这些import进来的变量也会改变，同时要注意它们都是只读的，无法在模块外部被修改。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; age &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span>age = <span class="hljs-number">5</span><span class="hljs-built_in">console</span>.log(age) <span class="hljs-comment">// Uncaught TypeError: Assignment to constant variable.</span></code></pre></div><h3 id="2-4-export-from"><a href="#2-4-export-from" class="headerlink" title="2.4 export from"></a>2.4 export from</h3><p>这个用法可以直接导出刚导入的变量，一般可以在一个组件或模块的汇总文件里使用。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> &#123; Button &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./button.js'</span><span class="hljs-keyword">export</span> &#123; Page &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./page.js'</span></code></pre></div><h3 id="2-5-导入"><a href="#2-5-导入" class="headerlink" title="2.5 导入"></a>2.5 导入</h3><p>ES模块在导入时必须使用完整的路径和文件名。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> x <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span> <span class="hljs-comment">// 不行，文件后缀名不能省略</span><span class="hljs-keyword">import</span> x <span class="hljs-keyword">from</span> <span class="hljs-string">'module.js'</span> <span class="hljs-comment">// 不行，相对路径不能省略./ ES会认为你要加载第三方模块</span><span class="hljs-keyword">import</span> x <span class="hljs-keyword">from</span> <span class="hljs-string">'/package/module.js'</span> <span class="hljs-comment">// 可以，从项目根目录开始</span><span class="hljs-keyword">import</span> x <span class="hljs-keyword">from</span> <span class="hljs-string">'http://localhost:3000/package/module.js'</span> <span class="hljs-comment">// 可以，允许使用地址</span><span class="hljs-keyword">import</span> &#123;&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span> <span class="hljs-comment">// 可以，不引入只是执行模块</span></code></pre></div><p>import只能出现在最顶层，不允许直接动态导入。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> path = <span class="hljs-string">'./module.js'</span><span class="hljs-keyword">import</span> x <span class="hljs-keyword">from</span> path <span class="hljs-comment">// 不行</span></code></pre></div><p>想动态加载就必须使用import函数。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span>(path).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">module</span>) </span>&#123; <span class="hljs-comment">// ES模块加载是异步的</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">module</span>)&#125;)</code></pre></div><h2 id="3-在Node里使用ES模块"><a href="#3-在Node里使用ES模块" class="headerlink" title="3. 在Node里使用ES模块"></a>3. 在Node里使用ES模块</h2><h3 id="3-1-Babel"><a href="#3-1-Babel" class="headerlink" title="3.1 Babel"></a>3.1 Babel</h3><p>最常用的方式就是通过万能的Babel来转换</p><p>Babel通过插件来转换每种ES新特性，所以一般需要安装：</p><div class="hljs"><pre><code class="hljs bash">@babel/node  @babel/core  @babel/preset-env</code></pre></div><p>其中preset-env是包含了新特性的一组插件，Babel本身就是通过不同的插件来完成代码转换的。</p><p>然后就可以通过<code>babel-node</code>命令来运行js文件了。</p><div class="hljs"><pre><code class="hljs bash">yarn babel-node index.js --presets=@babel/preset-env</code></pre></div><p>如果不想手动传入presets参数，可以在根目录下创建一个<code>.babelrc</code>文件来配置。</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"presets"</span>: [<span class="hljs-string">"@babel/preset-env"</span>]&#125;</code></pre></div><p>注意我们其实也可以自己来安装特定的插件然后使用</p><p>比如可以单独安装<code>@babel/plugin-transform-modules-commonjs</code></p><p>然后在<code>.babelrc</code>里面配置，这时候可以不使用presets，而是plugins直接配置要用的每个插件。</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"plugins"</span>: [<span class="hljs-string">"@babel/plugin-transform-modules-commonjs"</span>]&#125;</code></pre></div><h3 id="3-2-Node内置的功能"><a href="#3-2-Node内置的功能" class="headerlink" title="3.2 Node内置的功能"></a>3.2 Node内置的功能</h3><p>其实Node较新的版本（高于8.9.0）已经提供了对ES模块的支持，只不过截止目前为止仍然是作为实验特性。</p><div class="hljs"><pre><code class="hljs bash">node --experimental-modules index.mjs</code></pre></div><p>要注意的是需要把模块文件重命名为<code>.mjs</code>文件，如果不想这么麻烦可以在<code>package.json</code>里配置type项：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"module"</span>&#125;</code></pre></div><p>但这样以后所有的js文件都会默认以ES Module的规范加载，也就是说不能再使用CommonJS的那套语法了（比如<code>require</code>）</p><p>这个时候如果还想保留CommonJS的用法，需要把使用CommonJS的模块重命名为<code>.cjs</code>文件。</p>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习笔记 (chap.2.1) - 自动化构建工具Gulp</title>
    <link href="/2020/July/Javascript-gulp/"/>
    <url>/2020/July/Javascript-gulp/</url>
    
    <content type="html"><![CDATA[<h1 id="自动化构建工具Gulp"><a href="#自动化构建工具Gulp" class="headerlink" title="自动化构建工具Gulp"></a>自动化构建工具Gulp</h1><p>Gulp作为当下最流行的前端自动化构建工具，功能强大，插件丰富而且简单易上手。虽然最近Gulp的功能被全能的Webpack蚕食了不少，很多项目已经完全依赖Webpack构建了，但Gulp本身还是非常好用的，值得一学。</p><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h2><p>通过yarn/npm安装gulp之后，需要配置的有两个地方，一个是gulp的入口文件gulpfile.js，另一个则是安装gulp的一系列插件</p><p>gulp自带的最常用的命令：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>src</code></td><td>从指定目录构建一个输入流</td></tr><tr><td><code>dest</code></td><td>构建一个输出流到指定目录</td></tr><tr><td><code>parallel</code></td><td>并行执行任务</td></tr><tr><td><code>series</code></td><td>顺序执行任务</td></tr><tr><td><code>watch</code></td><td>跟踪一个路径内的文件变化，有变化时触发指定的任务</td></tr></tbody></table><p>我们来构建一个最基本的gulp任务：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> style = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> src(<span class="hljs-string">'src/assets/styles/*.scss'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'src'</span> &#125;) <span class="hljs-comment">// base可以指定要忽略的路径符，之后的路径会被完整复制到目标路径</span>    .pipe(plugins.sass(&#123; <span class="hljs-attr">outputStyle</span>: <span class="hljs-string">'expanded'</span> &#125;)) <span class="hljs-comment">// outputStyle控制编译后的css文件风格</span>    .pipe(dest(<span class="hljs-string">'temp'</span>))&#125;</code></pre></div><p>一个任务就是一个函数，需要return一个函数执行，一般我们使用gulp的目的就是自动化打包文件，所以常常先使用<code>src</code>构造一个文件输入流，从目录读取文件，经过处理后再通过<code>dest</code>输出到指定的打包目录。gulp对文件流使用了类似管道pipe的处理概念，使用<code>pipe()</code>可以使用gulp的插件或者自定义方法对文件流进行任意操作。</p><p>同理，下面这样也是一个gulp任务</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> clean = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> del([ <span class="hljs-string">'dist'</span>, <span class="hljs-string">'temp'</span> ])&#125;</code></pre></div><p>使用node自带的del库对目标文件夹进行清理</p><h2 id="2-自动加载插件"><a href="#2-自动加载插件" class="headerlink" title="2. 自动加载插件"></a>2. 自动加载插件</h2><p>一般安装插件后我们需要<code>require</code>来使用，但通过安装一个专门用于加载插件的插件<code>gulp-load-plugins</code>，我们可以把这个过程进一步简化，因为gulp的插件都有固定的命名方式<code>gulp-&lt;name&gt;</code>，通过<code>gulp-load-plugins</code>可以使用<code>plugins.name</code>的方法来直接调用（命名转为驼峰式）</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> loadPlugins = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-load-plugins'</span>)<span class="hljs-keyword">const</span> plugins = loadPlugins() <span class="hljs-comment">// 之后便可在pipe里使用plugins.sass/plugins/babel这样来使用</span></code></pre></div><p>当然不要忘了先安装这些插件，<code>gulp-load-plugins</code>本身并不会帮你安装任何插件，只是把加载方式简化了。</p><h2 id="3-使用Brower-Sync调试"><a href="#3-使用Brower-Sync调试" class="headerlink" title="3. 使用Brower-Sync调试"></a>3. 使用Brower-Sync调试</h2><p>在gulp打包编译完成之后一般我们会打开浏览器进行调试预览，通过<code>brower-sync</code>这个库可以很好地简化这个流程，<code>brower-sync</code>本身并不依赖于gulp，二者是完全独立的库，gulp可以非常轻松地和其结合使用。</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200709221730499.png" srcset="/img/loading.gif" alt="image-20200709221730499"></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> browserSync = <span class="hljs-built_in">require</span>(<span class="hljs-string">'browser-sync'</span>)<span class="hljs-keyword">const</span> bs = browserSync.create()bs.init(&#123;    notify: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不弹窗提示</span>    port: <span class="hljs-number">2080</span>, <span class="hljs-comment">// 端口号</span>    open: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否马上打开浏览器页面</span>    server: &#123;        baseDir: [ <span class="hljs-string">'temp'</span>, <span class="hljs-string">'src'</span>, <span class="hljs-string">'public'</span> ], <span class="hljs-comment">// 项目目录</span>        <span class="hljs-comment">// 额外配置特定路由的转发</span>        <span class="hljs-comment">// 比如一些html文件里通过src='path'导入的路径/node_modules并不在上面三个目录里面</span>        <span class="hljs-comment">// 所以要转发到我们开发根目录下的node_modules</span>        routes: &#123;            <span class="hljs-string">'/node_modules'</span>: <span class="hljs-string">'node_modules'</span>          &#125;    &#125;&#125;)</code></pre></div><p>配置可以见官网</p><p><a href="https://browsersync.io/docs/options" target="_blank" rel="noopener">https://browsersync.io/docs/options</a></p><h2 id="4-使用watch跟踪文件变化"><a href="#4-使用watch跟踪文件变化" class="headerlink" title="4. 使用watch跟踪文件变化"></a>4. 使用watch跟踪文件变化</h2><p>非常简单，watch的第一个参数是要跟踪的路径，可以使用通配符，第二个就是要执行的任务。</p><div class="hljs"><pre><code class="hljs js">watch(<span class="hljs-string">'src/assets/styles/*.scss'</span>, style)</code></pre></div><p>要注意的是watch的函数签名为</p><div class="hljs"><pre><code class="hljs js">watch(globs, [options], [task])</code></pre></div><p>所以可以最多接受三个参数，路径可以是一个数组，比如<code>[&#39;input/*.js&#39;, &#39;!input/something.js&#39;]</code>，task是一个定义好的任务，可以用在这里用<code>series</code>和<code>parallel</code>来组合任务。</p><h2 id="5-Useref替换资源路径"><a href="#5-Useref替换资源路径" class="headerlink" title="5. Useref替换资源路径"></a>5. Useref替换资源路径</h2><p>在开发过程中，一些资源有时候我们可能是分散引入的，比如从node_modules下面引入，或者从多个js/css文件中引入。我们在打包时希望把这些用到的文件全部整合到一起然后放到一个指定的目录下面，useref插件就是做这个的。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> useref = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> (    src(<span class="hljs-string">'temp/**/*.html'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'temp'</span> &#125;)      .pipe(plugins.useref(&#123; <span class="hljs-attr">searchPath</span>: [ <span class="hljs-string">'temp'</span>, <span class="hljs-string">'.'</span> ] &#125;)) <span class="hljs-comment">// 引用资源搜索的目录，useref会先到temp下面找，找不到就到下一个路径，以此类推</span>      <span class="hljs-comment">// html js css</span>      .pipe(plugins.if(<span class="hljs-regexp">/\.js$/</span>, plugins.uglify())) <span class="hljs-comment">// 在进行打包的过程中还可以使用其他插件来压缩转化</span>      .pipe(plugins.if(<span class="hljs-regexp">/\.css$/</span>, plugins.cleanCss())) <span class="hljs-comment">// 这里的plugins.if也是一个gulp插件</span>      .pipe(        plugins.if(          /\.html$/,          plugins.htmlmin(&#123;            collapseWhitespace: <span class="hljs-literal">true</span>,            minifyCSS: <span class="hljs-literal">true</span>,            minifyJS: <span class="hljs-literal">true</span>          &#125;)        )      )      .pipe(dest(<span class="hljs-string">'dist'</span>))  )&#125;</code></pre></div><p>要注意的是到底合并哪些文件其实是需要在html内指定的</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- build:js assets/scripts/vendor.js --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/node_modules/jquery/dist/jquery.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/node_modules/popper.js/dist/umd/popper.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/node_modules/bootstrap/dist/js/bootstrap.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!-- endbuild --&gt;</span><span class="hljs-comment">&lt;!-- build:js assets/scripts/main.js --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"assets/scripts/main.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!-- endbuild --&gt;</span></code></pre></div><p>上面的注释非常重要，<code>build</code>和<code>endbuild</code>之间就是一个build block，其中的所有文件都会被useref提取打包整合成一个文件，而整合后的文件的文件名和存放路径也在注释中，比如上面的<code>vendor.js</code>和<code>main.js</code></p><h2 id="6-一个完整的gulpfile-js文件"><a href="#6-一个完整的gulpfile-js文件" class="headerlink" title="6. 一个完整的gulpfile.js文件"></a>6. 一个完整的gulpfile.js文件</h2><p>最后我们来看一个完整的定义文件</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; src, dest, parallel, series, watch &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp'</span>)<span class="hljs-keyword">const</span> del = <span class="hljs-built_in">require</span>(<span class="hljs-string">'del'</span>)<span class="hljs-keyword">const</span> browserSync = <span class="hljs-built_in">require</span>(<span class="hljs-string">'browser-sync'</span>)<span class="hljs-keyword">const</span> loadPlugins = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-load-plugins'</span>)<span class="hljs-keyword">const</span> plugins = loadPlugins()<span class="hljs-keyword">const</span> bs = browserSync.create()<span class="hljs-keyword">const</span> clean = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> del([ <span class="hljs-string">'dist'</span>, <span class="hljs-string">'temp'</span> ])&#125;<span class="hljs-keyword">const</span> style = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> src(<span class="hljs-string">'src/assets/styles/*.scss'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'src'</span> &#125;)    .pipe(plugins.sass(&#123; <span class="hljs-attr">outputStyle</span>: <span class="hljs-string">'expanded'</span> &#125;))    .pipe(dest(<span class="hljs-string">'temp'</span>))    .pipe(bs.reload(&#123; <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> &#125;))&#125;<span class="hljs-keyword">const</span> script = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> src(<span class="hljs-string">'src/assets/scripts/*.js'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'src'</span> &#125;)    .pipe(plugins.babel(&#123; <span class="hljs-attr">presets</span>: [ <span class="hljs-string">'@babel/preset-env'</span> ] &#125;))    .pipe(dest(<span class="hljs-string">'temp'</span>))    .pipe(bs.reload(&#123; <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> &#125;))&#125;<span class="hljs-keyword">const</span> page = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> src(<span class="hljs-string">'src/**/*.html'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'src'</span> &#125;)    .pipe(plugins.swig(&#123; data, <span class="hljs-attr">defaults</span>: &#123; <span class="hljs-attr">cache</span>: <span class="hljs-literal">false</span> &#125; &#125;))    .pipe(dest(<span class="hljs-string">'temp'</span>))    .pipe(bs.reload(&#123; <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> &#125;))&#125;<span class="hljs-keyword">const</span> image = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> src(<span class="hljs-string">'src/assets/images/**'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'src'</span> &#125;)    .pipe(plugins.imagemin())    .pipe(dest(<span class="hljs-string">'dist'</span>))&#125;<span class="hljs-keyword">const</span> font = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> src(<span class="hljs-string">'src/assets/fonts/**'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'src'</span> &#125;)    .pipe(plugins.imagemin())    .pipe(dest(<span class="hljs-string">'dist'</span>))&#125;<span class="hljs-keyword">const</span> extra = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> src(<span class="hljs-string">'public/**'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'public'</span> &#125;).pipe(dest(<span class="hljs-string">'dist'</span>))&#125;<span class="hljs-keyword">const</span> start = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-comment">// 代码文件</span>  watch(<span class="hljs-string">'src/assets/styles/*.scss'</span>, style)  watch(<span class="hljs-string">'src/assets/scripts/*.js'</span>, script)  watch(<span class="hljs-string">'src/**/*.html'</span>, page)  <span class="hljs-comment">// 资源文件</span>  watch(    [ <span class="hljs-string">'src/assets/images/**'</span>, <span class="hljs-string">'src/assets/fonts/**'</span>, <span class="hljs-string">'public/**'</span> ],    bs.reload  )  bs.init(&#123;    notify: <span class="hljs-literal">false</span>,    port: <span class="hljs-number">2080</span>,    open: <span class="hljs-literal">true</span>,    server: &#123;      baseDir: [ <span class="hljs-string">'temp'</span>, <span class="hljs-string">'src'</span>, <span class="hljs-string">'public'</span> ],      routes: &#123;        <span class="hljs-string">'/node_modules'</span>: <span class="hljs-string">'node_modules'</span>      &#125;    &#125;  &#125;)&#125;<span class="hljs-keyword">const</span> useref = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> (    src(<span class="hljs-string">'temp/**/*.html'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'temp'</span> &#125;)      .pipe(plugins.useref(&#123; <span class="hljs-attr">searchPath</span>: [ <span class="hljs-string">'temp'</span>, <span class="hljs-string">'.'</span> ] &#125;))      <span class="hljs-comment">// html js css</span>      .pipe(plugins.if(<span class="hljs-regexp">/\.js$/</span>, plugins.uglify()))      .pipe(plugins.if(<span class="hljs-regexp">/\.css$/</span>, plugins.cleanCss()))      .pipe(        plugins.if(          /\.html$/,          plugins.htmlmin(&#123;            collapseWhitespace: <span class="hljs-literal">true</span>,            minifyCSS: <span class="hljs-literal">true</span>,            minifyJS: <span class="hljs-literal">true</span>          &#125;)        )      )      .pipe(dest(<span class="hljs-string">'dist'</span>))  )&#125;<span class="hljs-comment">// 并行执行文件编译</span><span class="hljs-keyword">const</span> compile = parallel(style, script, page)<span class="hljs-comment">// 打包上线之前执行的任务</span><span class="hljs-keyword">const</span> build = series(clean, parallel(compile, image, font, extra), useref)<span class="hljs-comment">// 开发编译并打开Broswer</span><span class="hljs-keyword">const</span> serve = series(compile, start)<span class="hljs-built_in">module</span>.exports = &#123;  clean,  build,  start,  serve&#125;</code></pre></div><h3 id="基础任务"><a href="#基础任务" class="headerlink" title="基础任务"></a>基础任务</h3><table><thead><tr><th>任务名</th><th>功能</th></tr></thead><tbody><tr><td><code>clean</code></td><td>清理temp和dist文件夹</td></tr><tr><td><code>style</code></td><td>编译scss样式文件为css文件</td></tr><tr><td><code>script</code></td><td>编译js文件，通过pipe先进行eslint语法校验再进行babel转译</td></tr><tr><td><code>page</code></td><td>编译html模板文件，渲染swig内容</td></tr><tr><td><code>image</code></td><td>打包静态图片资源</td></tr><tr><td><code>font</code></td><td>打包静态字体资源</td></tr><tr><td><code>extra</code></td><td>打包public目录下的其他静态资源</td></tr><tr><td><code>start</code></td><td>启动浏览器显示项目，并使用watch跟踪src目录下的html/js/css文件变化进行热更新</td></tr><tr><td><code>useref</code></td><td>对html文档中build block注释内的js/css资源导入进行处理，把引用到的文件进行合并打包，并在生成的html内替换</td></tr></tbody></table><h3 id="高级任务"><a href="#高级任务" class="headerlink" title="高级任务"></a>高级任务</h3><table><thead><tr><th>任务名</th><th>功能</th></tr></thead><tbody><tr><td><code>compile</code></td><td>并行执行style/script/page任务，编译scss/js/html文件</td></tr><tr><td><code>build</code></td><td>先进行clean，然后并行执行compile/image/font/extra任务，最后执行useref进行引用替换</td></tr><tr><td><code>serve</code></td><td>先执行compile在执行start，用于开发调试</td></tr></tbody></table><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>使用<code>yarn serve</code>命令即可编译项目并自动打开浏览器预览</p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>使用<code>yarn build</code>命令即可编译并打包所有资源到发布目录dist</p>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习笔记 (chap.1.4) - Javascript性能优化</title>
    <link href="/2020/June/Javascript-performance/"/>
    <url>/2020/June/Javascript-performance/</url>
    
    <content type="html"><![CDATA[<h1 id="Javascript性能优化"><a href="#Javascript性能优化" class="headerlink" title="Javascript性能优化"></a>Javascript性能优化</h1><h2 id="GC常见算法"><a href="#GC常见算法" class="headerlink" title="GC常见算法"></a>GC常见算法</h2><p>常用的内存回收(Garbage Collection)算法整理：</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/GC%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" alt="GC回收算法"></p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>可以使用Jsperf来进行Javascript代码的性能测试和对比</p><p><a href="https://jsperf.com/yif-global-variable" target="_blank" rel="noopener">https://jsperf.com/yif-global-variable</a></p><h3 id="1-慎用全局变量"><a href="#1-慎用全局变量" class="headerlink" title="1. 慎用全局变量"></a>1. 慎用全局变量</h3><ul><li>全局变量定义在全局执行上下文，是所有作用域链的顶端（根作用域）</li><li>由于一直存在于根作用域，难以被GC（内存回收）清理，会一直存在知道程序退出</li><li>容易被局部作用域的同名变量遮蔽或者污染</li></ul><h3 id="2-将使用中无法避免的全局变量放入缓存"><a href="#2-将使用中无法避免的全局变量放入缓存" class="headerlink" title="2. 将使用中无法避免的全局变量放入缓存"></a>2. 将使用中无法避免的全局变量放入缓存</h3><p>例如为了获取获取dom元素节点，在需要大量获取document节点的函数中缓存全局变量document可以增加性能</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 不使用对象缓存</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBtnWithoutCache</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> btn1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn1'</span>)    <span class="hljs-keyword">let</span> btn2 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn2'</span>)    <span class="hljs-keyword">let</span> btn3 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn3'</span>)&#125;<span class="hljs-comment">// 使用对象缓存</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBtnWitCache</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">document</span>    <span class="hljs-keyword">let</span> btn1 = obj.getElementById(<span class="hljs-string">'btn1'</span>)    <span class="hljs-keyword">let</span> btn2 = obj.getElementById(<span class="hljs-string">'btn2'</span>)    <span class="hljs-keyword">let</span> btn3 = obj.getElementById(<span class="hljs-string">'btn3'</span>)&#125;</code></pre></div><p>其原理是通过缓存加快对document全局变量的访问速度，不需要每次都从根作用域重新查找</p><h3 id="3-通过原型链添加方法"><a href="#3-通过原型链添加方法" class="headerlink" title="3. 通过原型链添加方法"></a>3. 通过原型链添加方法</h3><p>原型链是所有对象共享的，比起在每个对象的this上增加方法，使用原型链的性能会更好</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200630155359315.png" srcset="/img/loading.gif" alt="image-20200630155359315"></p><h3 id="4-避免闭包陷阱"><a href="#4-避免闭包陷阱" class="headerlink" title="4. 避免闭包陷阱"></a>4. 避免闭包陷阱</h3><p>闭包会产生额外的对象引用，会使得本身应该被释放回收的对象由于闭包内的引用而无法被回收</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn'</span>)  el.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)  &#125;&#125;foo()</code></pre></div><p>上面的el由于onclick函数的闭包会一直存在，使得即便btn节点已经从dom中被移除了也不会被回收，因为el一直对其进行引用</p><h3 id="5-避免属性访问方法"><a href="#5-避免属性访问方法" class="headerlink" title="5. 避免属性访问方法"></a>5. 避免属性访问方法</h3><p>Javascript中没有传统面向对象语言的属性访问限制，一个对象里所有属性都是对外暴露的（这里没有讨论ES2015之后的class），在这种情况下，使用对象访问方法反而会降低性能</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">'Me'</span>    <span class="hljs-keyword">this</span>.age = <span class="hljs-number">18</span>    <span class="hljs-keyword">this</span>.getAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age    &#125;&#125;</code></pre></div><p>上面的<code>getAge</code>就是一种属性访问方法，我们可以和直接的属性访问对比：</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200630162233394.png" srcset="/img/loading.gif" alt="image-20200630162233394"></p><p>可以发现直接访问性能明显更好，这也是符合直觉的</p><h3 id="6-For循环优化"><a href="#6-For循环优化" class="headerlink" title="6. For循环优化"></a>6. For循环优化</h3><p>如果for循环的终止条件是一个定值，最好直接把它取出来缓存成一个变量</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 使用len变量来直接获取数组长度，避免重复访问</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;    <span class="hljs-built_in">console</span>.log(i)&#125;</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200630164130926.png" srcset="/img/loading.gif" alt="image-20200630164130926"></p><p>再对比一下常用的四种for方法</p><p><a href="https://jsperf.com/yif-for-loop-performance" target="_blank" rel="noopener">https://jsperf.com/yif-for-loop-performance</a></p><ul><li>forEach (ES5引入)</li><li>for</li><li>for in</li><li>for of (ES2015引入，只能遍历可迭代对象，如数组，不能直接遍历对象，可以遍历<code>Object.values()</code>或者<code>Object.keys()</code>)</li></ul><p>测试的数组</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arrList = []<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;    arrList.push(i)&#125;</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200630180407937.png" srcset="/img/loading.gif" alt="image-20200630180407937"></p><p>可以发现forEach的速度是最快的（但这个结果或许并不准确，关于forEach和for的对比争论在stackoverflow上很多，两者其实在不同场景各有胜负，不过从语义角度而言，forEach作为比较新的语法表达更简洁易读，但要注意的是forEach不能使用break/continue来中断，而ES2015/ES6新加入的for of则可以）</p><h3 id="7-使用文档碎片优化节点添加"><a href="#7-使用文档碎片优化节点添加" class="headerlink" title="7. 使用文档碎片优化节点添加"></a>7. 使用文档碎片优化节点添加</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 直接往body上添加节点元素</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-keyword">let</span> oP = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'p'</span>)    oP.innerHTML = i    <span class="hljs-built_in">document</span>.body.appendChild(oP)&#125;<span class="hljs-comment">// 使用documentFragment</span><span class="hljs-keyword">const</span> fragEle = <span class="hljs-built_in">document</span>.createDocumentFragment()<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-keyword">let</span> oP = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'p'</span>)    oP.innerHTML = i    fragEle.appendChild(oP)&#125;<span class="hljs-built_in">document</span>.body.appendChild(fragEle)</code></pre></div><p>早期批量操作dom的开销比较大，使用<code>Fragment</code>可以很好的降低开销，因为是先把文档操作放到虚拟的<code>Fragment</code>上再一次性插入到document，<code>Fragment</code>就相当于占位符，在插入之后本身就会销毁</p><p>现代浏览器已经对这类批量文档操作做了优化，实际的运行速度上使用文档碎片并不会有很大的优势了，但是从语义上讲文档碎片依然是很好的选择，因为它表明了不需要马上对页面dom进行更新操作</p><h3 id="7-使用克隆节点代替创造节点"><a href="#7-使用克隆节点代替创造节点" class="headerlink" title="7. 使用克隆节点代替创造节点"></a>7. 使用克隆节点代替创造节点</h3><p>当需要插入新节点时，另一个优化的方法是使用<code>cloneNode</code>函数，复制一个已有的同类节点再进行更改</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;    <span class="hljs-keyword">let</span> newP = oldP.cloneNode(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 参数表示是否进行深拷贝</span>    newP.innerHTML = i    <span class="hljs-built_in">document</span>.body.appendChild(newP)&#125;</code></pre></div><p><code>cloneNode</code>比使用<code>createElement</code>性能更好，尤其批量创造同类节点</p><h3 id="8-直接量替换new-Object"><a href="#8-直接量替换new-Object" class="headerlink" title="8. 直接量替换new Object"></a>8. 直接量替换new Object</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 使用new</span><span class="hljs-keyword">let</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>)a1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>a1[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>a1[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span><span class="hljs-comment">// 直接量</span><span class="hljs-keyword">let</span> a2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</code></pre></div><p>这个非常好理解，使用直接量的性能更好</p>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习笔记 (chap.1.3) - ES2015</title>
    <link href="/2020/June/Javascript-ES2015/"/>
    <url>/2020/June/Javascript-ES2015/</url>
    
    <content type="html"><![CDATA[<h1 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h1><h2 id="1-let和const的块作用域"><a href="#1-let和const的块作用域" class="headerlink" title="1. let和const的块作用域"></a>1. let和const的块作用域</h2><p>let和const的块级作用域是JS很大的一个进步，尤其是let在循环中的使用很有意思</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;      <span class="hljs-built_in">console</span>.log(i)    &#125;&#125;</code></pre></div><p>像上面那样在循坏的内外层使用同名变量i但却不会相互覆盖</p><p>同时我们也可以这样</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> elements = [&#123;&#125;, &#123;&#125;, &#123;&#125;]<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;elements.length;i++) &#123;  elements[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(i)  &#125;&#125;elements[<span class="hljs-number">0</span>].onclick() <span class="hljs-comment">// 0</span></code></pre></div><p>这里通过闭包每个i都被单独地记住了</p><p>另外一个值得注意的地方是</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;  <span class="hljs-keyword">let</span> i = <span class="hljs-string">'foo'</span>  <span class="hljs-built_in">console</span>.log(i)&#125; <span class="hljs-comment">// 输出三次foo</span></code></pre></div><p>这里循环逻辑内部的i也不受影响，我们可以这样来理解，上面的代码其实等同于：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-keyword">let</span> i = <span class="hljs-string">'foo'</span> <span class="hljs-comment">// 块作用域内部的i的独立的</span>  <span class="hljs-built_in">console</span>.log(i)&#125;i++<span class="hljs-comment">// 以上重复三次</span></code></pre></div><p>最后let和const都不会自动提升，必须声明后才能使用，否则抛出RefError</p><p>但要特别注意的是：<strong>所谓的不会提升(hoist)指的是初始化不会提升，而不是声明不会提升</strong></p><p>let和const的声明依然会被提升，这是Javascript的底层机制决定的，Javascript引擎会在进入每个作用域时寻找该作用域内部的所有变量声明并创建它们</p><p>唯一的区别就是，var还会执行初始化（undefined），而let和const不会，这就是为何在赋值前使用let和const会抛出异常的真正原因</p><p><a href="https://www.jianshu.com/p/0f49c88cf169" target="_blank" rel="noopener">参考资料: let存在变量提升吗？</a></p><h2 id="2-Proxy"><a href="#2-Proxy" class="headerlink" title="2. Proxy"></a>2. Proxy</h2><p>Proxy专门用于对对象进行代理操作，是比Object.defineProperty更灵活便捷的方法。Proxy内置了13个代理方法handler，又称为捕捉器，比如最常用的set和get</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;    name: <span class="hljs-string">'Tom'</span>,    age: <span class="hljs-number">20</span>&#125;<span class="hljs-keyword">const</span> personProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(person, &#123;    <span class="hljs-keyword">get</span>(target, property) &#123;        <span class="hljs-keyword">return</span> property <span class="hljs-keyword">in</span> target ? target[property] : <span class="hljs-string">'default'</span>    &#125;,    <span class="hljs-keyword">set</span>(target, property, value) &#123;      <span class="hljs-comment">// 捕捉set进来的属性和值，可以进行任意额外的操作</span>      <span class="hljs-keyword">if</span> (property === <span class="hljs-string">'age'</span>) &#123;          <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Number</span>.isInteger(value)) &#123;              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;value&#125;</span> is not an integer`</span>)          &#125;      &#125;      target[property] = value      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// set方法需要返回一个bool值表示是否成功</span>    &#125;&#125;)</code></pre></div><p>Proxy比Object.defineProperty更为强大，事实上Proxy本身就自带了一个defineProperty的捕捉器</p><p>更重要的，Proxy可以方便地劫持数组操作，这也是Vue3.0使用Proxy代替了defineProperty的原因之一</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> list = []<span class="hljs-keyword">const</span> listProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(list, &#123;  <span class="hljs-keyword">set</span>(target, property, value) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'set'</span>, property, value)    target[property] = value    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  &#125;&#125;)listProxy.push(<span class="hljs-number">100</span>)<span class="hljs-comment">// set 0 100</span><span class="hljs-comment">// set length 1</span></code></pre></div><p>第一行的0表示数组下标0， 第二行的length表示对数组长度的操作。可见Proxy自己内部知道数组是如何被操作的，不再需要我们进行干涉，这比defineProperty方便了很多</p><p>Proxy对于对象的劫持是非侵入性的，可以任意代理一个已经被定义好的对象和其中的变量，而defineProperty则是一开始就需要声明好</p><h2 id="3-Reflect"><a href="#3-Reflect" class="headerlink" title="3. Reflect"></a>3. Reflect</h2><p>Reflect本身提供了一整套对象操作的拦截函数，可以说和Proxy有点相辅相成的感觉(特别是两者的自带方法都是13个)</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;    name: <span class="hljs-string">'Tom'</span>,    age: <span class="hljs-number">20</span>&#125;<span class="hljs-keyword">const</span> personProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(person, &#123;    <span class="hljs-keyword">get</span>(target, property) &#123;      <span class="hljs-built_in">console</span>.log(target, property)      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, property)    &#125;&#125;)</code></pre></div><p>Reflect可以统一对象的操作方式。传统的JS里针对对象的操作种类繁多，而且语法差异很大，非常不规范，如下例</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;    name: <span class="hljs-string">'Tom'</span>,    age: <span class="hljs-number">20</span>&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'name'</span> <span class="hljs-keyword">in</span> person) <span class="hljs-comment">// 判断是否存在属性</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">delete</span> person[<span class="hljs-string">'age'</span>]) <span class="hljs-comment">// 删除特定的属性</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(person)) <span class="hljs-comment">// 获取所有属性名</span><span class="hljs-comment">// 使用Reflect统一操作</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.has(person, <span class="hljs-string">'name'</span>))<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.deleteProperty(person, <span class="hljs-string">'age'</span>))<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.ownKeys(person))</code></pre></div><h2 id="4-Set"><a href="#4-Set" class="headerlink" title="4. Set"></a>4. Set</h2><p>Set类似Python等语言中的集合，是数学概念集合的实现，最有用的地方就是去重</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()s.add(<span class="hljs-number">1</span>).add(<span class="hljs-number">2</span>).add(<span class="hljs-number">2</span>).add(<span class="hljs-number">3</span>)<span class="hljs-built_in">console</span>.log(s) <span class="hljs-comment">// Set &#123;1, 2, 3&#125;</span>s.forEach(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))<span class="hljs-comment">// 注意Set是一个对象，并没有索引，所以不能使用for in</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> s) &#123;  <span class="hljs-built_in">console</span>.log(s)&#125;<span class="hljs-built_in">console</span>.log(s.size) <span class="hljs-comment">// 获取大小</span><span class="hljs-built_in">console</span>.log(s.has(<span class="hljs-number">100</span>)) <span class="hljs-comment">// 是否具有某个元素</span><span class="hljs-built_in">console</span>.log(s.delete(<span class="hljs-number">3</span>)) <span class="hljs-comment">// 成功删除返回true，否则false</span><span class="hljs-built_in">console</span>.log(s.clear()) <span class="hljs-comment">// 清空集合</span><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]<span class="hljs-keyword">const</span> result = [ ... new <span class="hljs-built_in">Set</span>(arr)]<span class="hljs-built_in">console</span>.log(result)</code></pre></div><h2 id="5-Map"><a href="#5-Map" class="headerlink" title="5. Map"></a>5. Map</h2><p>即便有计算属性这个对象字面量的增强版，可以给对象添加动态的属性名，比如</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  [<span class="hljs-built_in">Math</span>.ramdom()] : <span class="hljs-number">10</span>,  [<span class="hljs-number">1</span> + <span class="hljs-number">1</span>] : <span class="hljs-number">20</span>&#125;</code></pre></div><p>这种机制仍然有一个很大的限制，就是无法使用对象作为变量名</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  [&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">2</span>&#125;] : <span class="hljs-number">10</span>,  [&#123;<span class="hljs-attr">b</span>: <span class="hljs-number">3</span>&#125;]: <span class="hljs-number">30</span>&#125;<span class="hljs-built_in">console</span>.log(obj) <span class="hljs-comment">// &#123; '[object Object]': 30 &#125;</span><span class="hljs-built_in">console</span>.log(obj[&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">2</span>&#125;]) <span class="hljs-comment">// 30 错误值</span></code></pre></div><p>可以看到两个属性名其实都被toString之后再当做属性名，导致彼此覆盖掉了，因为任何对象toString = <code>[object Object]</code>。也就是说，传统的JS里对象的属性名只能为字符串。</p><p>Map就可以解决这个问题</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<span class="hljs-keyword">const</span> tom = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">10</span>&#125;m.set(tom, <span class="hljs-number">10</span>)<span class="hljs-built_in">console</span>.log(m) <span class="hljs-comment">// Map &#123; &#123; a: 10 &#125; =&gt; 10 &#125;</span><span class="hljs-built_in">console</span>.log(m.get(tom)) <span class="hljs-comment">// 10 正确值</span><span class="hljs-comment">// 和Set一样具有常用的基本操作</span><span class="hljs-comment">// m.has()</span><span class="hljs-comment">// m.delete()</span><span class="hljs-comment">// m.clear()</span></code></pre></div><h2 id="6-Symbol"><a href="#6-Symbol" class="headerlink" title="6. Symbol"></a>6. Symbol</h2><p>Symbol是很有意思的一个数据类型，类似传统静态语言中常用的UID，专门用于生成一个不会重复的变量</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'Hi'</span>) <span class="hljs-comment">// 使用for来注册一个全局Symbol</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>.keyFor(x)) <span class="hljs-comment">// Hi</span></code></pre></div><p>如果不使用Symbol.for来注册，每次Symbol都会生成一个不同的新值</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'Hi'</span>)<span class="hljs-keyword">let</span> y = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'Hi'</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'x'</span>) === <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'x'</span>)) <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(x === y) <span class="hljs-comment">// true</span></code></pre></div><p>Symbol的特性可以用来创造对象内部的私有成员</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-built_in">Symbol</span>()<span class="hljs-keyword">const</span> person = &#123;  [name]: <span class="hljs-string">'Yikhan'</span>,  say() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>[name])  &#125;&#125;person.say() <span class="hljs-comment">// Yikhan</span></code></pre></div><p>进一步来说，因为这个功能Symbol也成为了JS的一些内置接口名称，比如<code>[Symbol.toStringTag]</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  [<span class="hljs-built_in">Symbol</span>.toStringTag]: <span class="hljs-string">'Awesome Name'</span>,  foo: <span class="hljs-number">10</span>&#125;<span class="hljs-built_in">console</span>.log(obj.toString()) <span class="hljs-comment">// [object Awesome Name]</span></code></pre></div><p>通过Symbol定义的属性，无论是使用for in还是<code>Object.keys()</code>，亦或是<code>JSON.stringify()</code>都是获取不到的，会直接被这些方法忽略掉</p><h2 id="7-Iterator"><a href="#7-Iterator" class="headerlink" title="7. Iterator"></a>7. Iterator</h2><p>迭代器接口直接和for of操作符相关，只有实现了这个接口才能调用for of来遍历元素</p><p>要注意的是for of不能直接遍历普通的Object，只能遍历<code>Object.values(obj)</code></p><p>迭代器接口的关键字就是在对象中实现<code>[Symbol.iterator]</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  store: [ <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'baz'</span> ],  [<span class="hljs-built_in">Symbol</span>.iterator]: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> &#123;      next: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> result = &#123;          value: <span class="hljs-keyword">this</span>.store[index],          done: index &gt;= <span class="hljs-keyword">this</span>.store.length        &#125;        index++        <span class="hljs-keyword">return</span> result      &#125;    &#125;  &#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> obj) &#123;  <span class="hljs-built_in">console</span>.log(item) <span class="hljs-comment">// foo bar baz</span>&#125;</code></pre></div><p>如果结合生成器generator，还可以进一步简化这个方法</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  store: [ <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'baz'</span> ],  [<span class="hljs-built_in">Symbol</span>.iterator]: <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.store) &#123;      <span class="hljs-keyword">yield</span> item    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习笔记 (chap.1.2) - Promise</title>
    <link href="/2020/June/Javascript-promise/"/>
    <url>/2020/June/Javascript-promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="1-为什么不能把Promise-resolve当做函数变量来使用"><a href="#1-为什么不能把Promise-resolve当做函数变量来使用" class="headerlink" title="1. 为什么不能把Promise.resolve当做函数变量来使用"></a>1. 为什么不能把Promise.resolve当做函数变量来使用</h2><p>如果试图直接调用：</p><div class="hljs"><pre><code class="hljs js">FunctionThatNeedsCallback(Prmose.resolve) <span class="hljs-comment">// TypeError: PromiseResolve called on non-object</span></code></pre></div><p>最简单的复现方法是：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>).then(<span class="hljs-built_in">Promise</span>.resolve) <span class="hljs-comment">// TypeError: PromiseResolve called on non-object</span></code></pre></div><p>因为Promise.resolve是一个需要context的函数，好比一个里面使用了this的函数，是不允许脱离context使用的。<br>所以要么直接在一个对象上使用 <code>v =&gt; Prmose.resolve(v)</code>，要么就要手动绑定 <code>Promise.resolve.bind(Promise)</code></p><h2 id="2-Promise中的值穿透"><a href="#2-Promise中的值穿透" class="headerlink" title="2. Promise中的值穿透"></a>2. Promise中的值穿透</h2><p>和上面那个例子相关，假如有下面这样的代码，结果会打印出什么呢？</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>).then(<span class="hljs-number">2</span>).then(<span class="hljs-built_in">console</span>.log)</code></pre></div><p>答案是1，这是因为如果then的参数不是一个函数，就会把上一层传入的值直接传递给下一层 (类似直接 <code>return this</code>)，这就是值穿透现象。</p><p>通过具体的代码实现，可以比较容易地理解：</p><div class="hljs"><pre><code class="hljs js">successCallback =  <span class="hljs-keyword">typeof</span> successCallback === <span class="hljs-string">'function'</span>    ? successCallback    : <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value <span class="hljs-comment">// 如果callback不是函数，则返回传入的值</span>failCallback =  <span class="hljs-keyword">typeof</span> failCallback === <span class="hljs-string">'function'</span>    ? failCallback    : <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> reason <span class="hljs-comment">// 如果callback不是函数，则返回传入的值</span></code></pre></div><h2 id="3-await的执行顺序"><a href="#3-await的执行顺序" class="headerlink" title="3. await的执行顺序"></a>3. await的执行顺序</h2><p>在异步编程里面常见的知识点有两个，一个是微任务和宏任务的异步执行顺序，另一个就是以Promise为主的异步理解。其中个人觉得最容易被错误理解的不是Promise本身，而是await这个语法糖。众所周知，async-await关键字本质上还是generator和Promise，一个async函数默认会返回一个Promise</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 start'</span>)&#125;<span class="hljs-keyword">let</span> r = fn1() <span class="hljs-comment">// fn1 start</span><span class="hljs-built_in">console</span>.log(r) <span class="hljs-comment">// Promise &#123; undefined &#125;</span></code></pre></div><p>如果没有await，在函数内部即使有异步操作也不会以异步的方式执行，await就好比generator中的yield关键字，我们下面用一个完整的例子来具体分析await</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 start'</span>)  fn2()  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 end'</span>)&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn2 start'</span>)  <span class="hljs-keyword">await</span> fn3()  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn2 end'</span>)&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn3</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn3 start'</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;fn1()<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'Promise'</span>).then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(value))<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>)</code></pre></div><p>当fn1当中不使用await时，执行顺序为：</p><div class="hljs"><pre><code class="hljs text">fn1 startfn2 startfn3 startfn1 endfinallyfn2 endPromise</code></pre></div><p>我们可以注意到fn1 end和fn2 end的输出区别，在fn2中由于使用了await，后面的log语句被放到了Promise中执行，也就是进入了异步队列，因此最后主程序的finally打印之后才打印fn2 end</p><p>而fn1 end是直接打印的，这正是因为我们没有在fn1中使用await，所以fn2()后面的log是以同步的方式运行的。理解了这一点之后，我们可以很容易发现await其实就是Promise.resolve，两者在语义上是一致的，任何在await之后的代码都会被放到Promise中，在then里面才会运行</p><p><a href="https://www.zhihu.com/question/268007969" target="_blank" rel="noopener"><strong>值得注意的是，关于await具体的实现V8引擎也几经更改，可参考这个知乎回答</strong></a></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 start'</span>)  <span class="hljs-keyword">await</span> fn2()  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 end'</span>)&#125;<span class="hljs-comment">// 等价于</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 start'</span>)  <span class="hljs-built_in">Promise</span>.resolve(fn2())    .then(<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 end'</span>))&#125;</code></pre></div><p>当我们把await和Promise.resolve联系起来之后，就会很容易理解一个面试题的常考点，就是await同一行的函数会被立即执行，之后的代码才会被放到then里面，所以fn2 start和fn3 start都是马上就打印出来了</p><p>如果我们在<code>fn2()</code>前面加个await的话，打印顺序就不一样了</p><div class="hljs"><pre><code class="hljs text">fn1 startfn2 startfn3 startfinallyfn2 endPromisefn1 end</code></pre></div><p>可以发现fn1 end现在最后才会打印，甚至晚于fn2 end。这是也因为await同一行的函数会被立即执行，就好比<code>Promise.resolve(fn2())</code>里的fn2是马上执行的，其返回值就是resolve出去的对象一样，当执行fn2时，fn2内部也有一个await，所以fn3被马上执行，而后面的打印函数被放入了then里面，所以这里fn2中先产生了Promise，率先进入异步队列。而当执行栈再次回到fn1之后，才把fn1后面的log放入then，要晚于fn2</p>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习笔记 (chap.1.1) - 函数式编程</title>
    <link href="/2020/June/Javascript-exp/"/>
    <url>/2020/June/Javascript-exp/</url>
    
    <content type="html"><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="1-柯里化"><a href="#1-柯里化" class="headerlink" title="1. 柯里化"></a>1. 柯里化</h2><p>函数式编程的基础，使用了高阶函数的思想，利用闭包把接受多个参数的函数封装成单参数函数，配合组合使用函数compose构成了函数式编程的重点技术</p><p>如何实现curry</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curriedFunc</span>(<span class="hljs-params">...args</span>) </span>&#123;    <span class="hljs-comment">//* 使用fn.length获得fn定义时的参数数量，fn通过闭包被缓存</span>    <span class="hljs-keyword">if</span> (args.length &lt; fn.length) &#123;      <span class="hljs-comment">//* 参数数量不够，应该返回柯里化后的函数</span>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...localArgs</span>) </span>&#123;        <span class="hljs-comment">//* 继续递归返回</span>        <span class="hljs-comment">//* 把上一层递归的args和这个函数会接收到的参数合并</span>        <span class="hljs-keyword">return</span> curriedFunc(...args.concat([ ...localArgs ]))      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//* 参数数量够了，可以运行fn了</span>      <span class="hljs-keyword">return</span> fn(...args)    &#125;  &#125;&#125;</code></pre></div><h2 id="2-组合函数"><a href="#2-组合函数" class="headerlink" title="2. 组合函数"></a>2. 组合函数</h2><p>把一组需要组合的函数按照从右到左的顺序依次执行，注意要组合的函数必须都是单参数函数，也就是一元函数，所以常常需要和curry化配合使用</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//* 组合函数原理模拟</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params">...funcs</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;    <span class="hljs-keyword">return</span> funcs.reduceRight(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">acc, func</span>) </span>&#123;      <span class="hljs-keyword">return</span> func(acc)    &#125;, value)  &#125;&#125;<span class="hljs-keyword">const</span> reverse = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> arr.reverse()<span class="hljs-keyword">const</span> first = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> arr[<span class="hljs-number">0</span>]<span class="hljs-keyword">const</span> toUpperCase = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> str.toUpperCase()<span class="hljs-keyword">const</span> f = compose(toUpperCase, first, reverse)<span class="hljs-built_in">console</span>.log(f([ <span class="hljs-string">'ant'</span>, <span class="hljs-string">'bat'</span>, <span class="hljs-string">'cab'</span> ])) <span class="hljs-comment">// C B A</span></code></pre></div><h2 id="3-Point-free"><a href="#3-Point-free" class="headerlink" title="3. Point-free"></a>3. Point-free</h2><p>在组合函数的基础上，为了使函数更方便组合，可以约定让函数的第一个参数接受方法，第二个参数接受数据，这种方法优先的模式使得组合函数非常简单直接</p><p>当我们组合一系列的函数时，我们实际上就是在按一定的步骤组合方法，并没有提及数据，这和传统的过程式编程完全不同，也是函数式编程个人觉得最有魅力的地方，其简洁和老程序猿嗤之以鼻的面条代码刚好是两个极端</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 可以很直观地知道我们先要执行的步骤，而完全没有提及变量或者数据本身</span><span class="hljs-keyword">const</span> firstLetterToUpper = fp.flowRight(  fp.join(<span class="hljs-string">'. '</span>),  fp.map(fp.flowRight(fp.toUpper, fp.first())),  fp.split(<span class="hljs-string">' '</span>))</code></pre></div><p>lodash/fp这个库里实现了lodash里功能函数的Point-free版本(所以专门放在了fp这个模块下)</p><h2 id="4-函子Functor"><a href="#4-函子Functor" class="headerlink" title="4. 函子Functor"></a>4. 函子Functor</h2><h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>函子是我以前比较陌生的概念，基本从未看到其真正的使用</p><p>函子的本质类似面向对象里面的私有变量封装，传统的函数式编程要求函数为纯函数(Pure Function)，也就是没有任何副作用的函数</p><blockquote><p>副作用：函数执行时不引起其他变量的变化，函数没有中间中间状态</p></blockquote><p>在实际应用中，除了功能单一的功能性函数，大部分业务函数都不是纯函数，副作用无可避免，所以函子的概念应运而生</p><p>函子把要被改变的变量和改变它的方法封装为一个class，和面向对象不同的是，这个改变它的方法并不是一个确定的函数，而是从外部传入一个函数</p><p>同时每次操作都会返回一个新的函子，这样就可以进行链式操作</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//* SECTION 容器 - 用于封装会被改变的值，以及改变它的方法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(value) &#123;    <span class="hljs-keyword">this</span>._value = value  &#125;  <span class="hljs-comment">//* 使用静态函数封装构造函数，这样外面调用的时候就不需要使用new</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span>(value) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Container(value)  &#125;  <span class="hljs-comment">//* map封装了任何试图改动_value的行为，并且总是返回一个新的容器</span>  map(fn) &#123;    <span class="hljs-keyword">return</span> Container.of(fn(<span class="hljs-keyword">this</span>._value))  &#125;&#125;<span class="hljs-comment">//* !SECTION</span><span class="hljs-comment">//* 测试 基本的函子</span><span class="hljs-keyword">let</span> r = Container.of(<span class="hljs-number">5</span>) <span class="hljs-comment">// 初始化</span>  .map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x + <span class="hljs-number">1</span>) <span class="hljs-comment">// map会返回一个新的容器，所以可以链式调用</span>  .map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x * x) <span class="hljs-comment">// 结果应该是36</span></code></pre></div><h3 id="4-2-Maybe函子"><a href="#4-2-Maybe函子" class="headerlink" title="4.2 Maybe函子"></a>4.2 Maybe函子</h3><p>基本的函子里面没有判断value和传入的修改方法是否兼容，所以我们可以在容器内加入判断，比如value为空值的时候直接返回一个新函子(value值还是原来的)，并不进行计算</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MayBe</span> </span>&#123;  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span>(value) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MayBe(value)  &#125;  <span class="hljs-keyword">constructor</span>(value) &#123;    <span class="hljs-keyword">this</span>._value = value  &#125;  <span class="hljs-comment">// 如果对空值变形的话直接返回 值为 null 的函子</span>  map(fn) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNothing() ? MayBe.of(<span class="hljs-literal">null</span>) : MayBe.of(fn(<span class="hljs-keyword">this</span>._value))  &#125;  isNothing() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._value === <span class="hljs-literal">null</span> || <span class="hljs-keyword">this</span>._value === <span class="hljs-literal">undefined</span>  &#125;&#125;<span class="hljs-comment">// 传入具体值</span>MayBe.of(<span class="hljs-string">'Hello World'</span>).map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.toUpperCase())<span class="hljs-comment">// 传入 null 的情况</span>MayBe.of(<span class="hljs-literal">null</span>).map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.toUpperCase())<span class="hljs-comment">// =&gt; MayBe &#123; _value: null &#125;</span></code></pre></div><h3 id="4-3-其他函子"><a href="#4-3-其他函子" class="headerlink" title="4.3 其他函子"></a>4.3 其他函子</h3><p>常用的函子还有Either函子，IO函子，Task函子等</p><p>尤其是Task函子也是一种异步机制，具体可参考folktale函数式编程库</p><p><a href="https://folktale.origamitower.com/" target="_blank" rel="noopener">folktale</a></p><h2 id="5-一些题目"><a href="#5-一些题目" class="headerlink" title="5. 一些题目"></a>5. 一些题目</h2><h3 id="5-1-map函数和parseInt之间的故事"><a href="#5-1-map函数和parseInt之间的故事" class="headerlink" title="5.1 map函数和parseInt之间的故事"></a>5.1 map函数和parseInt之间的故事</h3><p>这也是一道经典的题目了</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">'23'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'10'</span>]<span class="hljs-built_in">console</span>.log(array.map(<span class="hljs-built_in">parseInt</span>))<span class="hljs-comment">//! 结果是[ 23, NaN, 2 ]</span></code></pre></div><p>这是因为map函数在传递形参时，一共会传递三个参数 <code>callback(currentValue[, index[, array]])</code> 第二个是索引，第三个是数组本身<br>而parseInt其实可以接受两个参数string, radix，第二个radix表示进制，取值范围是2-36。</p><p>有意思的地方来了，radix大部分时候都没有人用，一般都会被留空，而当radix为 <code>0, undefined, null</code> 时，并不是默认以10进制来解析的：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt#%E6%8F%8F%E8%BF%B0" target="_blank" rel="noopener">根据MDN的资料</a></p><ul><li><p>如果输入的 string以 “0x”或 “0x”（一个0，后面是小写或大写的X）开头，那么radix被假定为16，字符串的其余部分被解析为十六进制数。</p></li><li><p>如果输入的 string以 “0”（0）开头， radix被假定为8（八进制）或10（十进制）。具体选择哪一个radix取决于实现。ECMAScript 5 澄清了应该使用 10 (十进制)，但不是所有的浏览器都支持。因此，在使用 parseInt 时，一定要指定一个 radix。</p></li><li><p>如果输入的 string 以任何其他值开头， radix 是 10 (十进制)。</p></li></ul><p>所以上面的例子，其真实的执行情况是：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'23'</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// parseInt没有第三个参数，所以map传递进来第三个参数array可以被忽略</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'8'</span>, <span class="hljs-number">1</span>)<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'10'</span>, <span class="hljs-number">2</span>)</code></pre></div><p>第一个23是字符串，且不是以0x开头的特殊情况，所以使用默认10进制解析，答案为23<br>第二个因为parseInt的radix取值是2-36，1是非法值，所以结果为NaN<br>第三个10是字符串，以2进制解析，答案是2</p><p>这里的细节确实是普通程序猿绝对不会留意到的，这个题目出的的确刁钻</p>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建总结</title>
    <link href="/2020/June/blog-build/"/>
    <url>/2020/June/blog-build/</url>
    
    <content type="html"><![CDATA[<p>折腾了一番，博客顺利搭建完毕。不得不说到了2020年的今天Hexo确实很强大了，以往个人博客比较难配置的一些站长功能都已经有了现成的集成，特别是主流的几个Theme模版都囊括了常用的几乎所有博客功能，只要自己愿意玩玩技术，不需要多少编程能力就能独立搭好不弱于任何主流社区的个人博客了，巴适得很。</p><p>总结一下几个比较容易踩坑的地方：</p><h3 id="git-repo-嵌套问题"><a href="#git-repo-嵌套问题" class="headerlink" title="git repo 嵌套问题"></a>git repo 嵌套问题</h3><p>推荐直接下载主题到本地，解压放到theme目录下，不要使用submodule，就不用折腾了……</p><p>这个问题应该所有想用git管理博客的blogger都会遇到，而且如果不擅长查资料的话会非常坑，因为官方基本没怎么提这个问题。</p><p>当我们搭建博客项目的时候，一般博客本身就是一个repo，而Hexo会把你下载的主题放在themes这个子文件中，如果你是用 git clone 来下载的话，就会发现当你试图build博客的时候，本地运行一切正常，但一旦你deploy到Github Pages就会收到下面的邮件：</p><blockquote><p>You are attempting to use a Jekyll theme, which is not supported by GitHub Pages. Please visit <a href="https://pages.github.com/themes/" target="_blank" rel="noopener">https://pages.github.com/themes/</a> for a list of supported themes. If you are using the “theme” configuration variable for something other than a Jekyll theme, we recommend you rename this variable throughout your site. For more information, see <a href="https://help.github.com/en/articles/adding-a-jekyll-theme-to-your-github-pages-site." target="_blank" rel="noopener">https://help.github.com/en/articles/adding-a-jekyll-theme-to-your-github-pages-site.</a></p></blockquote><p>这个问题乍一看好像是Github不识别Jekyll主题，但很明显我们用的是Hexo而不是Jekyll模版，如果你直接搜索这些关键词会找到很多几年前很类似的问题。当时Github会默认使用Jekyll去解析网页项目，所以需要在项目里放一个空的 .nojekyll 文件来让Github知道不需要进行解析，但这个问题已经被解决了。</p><p>真正导致这一问题的关键在于repo的嵌套导致的deploy失败，由于你clone的主题本身就是一个repo，而你的博客项目是另外一个repo，两个repo有了嵌套关系就会导致Github不知道如何处理deploy上来的文件。</p><p>所以要用 git submodule 来导入主题，而不是 git clone</p><div class="hljs"><pre><code class="hljs bash">git submodule add https://github.com/geektutu/hexo-theme-geektutu.git themes/geektutu</code></pre></div><p>这样theme模版项目作为一个子模块加载到博客项目里面来，层次逻辑就不会混乱了。</p><p>当你要更新模版时也很简单：</p><div class="hljs"><pre><code class="hljs bash">git submodule upate</code></pre></div><h3 id="css等资源加载失败"><a href="#css等资源加载失败" class="headerlink" title="css等资源加载失败"></a>css等资源加载失败</h3><p>deploy成功之后可能还会发现下面的情况：</p><p><img src="https://raw.githubusercontent.com/Yikhan/ImageHost/master/blog/1564116640441.png" srcset="/img/loading.gif" alt="css error"></p><p>css和js等资源文件统统加载失败，博客只有内容而没有样式。</p><p>404问题一般都是由于访问路径错误导致的，可以看一下这些文件是在访问什么路径的时候失败的，比如:</p><div class="hljs"><pre><code class="hljs bash">正确的:yourname.github.io/blog/css/1.css实际访问:yourname.github.io/css/1.css</code></pre></div><p>其实Hexo文档里面已经提示过你了：</p><blockquote><p>If your site is put in a subdirectory, set url as ‘<a href="http://yoursite.com/child&#39;">http://yoursite.com/child&#39;</a> and root as ‘/child/‘</p></blockquote><p>当你的博客网址不是第一路径时（就是网址中带有/，有/就表示你的博客在一个子路径里面），你要密切注意子路径的配置方式。很多人的博客项目实际网址是 yourname.github.io/blog/ 这样的形式，这时候你就必须要在 _config.yml 文件里面严格按照下面的方式来配置:</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">url:</span> <span class="hljs-string">https://yourname.github.io/blog/</span><span class="hljs-attr">root:</span> <span class="hljs-string">/blog/</span></code></pre></div><p>这是我在搭建博客时候碰到的两个坑，总结一下方便其他朋友绕坑。</p><h3 id="如何删除submodule"><a href="#如何删除submodule" class="headerlink" title="如何删除submodule"></a>如何删除submodule</h3><p>如果想停止使用submodule的方式引入主题，可以使用下面的命令：</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># Remove the submodule entry from .git/config</span>git submodule deinit -f path/to/submodule<span class="hljs-comment"># Remove the submodule directory from the superproject's .git/modules directory</span>rm -rf .git/modules/path/to/submodule<span class="hljs-comment"># Remove the entry in .gitmodules and remove the submodule directory located at path/to/submodule</span>git rm -f path/to/submodule</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
