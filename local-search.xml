<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vuex数据流心法</title>
    <link href="/2020/August/Javascript-vue-vuex/"/>
    <url>/2020/August/Javascript-vue-vuex/</url>
    
    <content type="html"><![CDATA[<h1 id="Vuex-数据流心法"><a href="#Vuex-数据流心法" class="headerlink" title="Vuex 数据流心法"></a>Vuex 数据流心法</h1><h2 id="1-父子组件传递数据的传统方法"><a href="#1-父子组件传递数据的传统方法" class="headerlink" title="1. 父子组件传递数据的传统方法"></a>1. 父子组件传递数据的传统方法</h2><p>自从组件化模式成为前端主流后，开发中的一大问题就是如何在父子组件之间传递数据。</p><h3 id="1-1-Props"><a href="#1-1-Props" class="headerlink" title="1.1 Props"></a>1.1 Props</h3><p>Vue本身提供的props是最简单，也是最常用的父子组件通讯方式</p><p>父组件可以在html模板里直接把数据传递给子组件。</p><p>父组件：调用子组件时传递props</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Props Down Parent<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"My journey with Vue"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><p>子组件：声明要接收的props</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>  props: &#123;<span class="javascript">    title: <span class="hljs-built_in">String</span></span>  &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>props的使用非常广泛，几乎所有Vue项目都会使用，其最大的不足是只能父传子，不能子传父。</p><h3 id="1-2-Event"><a href="#1-2-Event" class="headerlink" title="1.2 Event"></a>1.2 Event</h3><p>事件机制是另一种可以传递数据的方法，主要就是使用Vue提供的<code>$emit</code>方法，配合<code>v-on</code>指令</p><p>父组件：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"&#123; fontSize: hFontSize + 'em'&#125;"</span>&gt;</span>Event Up Parent<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    v-on:事件名=要触发的函数或者表达式    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">:fontSize</span>=<span class="hljs-string">"hFontSize"</span> <span class="hljs-attr">v-on:enlargeText</span>=<span class="hljs-string">"enlargeText"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>     $event是默认的事件参数    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">:fontSize</span>=<span class="hljs-string">"hFontSize"</span> <span class="hljs-attr">v-on:enlargeText</span>=<span class="hljs-string">"hFontSize += $event"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>  components: &#123;    child  &#125;,  data () &#123;<span class="actionscript">    <span class="hljs-keyword">return</span> &#123;</span>      hFontSize: 1    &#125;  &#125;,  methods: &#123;    enlargeText (size) &#123;<span class="actionscript">      <span class="hljs-keyword">this</span>.hFontSize += size</span>    &#125;  &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>子组件：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"&#123; fontSize: fontSize + 'em' &#125;"</span>&gt;</span>Props Down Child<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"handler"</span>&gt;</span>文字增大<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>  props: &#123;<span class="javascript">    fontSize: <span class="hljs-built_in">Number</span></span>  &#125;,  methods: &#123;    handler () &#123;<span class="actionscript">      <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'enlargeText'</span>, <span class="hljs-number">0.1</span>)</span>    &#125;  &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>子组件使用<code>$emit</code>来触发事件并传递参数，父组件通过<code>v-on:eventName=handler</code>来接收特定的事件并触发函数。</p><p>这样一来就实现了子组件向父组件传递传递数据。</p><p>要注意的是，<code>$emit</code>可以传递任意数量的参数，其函数原型是：</p><p><code>vm.$emit( eventName, […args\] )</code></p><p>另外在接收参数的时候，<code>$event</code>会作为第一个传上来的参数，可以直接用于表达式：</p><p><code>v-on:enlargeText=&quot;hFontSize += $event&quot;</code></p><p>或者是函数参数：</p><p><code>v-on:enlargeText=&quot;enlargeText($event)&quot;</code></p><p>但<code>$event</code>仅能默认接收第一个参数，所以如果<code>$emit</code>传递了多个参数，就不能使用<code>$event</code>来接收，直接使用函数名就可以了：</p><p>``v-on:enlargeText=”enlargeText`</p><p>在<code>handler</code>函数实现的时候再把要接收的参数个数以形参的方式定义清楚：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 假设$emit传递上来了两个参数</span>enlargeText (arg1, arg2) &#123;  <span class="hljs-built_in">console</span>.log(arg1, arg2)&#125;<span class="hljs-comment">// 当然使用解构语法也是可以的</span>enlargeText (...args) &#123;  <span class="hljs-built_in">console</span>.log(args)&#125;</code></pre></div><h3 id="1-3-Event-Bus"><a href="#1-3-Event-Bus" class="headerlink" title="1.3 Event Bus"></a>1.3 Event Bus</h3><p>事件传递机制虽然简单易用，但是如果要跨层级进行组件通讯会十分繁琐，必须层层上传，而且如果是同级别组件也无法传递。于是第三种传递方式事件总线Event Bus应运而生。</p><p>事件总线Event Bus的思路是创造一个新的Vue实例作为事件中心，其他组件向这个新的Vue实例传递事件，并且通过它订阅自己需要关注的事件。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 创建一个Vue实例作为Event Bus</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vue()<span class="hljs-comment">// 组件1 通过EventBus触发事件</span><span class="hljs-keyword">import</span> bus <span class="hljs-keyword">from</span> <span class="hljs-string">'./eventbus'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  methods: &#123;    sub () &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.value &gt; <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">this</span>.value--        bus.$emit(<span class="hljs-string">'numchange'</span>, <span class="hljs-keyword">this</span>.value)      &#125;    &#125;,    add () &#123;      <span class="hljs-keyword">this</span>.value++      bus.$emit(<span class="hljs-string">'numchange'</span>, <span class="hljs-keyword">this</span>.value)    &#125;  &#125;&#125;<span class="hljs-comment">// 组件2 通过EventBus得到事件</span><span class="hljs-keyword">import</span> bus <span class="hljs-keyword">from</span> <span class="hljs-string">'./eventbus'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  created () &#123;    bus.$on(<span class="hljs-string">'numchange'</span>, (value) =&gt; &#123;      <span class="hljs-keyword">this</span>.msg = <span class="hljs-string">`您选择了<span class="hljs-subst">$&#123;value&#125;</span>件商品`</span>    &#125;)  &#125;&#125;</code></pre></div><p>对一些比较简单的Vue项目而言，Event Bus就已经够用了。</p><h3 id="1-4-Refs"><a href="#1-4-Refs" class="headerlink" title="1.4 Refs"></a>1.4 Refs</h3><p>Vue提供的<code>$refs</code>一般用于获取DOM元素，但其实也可以用来传递数据。</p><p>父组件：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>ref Parent<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"c"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">'./child'</span></span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>  components: &#123;    child  &#125;,  mounted () &#123;<span class="actionscript">    <span class="hljs-keyword">this</span>.$refs.c.focus()</span><span class="actionscript">    <span class="hljs-keyword">this</span>.$refs.c.value = <span class="hljs-string">'hello input'</span></span>  &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>子组件</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>ref Child<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"input"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"value"</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>  data () &#123;<span class="actionscript">    <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">      value: <span class="hljs-string">''</span></span>    &#125;  &#125;,  methods: &#123;    focus () &#123;<span class="actionscript">      <span class="hljs-keyword">this</span>.$refs.input.focus()</span>    &#125;  &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>可以看到父组件直接通过<code>$refs</code>拿到子组件的引用，然后直接访问了子组件的<code>data</code>数据。</p><p>但这种方法官方并不推荐，属于“奇巧淫技”，因为这样传递数据非常不利于日后的管理维护。</p><h2 id="2-Vuex"><a href="#2-Vuex" class="headerlink" title="2. Vuex"></a>2. Vuex</h2><h3 id="2-1-Vuex基础"><a href="#2-1-Vuex基础" class="headerlink" title="2.1 Vuex基础"></a>2.1 Vuex基础</h3><p>Vuex提供了一种新的统一集成式管理数据的解决方案，本质来说就是使用一个单独的js对象来在组件之间传递数据，类似Event Bus都是采用了一个中间者来统一管理和分发数据。</p><p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener">Vuex文档</a></p><p>Vuex非常简洁好上手，配置方便，核心概念主要有</p><table><thead><tr><th></th><th>作用</th><th>调用方法</th></tr></thead><tbody><tr><td>State</td><td>存放数据，是一个单一状态树</td><td><code>$store.state.x</code></td></tr><tr><td>Getter</td><td>类似computed，用于从state派生变量</td><td><code>$store.getters.x</code></td></tr><tr><td>Mutation</td><td>类似event，是一个函数，调用后改变state内的数据，只能执行同步操作</td><td><code>$store.commit(&#39;x&#39;, payload)</code> or <code>$store.commit({type:&#39;x&#39;, payload})</code></td></tr><tr><td>Action</td><td>提交mutation，可以包含异步操作</td><td><code>$store.dispatch(&#39;x&#39;, payload)</code> or <code>$store.dispatch({type:&#39;x&#39;, payload})</code></td></tr><tr><td>Module</td><td>把数据分割成模块，每个模块都有各自的一套state，mutation，action等</td><td>推荐在导出每个模块时开启<code>namespaced:true</code></td></tr></tbody></table><p><img src="https://vuex.vuejs.org/vuex.png" srcset="/img/loading.gif" alt="Vuex数据流"></p><p>官网文档对于基本用法的介绍十分详细，这里就不再举例说明了。</p><p>比较值得一提的是module的使用和Vuex提供的一些工具方法。</p><p>一般实际开发中我们都会把store模块化，以便于管理和维护。</p><p>首先推荐在各个module里面开启<code>namespaced</code>，这个不是必须的，但是开启后所有的数据变化操作都可以指定是最哪个模块进行，否则由于Vuex会把所有的getter，mutation等方法都默认放在同一个全局空间里，多个同名的方法会被同时触发。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  namespaced: <span class="hljs-literal">true</span>,  state,  getters,  mutations,  actions&#125;</code></pre></div><p>然后在store的index.js，也就是最外层的store声明文件导入模块并命名：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> products <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules/products'</span><span class="hljs-keyword">import</span> cart <span class="hljs-keyword">from</span> <span class="hljs-string">'./modules/cart'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vuex.Store(&#123;  modules: &#123;    products,    cart  &#125;&#125;)</code></pre></div><p>这样在使用的时候就可以直接指定模块名了，并且推荐和<code>mapState</code>，<code>mapMutations</code>等工具函数一起使用，避免每次都要写<code>this.$store.state.cart.cartProducts</code>这样一长串。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapState, mapGetters, mapMutations &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  name: <span class="hljs-string">'PopCart'</span>,  computed: &#123;    ...mapState(<span class="hljs-string">'cart'</span>, [<span class="hljs-string">'cartProducts'</span>]),    ...mapGetters(<span class="hljs-string">'cart'</span>, [<span class="hljs-string">'totalCount'</span>, <span class="hljs-string">'totalPrice'</span>])  &#125;,  methods: &#123;    ...mapMutations(<span class="hljs-string">'cart'</span>, [<span class="hljs-string">'deleteFromCart'</span>])  &#125;&#125;</code></pre></div><h3 id="2-2-插件机制"><a href="#2-2-插件机制" class="headerlink" title="2.2 插件机制"></a>2.2 插件机制</h3><p>Vuex通用支持自定义的插件</p><p><a href="https://vuex.vuejs.org/zh/guide/plugins.html" target="_blank" rel="noopener">Vuex插件文档</a></p><p>其作用就是在每次执行mutation改变数据的时候进行额外的自定义操作</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 声明一个plugin用于每次改变购物车数据的时候自动把新数据同步到localStorage中持久化保存</span><span class="hljs-keyword">const</span> myPlugin = <span class="hljs-function"><span class="hljs-params">store</span> =&gt;</span> &#123;  store.subscribe(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (mutation.type.startsWith(<span class="hljs-string">'cart/'</span>)) &#123;      <span class="hljs-built_in">window</span>.localStorage.setItem(<span class="hljs-string">'cart-products'</span>, <span class="hljs-built_in">JSON</span>.stringify(state.cart.cartProducts))    &#125;  &#125;)&#125;<span class="hljs-comment">// 使用这个plugin</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vuex.Store(&#123;  plugins: [myPlugin]&#125;)</code></pre></div><h3 id="2-2-自己实现一个Vuex"><a href="#2-2-自己实现一个Vuex" class="headerlink" title="2.2 自己实现一个Vuex"></a>2.2 自己实现一个Vuex</h3><p>相比较于Vue三件套的Vue和VueRouter而言，Vuex的核心代码并不复杂：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> _Vue = <span class="hljs-literal">null</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span> </span>&#123;  <span class="hljs-keyword">constructor</span> (options) &#123;    <span class="hljs-keyword">const</span> &#123;      state = &#123;&#125;,      getters = &#123;&#125;,      mutations = &#123;&#125;,      actions = &#123;&#125;    &#125; = options    <span class="hljs-keyword">this</span>.state = _Vue.observable(state)    <span class="hljs-keyword">this</span>.getters = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)    <span class="hljs-comment">// 处理传入的getter，使用defineProperty把传入的getter中的每一个函数绑定到this.getter上面</span>    <span class="hljs-comment">// 并且把state作为默认参数传入</span>    <span class="hljs-built_in">Object</span>.keys(getters).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;      <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>.getters, key, &#123;        <span class="hljs-keyword">get</span>: () =&gt; getters[key](state)      &#125;)    &#125;)    this._mutations = mutations    this._actions = actions  &#125;  commit (type, payload) &#123;    <span class="hljs-keyword">this</span>._mutations[type](<span class="hljs-keyword">this</span>.state, payload)  &#125;  dispatch (type, payload) &#123;    <span class="hljs-keyword">this</span>._actions[type](<span class="hljs-keyword">this</span>, payload)  &#125;&#125;<span class="hljs-comment">// 提供一个install方法注入自己到Vue实例中</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">install</span> (<span class="hljs-params">Vue</span>) </span>&#123;  _Vue = Vue  _Vue.mixin(&#123;    beforeCreate () &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.store) &#123;        _Vue.prototype.$store = <span class="hljs-keyword">this</span>.$options.store      &#125;    &#125;  &#125;)&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  Store,  install&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue核心原理 - 自己实现一个Vue</title>
    <link href="/2020/August/Javascript-vue-responsive/"/>
    <url>/2020/August/Javascript-vue-responsive/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue核心实现原理"><a href="#Vue核心实现原理" class="headerlink" title="Vue核心实现原理"></a>Vue核心实现原理</h1><h2 id="1-观察者模式和发布订阅模式"><a href="#1-观察者模式和发布订阅模式" class="headerlink" title="1. 观察者模式和发布订阅模式"></a>1. 观察者模式和发布订阅模式</h2><center><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200722225714226.png" srcset="/img/loading.gif" width="50%" height="50%"></center><p>观察者模式和发布订阅模式是最为常用的事件响应设计模式。</p><p>与观察者模式相比，发布订阅模式多了一层事件中心，隔离了发布者和订阅者，使其不需要相互依赖。</p><p>既然我们希望当数据改变的时候视图也自动更新，那么就需要一个发布者来跟踪数据，当数据改变的时候这个发布者能够通知所有订阅自己的观察者，观察者再负责改变视图。</p><p>所以简单来说：</p><ul><li>发布者 - 跟踪数据变化，有变化发生时通知观察者</li><li>观察者 - 当被通知的时候更新视图</li></ul><p>这个原理其实非常简单，剩下的就是如何实现里面的细节了，比如：</p><ul><li>发布者<ul><li>如何跟踪数据？- 给数据设置setter/getter函数</li><li>如何通知观察者？- 创建一个数组存放所有的观察者，遍历并调用每个观察者的<code>update</code>方法</li></ul></li><li>观察者<ul><li>如何订阅发布者？- 被放到订阅者的观察者数组中就可以了</li><li>如何更新视图？- 实现<code>update</code>方法：获取页面DOM元素并修改</li></ul></li></ul><p>Vue的响应式机制就使用了观察者模式，从源代码中的相应类的命名也能看出来（<code>Observer</code>，<code>Dependant(依赖管理者，就是发布者)</code>，<code>Watcher(观察者)</code>）</p><h2 id="2-Vue原理"><a href="#2-Vue原理" class="headerlink" title="2. Vue原理"></a>2. Vue原理</h2><p>一个基本的响应式Vue由5个组件构成，每个组件都是一个class</p><center><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/VueStructure.jpg" srcset="/img/loading.gif" alt="VueStructure" style="zoom:50%"></center><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><p>需要实现的功能</p><ul><li>接收初始化的参数（选项）</li><li>把data中的属性注入到Vue实例，转换成getter/setter</li><li>调用observer监听data所有属性的变化</li><li>调用compiler解析指令和插值表达式</li></ul><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>把data中的属性变为响应式</p><h3 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h3><p>需要实现的功能</p><ul><li>编译模板，解析指令/插值表达式</li><li>页面的首次渲染</li><li>当数据变化后重新渲染视图</li></ul><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><p>通过Data的getter收集依赖，然后通过setter触发依赖，使用<code>notify</code>方法通知所有依赖自己的<code>Watcher</code></p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p>需要实现的功能</p><ul><li>当数据变化时触发依赖，Dep通知所有的Watcher实例更新视图</li><li>自身实例化的时候往Dep对象中添加自己</li></ul><h2 id="3-自己实现一个Vue"><a href="#3-自己实现一个Vue" class="headerlink" title="3. 自己实现一个Vue"></a>3. 自己实现一个Vue</h2><blockquote><p>Talking is cheap, show me the code</p></blockquote><p>下面我们就来自己实现一个简化版本的Vue，充分理解上面5个类是如何相互协同工作的</p><p>5个class的各自属性和方法成员如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/Vue.png" srcset="/img/loading.gif" alt="Vue"></p><h3 id="3-1-Vue"><a href="#3-1-Vue" class="headerlink" title="3.1 Vue"></a>3.1 <code>Vue</code></h3><p>首先我们都知道Vue的使用是以<code>new Vue()</code>的调用来开始的，所以<code>Vue</code>这个同名class当然是第一个要实现的：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vue</span> </span>&#123;  <span class="hljs-keyword">constructor</span> (options) &#123;    <span class="hljs-comment">//* 1. 通过属性保存选项的数据</span>    <span class="hljs-keyword">this</span>.$options = options || &#123;&#125;    <span class="hljs-keyword">this</span>.$data = options.data || &#123;&#125;    <span class="hljs-keyword">this</span>.$methods = options.methods || &#123;&#125;    <span class="hljs-comment">// 如果$el是字符串，就使用选择器查找这个元素，反之则认为传入的就是一个dom元素</span>    <span class="hljs-keyword">this</span>.$el =      <span class="hljs-keyword">typeof</span> options.el === <span class="hljs-string">'string'</span>        ? <span class="hljs-built_in">document</span>.querySelector(options.el)        : options.el    <span class="hljs-comment">//* 2.1 把data中的成员转换为getter/setter，注入到Vue实例中</span>    <span class="hljs-keyword">this</span>._proxyData(<span class="hljs-keyword">this</span>.$data)    <span class="hljs-comment">//* 2.2 把method中的函数成员注入到Vue实例中</span>    <span class="hljs-keyword">this</span>._proxyMethod(<span class="hljs-keyword">this</span>.$methods)    <span class="hljs-comment">//* 3. 调用observer对象，监听对象变化</span>    <span class="hljs-keyword">new</span> Observer(<span class="hljs-keyword">this</span>.$data)      <span class="hljs-comment">//* 4. 调用compiler对象，解析指令和插值表达式</span>    <span class="hljs-keyword">new</span> Compiler(<span class="hljs-keyword">this</span>)  &#125;  _proxyData (data) &#123;    <span class="hljs-comment">// 遍历data中的所有属性</span>    <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;      <span class="hljs-comment">// 注入到Vue实例</span>      <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, key, &#123;        enumerable: <span class="hljs-literal">true</span>,        configurable: <span class="hljs-literal">true</span>,        <span class="hljs-keyword">get</span> () &#123;          <span class="hljs-keyword">return</span> data[key]        &#125;,        <span class="hljs-keyword">set</span> (newValue) &#123;          <span class="hljs-keyword">if</span> (newValue === data[key]) &#123;            <span class="hljs-keyword">return</span>          &#125;          data[key] = newValue        &#125;      &#125;)    &#125;)  &#125;  _proxyMethod(methods) &#123;    <span class="hljs-built_in">Object</span>.keys(methods).forEach(<span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> &#123;      <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-keyword">this</span>, name, &#123;        enumerable: <span class="hljs-literal">true</span>,        configurable: <span class="hljs-literal">true</span>,        <span class="hljs-keyword">get</span>() &#123;          <span class="hljs-keyword">return</span> methods[name]        &#125;      &#125;)    &#125;)  &#125;&#125;</code></pre></div><p>首先当然是接受传入的参数进行初始化，然后就是第一个使用了<code>Object.defineProperty</code>的地方：<code>_proxyData</code>，它把<code>data</code>里的所有成员都挂载到了<code>this</code>，也就是<code>Vue</code>实例上，这也是为什么我们能够在模板里直接访问<code>data</code>里的属性的原因（比如<code></code>），下面的<code>_proxyMethod</code>原理一样。</p><h3 id="3-2-Observer"><a href="#3-2-Observer" class="headerlink" title="3.2 Observer"></a>3.2 <code>Observer</code></h3><p>然后到了<code>new Observer(this.$data)</code>这一行，我们就要实现<code>Observer</code>这个类了：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(data) &#123;    <span class="hljs-keyword">this</span>.walk(data)  &#125;  walk(data) &#123;    <span class="hljs-comment">// 判断data是否为对象</span>    <span class="hljs-keyword">if</span> (!data || <span class="hljs-keyword">typeof</span> data !== <span class="hljs-string">'object'</span>) &#123;      <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-comment">// 遍历data所有属性</span>    <span class="hljs-comment">//! 注意compiler内部没有实现针对新对象内部的属性创建watcher</span>    <span class="hljs-built_in">Object</span>.keys(data).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;      <span class="hljs-keyword">this</span>.defineReactive(data, key, data[key])    &#125;)  &#125;  defineReactive(obj, key, val) &#123;    <span class="hljs-comment">// 把当前的this记录下来</span>    <span class="hljs-keyword">let</span> self = <span class="hljs-keyword">this</span>    <span class="hljs-comment">// dep负责收集依赖，发送通知</span>    <span class="hljs-keyword">let</span> dep = <span class="hljs-keyword">new</span> Dep()    <span class="hljs-comment">// 如果val是对象，把val内部的属性也变成响应式</span>    <span class="hljs-keyword">this</span>.walk(val)    <span class="hljs-comment">// defineProperty内部的this发生了变化，不再指向Observer，所以不能直接使用this</span>    <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;      enumerable: <span class="hljs-literal">true</span>,      configurable: <span class="hljs-literal">true</span>,      <span class="hljs-keyword">get</span>() &#123;        <span class="hljs-comment">//* 收集依赖，watcher初始化的时候会绑定到Dep.target这个静态属性上</span>        Dep.target &amp;&amp; dep.addSub(Dep.target)        <span class="hljs-comment">//! 这里不能使用obj[key]，否则会死循环，因为obj[key]又会触发get</span>        <span class="hljs-comment">//! 所以val要作为参数传入，会通过闭包被缓存下来</span>        <span class="hljs-keyword">return</span> val      &#125;,      <span class="hljs-keyword">set</span> (newValue) &#123;        <span class="hljs-keyword">if</span> (newValue === val) &#123;          <span class="hljs-keyword">return</span>        &#125;        val = newValue        <span class="hljs-comment">// 如果新的值是对象，把其内部的属性也变成响应式</span>        self.walk(newValue)        <span class="hljs-comment">// 发送通知</span>        dep.notfiy()      &#125;    &#125;)  &#125;&#125;</code></pre></div><p><code>Vue</code>里面的<code>_proxyData</code>只是把<code>data</code>里面的属性挂载到了实例上，还没有实现响应式，而这里的<code>defineReactive</code>才是真正的重头戏，也就是Vue的响应式核心所在。</p><ol><li>首先我们调用了<code>walk</code>方法来遍历<code>data</code>，而且注意<code>defineReactive</code>和<code>walk</code>相互调用形成递归，只要一个属性是对象就会一直深入下去把里面对象内部的属性也变成响应式，知道遇见非对象的属性为止。</li><li><code>defineReactive</code>先声明了一个<code>Dep</code>，也就是发布者，用于收集依赖。</li><li>再次使用了<code>Object.defineProperty</code>方法来对属性设置<code>setter</code>和<code>getter</code>，于是属性值的改变和读取都被劫持了。</li><li>在<code>getter</code>里面先判断当前<code>Dep</code>上有没有需要被收集（想订阅发布者）的<code>Watcher</code>，这个判断是通过<code>Dep.target</code>这个静态属性来实现的，非常巧妙，我们后面在<code>Watcher</code>内部可以看到为什么要这么做。如果有，就把它放入订阅者（观察者）数组，这样“订阅”这个目的就实现了。</li><li>当<code>setter</code>被触发时，通知所有订阅了<code>Dep</code>的<code>Watcher</code>，于是视图被更新了。</li></ol><p>这里要注意的一点是，<code>defineReactive(obj, key, val)</code>接受三个参数，第三个<code>val</code>就是被劫持属性本身的值，在<code>getter</code>里面直接返回这个值给外部的访问者，而不是像<code>Vue</code>里面一样直接返回<code>obj[key]</code>，这是为了避免<code>obj[key]</code>再次触发<code>getter</code>导致无限自我递归。</p><ul><li>那为什么<code>Vue</code>里面的<code>_proxyData</code>使用<code>obj[key]</code>不会无限递归？</li></ul><p>因为<code>_proxyData</code>是在<code>this</code>，也就是Vue实例上新增了属性，这个属性被读取时返回<code>data[key]</code>。而<code>defineReactive</code>是直接在<code>data</code>上再次定义了同样的<code>key</code>，所以<code>data[key]</code>会触发<code>getter</code>，然后<code>getter</code>内部如果又是<code>return data[key]</code>就又会触发<code>getter</code>了。</p><h3 id="3-3-Dep"><a href="#3-3-Dep" class="headerlink" title="3.3 Dep"></a>3.3 <code>Dep</code></h3><p>接着我们来实现<code>Dep</code>这个class</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>&#123;  <span class="hljs-keyword">constructor</span>() &#123;    <span class="hljs-keyword">this</span>.subs = []  &#125;  <span class="hljs-comment">//* 添加观察者</span>  addSub(sub) &#123;    <span class="hljs-comment">// 所有的观察者都必须有一个update方法</span>    <span class="hljs-keyword">if</span> (sub &amp;&amp; sub.update) &#123;      <span class="hljs-keyword">this</span>.subs.push(sub)    &#125;  &#125;  <span class="hljs-comment">//* 发送通知</span>  notfiy() &#123;    <span class="hljs-keyword">this</span>.subs.forEach(<span class="hljs-function"><span class="hljs-params">sub</span> =&gt;</span> &#123;      sub.update()    &#125;)  &#125;&#125;</code></pre></div><p>这个类很简洁，<code>addSub</code>方法用于添加订阅自己的<code>Watcher</code>，<code>nofity</code>方法用于通知所有订阅自己的<code>Watcher</code></p><h3 id="3-4-Watcher"><a href="#3-4-Watcher" class="headerlink" title="3.4 Watcher"></a>3.4 <code>Watcher</code></h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(vm, key, cb) &#123;    <span class="hljs-keyword">this</span>.vm = vm    <span class="hljs-comment">// data中的属性名</span>    <span class="hljs-keyword">this</span>.key = key    <span class="hljs-comment">// 回调函数负责更新视图</span>    <span class="hljs-keyword">this</span>.cb = cb    <span class="hljs-comment">//* 把watcher注册到Dep的静态属性target</span>    Dep.target = <span class="hljs-keyword">this</span>    <span class="hljs-comment">//* 触发get方法，在get方法中调用addSub</span>    <span class="hljs-keyword">this</span>.oldValue = vm[key]    <span class="hljs-comment">//* 注册成功之后把target重置为null，避免重复注册</span>    Dep.target = <span class="hljs-literal">null</span>  &#125;  <span class="hljs-comment">//* 数据变化时使用cb更新视图</span>  update() &#123;    <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">this</span>.vm[<span class="hljs-keyword">this</span>.key]    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.oldValue === newValue) &#123;      <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">this</span>.cb(newValue)  &#125;&#125;</code></pre></div><p><code>Watcher</code>同样不复杂，里面最关键的地方有两个</p><p>第一个就是如何通过订阅<code>Dep</code>：</p><ol><li>给<code>Dep</code>这个类上增加一个静态属性<code>target</code>，这个<code>target</code>就指向自己</li><li>然后调用<code>vm[key]</code>，触发<code>getter</code></li><li>回到<code>Observer</code>里面，精髓的地方就是这一句<code>Dep.target &amp;&amp; dep.addSub(Dep.target)</code>，也就是如果<code>Dep</code>上有<code>target</code>（也就是新的<code>Watcher</code>自己），那么就注册这个<code>target</code>成为订阅者。于是最关键的订阅功能就完成了！</li><li>在成功注册自己之后，把<code>target</code>的值重设为<code>null</code></li></ol><p>通过<code>Dep.target</code>这个静态属性，我们可以在不进行任何多余操作的情况下成功把<code>Watcher</code>注册到了<code>Dep</code>上面。</p><p>第二个关键地方就是<code>update</code>函数：</p><p>如果新旧值不同，就要调用<code>Watcher</code>初始化时传入的<code>callback</code>函数，这个函数应该实现真正更新视图的逻辑，比如访问DOM。</p><h3 id="3-5-Compiler"><a href="#3-5-Compiler" class="headerlink" title="3.5 Compiler"></a>3.5 <code>Compiler</code></h3><p>最后尚缺两块拼图，一个是上面<code>Observer</code> - <code>Dep</code> - <code>Watcher</code>这个发布订阅模式的最后一环，就是在哪里初始化<code>Watcher</code>，第二个是模板指令的解析，比如<code>v-model</code>，<code>v-on</code>，<code>v-html</code>和插值表达式等。</p><p>这两块其实是互相关联的，其实就是在解析html模板的时候知道哪些变量需要监视，然后生成对应的<code>Watcher</code>。</p><p><code>Compiler</code>涉及到DOM节点的创建，代码相对较多，只取最关键的地方。</p><p>当解析到特定的模板指令时，我们就调用相应的<code>updater</code>函数去创建<code>Watcher</code>：</p><div class="hljs"><pre><code class="hljs js">update (node, key, attrName, event) &#123;  <span class="hljs-comment">// 通过拼接函数名找到处理函数，避免if语句</span>  <span class="hljs-keyword">let</span> updateFn = <span class="hljs-keyword">this</span>[attrName + <span class="hljs-string">'Updater'</span>]  <span class="hljs-comment">// 注意调用时this的指向</span>  updateFn &amp;&amp; updateFn.call(<span class="hljs-keyword">this</span>, node, key, <span class="hljs-keyword">this</span>.vm[key], event)&#125;</code></pre></div><p>先声明好一系列的模板<code>updater</code>，然后通过函数名拼接的方式<code>this[attrName + &#39;Updater&#39;]</code>来调用，这样可以避免用一大堆的<code>if</code>语句。</p><p>比如<code>v-model</code>就对应一个<code>modelUpdater</code>，同理还有<code>v-html</code>对应的<code>htmlUpdater</code>，<code>v-on</code>对应的<code>onUpdater</code>等等。</p><div class="hljs"><pre><code class="hljs js">modelUpdater (node, key, value) &#123;  node.value = value  <span class="hljs-keyword">new</span> Watcher(<span class="hljs-keyword">this</span>.vm, key, (newValue) =&gt; &#123; <span class="hljs-comment">// 传入改变视图的callback函数</span>    node.value = newValue  &#125;)  <span class="hljs-comment">// 双向绑定</span>  node.addEventListener(<span class="hljs-string">'input'</span>, () =&gt; &#123;    <span class="hljs-keyword">this</span>.vm[key] = node.value  &#125;)&#125;</code></pre></div><p><code>updater</code>里面会声明一个<code>Watcher</code>，这样发布订阅模式就完整实现了。</p>]]></content>
    
    
    <categories>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue源码理解心得</title>
    <link href="/2020/August/Javascript-vue-sourcecode/"/>
    <url>/2020/August/Javascript-vue-sourcecode/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue源码理解心得"><a href="#Vue源码理解心得" class="headerlink" title="Vue源码理解心得"></a>Vue源码理解心得</h1><h2 id="1-响应式原理"><a href="#1-响应式原理" class="headerlink" title="1. 响应式原理"></a>1. 响应式原理</h2><p>先上一张图作为总纲心法：</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png" srcset="/img/loading.gif" alt="Vue响应式处理过程"></p><p>里面有很多实现细节，但大概的原理都和<a href="https://yikhan.github.io/2020/August/Javascript-vue-responsive/" target="_blank" rel="noopener">自己实现的简化版的Vue</a>类似。</p><p>其中比较有意思的几个地方，也是面试里面常常考察的点，通过理解源码之后就再无任何疑问了，一通百通。</p><h3 id="1-1-数组响应式劫持"><a href="#1-1-数组响应式劫持" class="headerlink" title="1.1 数组响应式劫持"></a>1.1 数组响应式劫持</h3><p>众所周知，Vue对于数组的响应式处理是一个被经常讨论的话题，比较关键的源码如下：</p><blockquote><p>源码位置：vue\src\core\observer\index.js 是响应式处理的核心</p></blockquote><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span> (<span class="hljs-params">value: any, asRootData: ?boolean</span>): <span class="hljs-title">Observer</span> | <span class="hljs-title">void</span> </span>&#123;  <span class="hljs-comment">// 判断 value 是否是对象</span>  <span class="hljs-keyword">if</span> (!isObject(value) || value <span class="hljs-keyword">instanceof</span> VNode) &#123;    <span class="hljs-keyword">return</span>  &#125;  <span class="hljs-keyword">let</span> ob: Observer | <span class="hljs-keyword">void</span>  <span class="hljs-comment">// 如果 value 有 __ob__(observer对象) 属性 结束</span>  <span class="hljs-keyword">if</span> (hasOwn(value, <span class="hljs-string">'__ob__'</span>) &amp;&amp; value.__ob__ <span class="hljs-keyword">instanceof</span> Observer) &#123;    ob = value.__ob__  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (    shouldObserve &amp;&amp;    !isServerRendering() &amp;&amp;    (<span class="hljs-built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;    <span class="hljs-built_in">Object</span>.isExtensible(value) &amp;&amp;    !value._isVue  ) &#123;    <span class="hljs-comment">// 创建一个 Observer 对象</span>    ob = <span class="hljs-keyword">new</span> Observer(value)  &#125;  <span class="hljs-keyword">if</span> (asRootData &amp;&amp; ob) &#123;    ob.vmCount++  &#125;  <span class="hljs-keyword">return</span> ob&#125;</code></pre></div><p>上面代码一开始的判断非常重要，如果传入的<code>value</code>不是对象或者VNode，<strong>就不会进行响应式处理了</strong>！</p><p>从一开始的总纲可以看到，<code>observe</code>方法是开始响应式处理的关键入口，其中会创建<code>Observer</code>这个响应式类，然后我们再到<code>Observer</code>的源码中看看：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">constructor</span> (value: any) &#123;  <span class="hljs-keyword">this</span>.value = value  <span class="hljs-keyword">this</span>.dep = <span class="hljs-keyword">new</span> Dep()  <span class="hljs-comment">// 初始化实例的 vmCount 为0</span>  <span class="hljs-keyword">this</span>.vmCount = <span class="hljs-number">0</span>  <span class="hljs-comment">// 将实例挂载到观察对象的 __ob__ 属性</span>  def(value, <span class="hljs-string">'__ob__'</span>, <span class="hljs-keyword">this</span>)  <span class="hljs-comment">// 数组的响应式处理</span>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;    <span class="hljs-keyword">if</span> (hasProto) &#123;      protoAugment(value, arrayMethods)    &#125; <span class="hljs-keyword">else</span> &#123;      copyAugment(value, arrayMethods, arrayKeys)    &#125;    <span class="hljs-comment">// 为数组中的每一个对象创建一个 observer 实例</span>    <span class="hljs-keyword">this</span>.observeArray(value)  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 遍历对象中的每一个属性，转换成 setter/getter</span>    <span class="hljs-keyword">this</span>.walk(value)  &#125;&#125;</code></pre></div><p>这里的构造函数比较直白，马上可以看到对于数组是有额外的判断处理的，需要调用<code>observeArray</code>这个方法。</p><div class="hljs"><pre><code class="hljs js">observeArray (items: <span class="hljs-built_in">Array</span>&lt;any&gt;) &#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = items.length; i &lt; l; i++) &#123;    observe(items[i])  &#125;&#125;</code></pre></div><p>这个方法非常简单，就是遍历数组的每个元素，然后再次递归调用一开始的<code>observe</code>方法。</p><p>然后再回到<code>Observer</code>中，在10行的位置判断了当前环境是否有prototype可以用，然后分别调用<code>protoAugment</code>或者<code>copyAugment</code>两个方法，其目的都是劫持数组自带的方法，关键的源码如下：</p><blockquote><p>源码位置：vue\src\core\observer\array.js</p></blockquote><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arrayProto = <span class="hljs-built_in">Array</span>.prototype<span class="hljs-comment">// 使用数组的原型创建一个新的对象</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arrayMethods = <span class="hljs-built_in">Object</span>.create(arrayProto)<span class="hljs-comment">// 修改数组元素的方法</span><span class="hljs-keyword">const</span> methodsToPatch = [  <span class="hljs-string">'push'</span>,  <span class="hljs-string">'pop'</span>,  <span class="hljs-string">'shift'</span>,  <span class="hljs-string">'unshift'</span>,  <span class="hljs-string">'splice'</span>,  <span class="hljs-string">'sort'</span>,  <span class="hljs-string">'reverse'</span>]</code></pre></div><p>具体的劫持方法：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Intercept mutating methods and emit events</span><span class="hljs-comment"> */</span>methodsToPatch.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>&#123;  <span class="hljs-comment">// cache original method</span>  <span class="hljs-comment">// 保存数组原方法</span>  <span class="hljs-keyword">const</span> original = arrayProto[method]  <span class="hljs-comment">// 调用 Object.defineProperty() 重新定义修改数组的方法</span>  def(arrayMethods, method, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutator</span> (<span class="hljs-params">...args</span>) </span>&#123;    <span class="hljs-comment">// 执行数组的原始方法</span>    <span class="hljs-keyword">const</span> result = original.apply(<span class="hljs-keyword">this</span>, args)    <span class="hljs-comment">// 获取数组对象的 ob 对象</span>    <span class="hljs-keyword">const</span> ob = <span class="hljs-keyword">this</span>.__ob__    <span class="hljs-keyword">let</span> inserted    <span class="hljs-keyword">switch</span> (method) &#123;      <span class="hljs-keyword">case</span> <span class="hljs-string">'push'</span>:      <span class="hljs-keyword">case</span> <span class="hljs-string">'unshift'</span>:        inserted = args        <span class="hljs-keyword">break</span>      <span class="hljs-keyword">case</span> <span class="hljs-string">'splice'</span>:        inserted = args.slice(<span class="hljs-number">2</span>)        <span class="hljs-keyword">break</span>    &#125;    <span class="hljs-comment">// 对插入的新元素，重新遍历数组元素设置为响应式数据</span>    <span class="hljs-keyword">if</span> (inserted) ob.observeArray(inserted)    <span class="hljs-comment">// notify change</span>    <span class="hljs-comment">// 调用了修改数组的方法，调用数组的ob对象发送通知</span>    ob.dep.notify()    <span class="hljs-keyword">return</span> result  &#125;)&#125;)</code></pre></div><p>这样串联起来思考一下，我们很容易就能通过源代码的逻辑知道：</p><ol><li><p>数组的每个元素都是响应式的吗？</p><p>– 不是，注意<code>observe</code>方法一开始的判断，当<code>observeArray</code>遍历数组元素的时候，如果元素不是对象或者VNode，就不会被响应式处理。这也非常合理，因为数组有可能非常大，都转化成响应式毫无意义，性能极低。</p></li><li><p>什么情况下数组元素会变成响应式？</p><p>– 当元素本身是对象或者VNode的时候！这时<code>observe</code>方法就会尽心尽力地开始遍历元素的成员并转换成响应式了。</p></li></ol><p>这就是为什么直接修改数组成员，比如<code>arr[0] = 100</code>这种或者修改数组自带成员<code>arr.length = 0</code>都无法触发视图更新，因为本来就不是响应式的。</p><p>那如果要响应式地改变数组成员如何处理？</p><ol><li>使用<code>splice</code>方法，比如<code>arr.splice(1, 1, 100)</code>，删除原来索引为1的元素然后替换为新值，<code>splice</code>方法因为被劫持了，所以是响应式的。</li><li>使用<code>$set</code>方法，比如<code>vm.$set(vm.arr, 1, 100)</code>，在JS里数组的索引等同于对象的键，所以<code>$set</code>方法不但能用于设置对象的响应式成员，也能设置数组元素。有意思的是，如果看<code>$set</code>方法的源码，可以发现内部也是通过调用被劫持的<code>splice</code>方法来改变数组的。</li></ol><h3 id="1-2-set和del方法"><a href="#1-2-set和del方法" class="headerlink" title="1.2 set和del方法"></a>1.2 <code>set</code>和<code>del</code>方法</h3><blockquote><p>源码位置：vue\src\core\observer\index.js</p></blockquote><p>上面提到了<code>$set</code>方法，其实就是静态方法<code>Vue.set</code>的别名，在初始化的时候会被挂载到Vue实例上，然后通过<code>vm.$set</code>的方式被使用。</p><p><code>set</code>方法内部调用了核心的<code>defineReactive(obj, key, val)</code>来实现响应式地新增成员。</p><p><code>set</code>和<code>del</code>方法代码十分相似，其中有意思的一段源码是（两个函数都有）：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 如果 target 是 vue 实例或者 $data 直接返回</span><span class="hljs-keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;  process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp; warn(    <span class="hljs-string">'Avoid adding reactive properties to a Vue instance or its root $data '</span> +    <span class="hljs-string">'at runtime - declare it upfront in the data option.'</span>  )  <span class="hljs-keyword">return</span> val&#125;</code></pre></div><p>上面的代码表明了<code>set</code>和<code>del</code>都不能直接对Vue实例或者<code>$data</code>对象使用，如果要操作<code>$data</code>，应该要在声明阶段定义好，不允许在运行时动态增删。</p><p>比较有趣的地方在于代码里检查<code>$data</code>的方式，因为<code>observe</code>方法在初始化传入的<code>data</code>并赋值给<code>$data</code>时，会新增一个<code>vmCount</code>属性到<code>ob</code>，并设置为1，其他普通对象则为0，所以<code>(ob &amp;&amp; ob.vmCount)</code>可以判断传入的要删改对象是否为<code>$data</code>，代码简化后类似如下：</p><div class="hljs"><pre><code class="hljs js">ob = value.__ob__ || <span class="hljs-keyword">new</span> Observer(value)ob = <span class="hljs-keyword">new</span> Observer(value) <span class="hljs-comment">// vmCount初始化为0</span><span class="hljs-keyword">if</span> (asRootData &amp;&amp; ob) &#123; <span class="hljs-comment">// asRootData表示为根数据对象，即$data</span>  ob.vmCount++&#125;</code></pre></div><h3 id="1-3-nextTick方法"><a href="#1-3-nextTick方法" class="headerlink" title="1.3 nextTick方法"></a>1.3 <code>nextTick</code>方法</h3><blockquote><p>源码位置：vue\src\core\util\next-tick.js</p></blockquote><p><code>nextTick</code>也是常用的一个方法，主要用于在DOM元素更新后立即执行某些操作，因为DOM的更新是异步的，所以同步代码无法获得更新之后的DOM元素内容，所以要使用<code>nextTick</code>，这个函数名字也表示了<strong>下一时刻</strong>执行之意。</p><p>用法如下：</p><div class="hljs"><pre><code class="hljs js">mounted() &#123;  <span class="hljs-keyword">this</span>.msg = <span class="hljs-string">'Hello'</span> <span class="hljs-comment">// 通过响应式数据改变DOM内容</span>  <span class="hljs-keyword">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.$refs.p1.textContent) <span class="hljs-comment">// 通过$refs获取DOM元素内容</span>  &#125;)&#125;</code></pre></div><p><code>nextTick</code>本身是一个静态方法，和<code>set</code>以及<code>del</code>函数一样，会在Vue初始化的时候被注入到实例中，然后通过<code>vm.$nextTick()</code>的方式来调用，其参数是一个callback函数。</p><p>源码实现：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextTick</span> (<span class="hljs-params">cb?: Function, ctx?: Object</span>) </span>&#123;  <span class="hljs-keyword">let</span> _resolve  <span class="hljs-comment">// 把 cb 加上异常处理存入 callbacks 数组中</span>  callbacks.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (cb) &#123;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 调用 cb()</span>        cb.call(ctx)      &#125; <span class="hljs-keyword">catch</span> (e) &#123;        handleError(e, ctx, <span class="hljs-string">'nextTick'</span>)      &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_resolve) &#123;      _resolve(ctx)    &#125;  &#125;)  <span class="hljs-keyword">if</span> (!pending) &#123;    pending = <span class="hljs-literal">true</span>    <span class="hljs-comment">// 通过异步api调用回调函数</span>    timerFunc()  &#125;  <span class="hljs-comment">// $flow-disable-line</span>  <span class="hljs-keyword">if</span> (!cb &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Promise</span> !== <span class="hljs-string">'undefined'</span>) &#123;    <span class="hljs-comment">// 返回 promise 对象</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;      _resolve = resolve    &#125;)  &#125;&#125;</code></pre></div><p>了解JS的异步知识之后，很容易想到<code>nextTick</code>必然也是借助了<code>Promise</code>等异步api来实现。</p><p>源码中的细节会更加复杂一些，因为要考虑到环境中不支持<code>Promise</code>的情况，也就是19行的那个<code>timerFunc</code>，回调的异步调用是在这个函数里完成的。</p><p>Vue考虑到了各种环境里面的异步api情况，总结一下就是以下面的顺序来决定使用哪个api实现异步延时：</p><ol><li><code>Promise</code> （微任务）</li><li><code>MutationObserver</code> （微任务）</li><li><code>setImmediate</code> （宏任务，主要是IE10以上，还有Node环境，虽然也是宏任务但性能优于<code>setTimeout</code>）</li><li><code>setTimeout</code> （宏任务）</li></ol><p>要注意的时，此时DOM并没有真正的更新完毕（稍微想想也能知道DOM更新是浏览器来完成的，速度必然远远滞后于JS，也根本不受JS控制），所以<code>nextTick</code>实际上等待的是虚拟DOM的更新而不是真实页面上的DOM！因为虚拟DOM是在JS代码中更新的，所以才能保证我们能在异步任务中获取更新后的虚拟DOM树。</p><h3 id="1-4-computed和-watcher的区别"><a href="#1-4-computed和-watcher的区别" class="headerlink" title="1.4 computed和 watcher的区别"></a>1.4 computed和 watcher的区别</h3><p>computed属性：</p><ul><li>不支持异步，因为计算属性一般要绑定到模板中</li><li>会缓存结果以提高性能</li><li>一定要有返回值</li></ul><p>watcher：</p><ul><li><p>可以执行异步操作</p></li><li><p>不需要返回值</p></li></ul><h2 id="2-Key的作用"><a href="#2-Key的作用" class="headerlink" title="2. Key的作用"></a>2. Key的作用</h2><p>几乎所有的文档都会说，在使用<code>v-for</code>等指令渲染节点时最好使用key，这和Vue使用的diff算法关系很大。</p><blockquote><p>源码位置：vue\src\core\vdom\patch.js</p></blockquote><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sameVnode</span> (<span class="hljs-params">a, b</span>) </span>&#123;  <span class="hljs-keyword">return</span> (    a.key === b.key &amp;&amp; (      (        a.tag === b.tag &amp;&amp;        a.isComment === b.isComment &amp;&amp;        isDef(a.data) === isDef(b.data) &amp;&amp;        sameInputType(a, b)      ) || (        isTrue(a.isAsyncPlaceholder) &amp;&amp;        a.asyncFactory === b.asyncFactory &amp;&amp;        isUndef(b.asyncFactory.error)      )    )  )&#125;</code></pre></div><p>Vue的diff算法类似Snabbdom，主要进行同层级的VNode比较，基本上所有文档都会提到diff的5种比较情况：</p><ol><li>oldStartNode = newStartNode</li><li>oldStartNode = newEndNode</li><li>oldEndNode = newStartNode</li><li>oldEndNode = newEndNode</li><li>其他</li></ol><p>具体的比较过程不在这里赘述，其篇幅足够单独撰文阐述了，但既然要比较节点，就必然需要一个比较函数，也就是上面的<code>sameVnode</code>函数。</p><p>可以很清楚地看到，进行节点比较的时候第一个比较对象就是key，如果设置了key，只要两个key不同就能马上判断节点不同，反之如果没有key，第一个判断为true（<code>undefined === undefined</code>），所以就要进行后续的比较，这时就有问题了，我们可以举例说明：</p><blockquote><p>假设原始DOM元素节点数组为[A, B, C , D]，新的是[A, E, B, C , D]</p></blockquote><p>使用key和不使用key的更新过程：</p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/key的作用.jpg" srcset="/img/loading.gif" alt="key的作用" style="zoom:67%"><p>可以发现，没有key的情况下要更新三次并插入一个新的节点D，而如果有key的话，只需要插入一个新节点E，效率明显高多了。</p><p>这里的关键原因就是上面的<code>sameVnode</code>函数，如果不看源码的话，大部分人都会想当然地认为判断两个节点是否相同，应该要比较节点里面的内容（<code>textContent</code>）才对，然而源码告诉我们，Vue在比较节点的时候并不考虑节点里面的内容，事实上<code>textContent</code>的比较和更新是放到最后<code>patchVnode</code>方法被调用时，真正改变节点的时候才进行的。</p><p>所以当没有key时，<code>sameVnode</code>会直接比较两个节点的类型（<code>tag</code>），假设它们都是<code>&lt;li&gt;</code>元素，就会直接被判定相同，因此老的B节点和新的E节点被认为相同，然后调用<code>patchVnode</code>方法更新，后面的C更新成B，D更新成C同理，最后发现新元素还多了一个D，于是再新建一个D。</p><p>而如果设置了key，<code>sameVnode</code>比较B和E的时候就会返回<code>false</code>，知道它们不是同一个节点，然后老的B节点就会继续与后面的节点比较，接着发现B节点可以复用，C，D亦然，最后只用插入一个新的E节点就行了，如此一来效率就高得多了。</p><h2 id="3-模板和render函数谁优先"><a href="#3-模板和render函数谁优先" class="headerlink" title="3. 模板和render函数谁优先"></a>3. 模板和render函数谁优先</h2><p>假设有下面的代码，既有<code>template</code>又有<code>render</code>函数，谁会优先被使用呢？</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;  el: <span class="hljs-string">'#app'</span>,  template: <span class="hljs-string">'&lt;h1&gt;Hello Template&lt;/h1&gt;'</span>,  render(h) &#123;    <span class="hljs-keyword">return</span> h(<span class="hljs-string">'h1'</span>, <span class="hljs-string">'Hello Render'</span>)  &#125;&#125;)</code></pre></div><p>如果是使用run-time版本的Vue，由于没有模板编译器，<code>template</code>自然会被忽略。在完整版的Vue里面，存在如下的判断代码，位于入口文件<code>entry-runtime-with-compile.js</code>（也就是带有编译器的版本）</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!options.render) &#123;  <span class="hljs-comment">// 这里的代码是转换template代码为render函数</span>&#125;<span class="hljs-keyword">return</span> mount.call(<span class="hljs-keyword">this</span>, el, hydrating)</code></pre></div><p>所以<code>render</code>函数优先级更高，有<code>render</code>函数的时候<code>template</code>就不会被编译了。</p><h2 id="4-el不能是body或者html根标签"><a href="#4-el不能是body或者html根标签" class="headerlink" title="4. el不能是body或者html根标签"></a>4. el不能是body或者html根标签</h2><p>在初始化的代码中有如下的判断</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (el === <span class="hljs-built_in">document</span>.body || el === <span class="hljs-built_in">document</span>.documentElement) &#123;  process.env.NODE_ENV !== <span class="hljs-string">'producation'</span> &amp;&amp; warn(  <span class="hljs-string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal element instead.`</span>  )  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>&#125;</code></pre></div><p><code>document.documentElement</code>就是文档的根元素，一般就是html根标签</p><h2 id="5-Vue入口文件"><a href="#5-Vue入口文件" class="headerlink" title="5. Vue入口文件"></a>5. Vue入口文件</h2><p>Vue的文件打包入口在</p><blockquote><p><code>vue\src\platforms\web\*.js</code></p></blockquote><p>在初始化的过程中，有四个模块比较重要</p><ul><li><code>src\platforms\web\entry-runtime-with-compiler.js</code><ul><li>web平台相关的打包入口</li><li>重写了平台相关的<code>$mount()</code>方法（增加了编译模板的功能）</li><li>注册了<code>Vue.compile()</code>方法，传递一个html字符串，返回render函数</li></ul></li><li><code>src\platforms\web\runtime\index.js</code><ul><li>web平台相关</li><li>注册和平台相关的全局指令：<code>v-model</code>，<code>v-show</code> -&gt; <code>Vue.options.directives</code></li><li>注册和平台相关的全局组件：<code>v-transition</code>，<code>v-transition-group</code> -&gt; <code>Vue.options.comoponents</code></li><li>全局方法：<ul><li><code>__patch__</code>：把虚拟DOM转换为真实的DOM</li><li><code>$mount</code>：标明渲染到哪里的挂载方法</li></ul></li></ul></li><li><code>src\core\index.js</code><ul><li>与平台无关</li><li>设置了Vue的静态方法，<code>initGlobalAPI(Vue)</code><ul><li><code>Vue.set</code></li><li><code>Vue.delete</code></li><li><code>Vue.nextTick</code></li><li><code>Vue.observable</code> (Vue 2.6新增)</li></ul></li></ul></li><li><code>src\core\instance\index.js</code><ul><li>与平台无关</li><li>定义了构造函数，调用了<code>this._init(options)</code></li><li>给Vue中混入了常用的实例成员</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VueRouter的原理和实现</title>
    <link href="/2020/July/Javascript-vue-router/"/>
    <url>/2020/July/Javascript-vue-router/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h1><p>先来看看<code>VueRouter</code>的使用方式</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// router/index.js</span><span class="hljs-comment">// 注册VueRouter插件</span>Vue.use(VueRouter)<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;  route: [    &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">'home'</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">'/'</span>, <span class="hljs-attr">component</span>: homeComponent&#125;  ]&#125;)<span class="hljs-comment">// main.js</span><span class="hljs-comment">// 创建Vue实例，注册router对象</span><span class="hljs-keyword">new</span> Vue(&#123;  router,  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)&#125;).$mount(<span class="hljs-string">'#app'</span>)</code></pre></div><p>Vue注册插件的<code>Vue.use()</code>接受函数或者一个类，如果是函数就会被直接调用，是类的话就会调用类里面的<code>install</code>方法。</p><p>基本可以看出如果要实现一个<code>VueRouter</code>，大概要怎么写了。</p><p><code>VueRouter</code>的结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/VueRouter.png" srcset="/img/loading.gif" alt="VueRouter"></p><p>VueRouter提供了两个模式</p><ul><li><code>history</code> 历史模式</li><li><code>hash</code> 哈希模式</li></ul><p>在初始化VueRouter时可以通过<code>mode</code>选项配置：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;  mode: <span class="hljs-string">'history'</span>,  routes: [...]&#125;)</code></pre></div><p>hash模式就是通过地址栏中的<code>#</code>锚点来实现的，传统上用于在同一个页面中跳转到不同地方。hash的特点是改变时不会发送新的请求，所以通过监听<code>hashchange</code>这个事件就可以在前端为所欲为，包括实现各种组件渲染达到路由效果。</p><p>history模式是目前最流行的（hash看着实在不美观），通过浏览器的api来实现（api名字就是<code>history</code>）</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/History/pushState" target="_blank" rel="noopener">MDN资料</a></p><h2 id="1-Vue插件机制"><a href="#1-Vue插件机制" class="headerlink" title="1. Vue插件机制"></a>1. Vue插件机制</h2><p>VueRouter中的前面一部分代码都和现实Vue的插件机制有关，Vue作为主流的前端框架之一必然要提供插件接口来扩展功能，而所有的Vue插件要么本身是一个函数可以直接运行，要么是一个class并提供一个intall方法，这个方法会在使用<code>Vue.use()</code>注册插件时被调用。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">static</span> install (Vue) &#123;   <span class="hljs-comment">//* 1. 判断当前插件是否已经被安装</span>   <span class="hljs-keyword">if</span> (VueRouter.install.installed) &#123;     <span class="hljs-keyword">return</span>   &#125;   VueRouter.install.installed = <span class="hljs-literal">true</span>   <span class="hljs-comment">//* 2. 把Vue构造函数记录到全局变量</span>   _Vue = Vue   <span class="hljs-comment">//* 3. 把创建Vue实例时传入的router对象注入到Vue实例中</span>   <span class="hljs-comment">//* 需要使用mixin混入</span>   <span class="hljs-comment">// _Vue.prototype.$router = this.$options.router 直接这样实现是不行的</span>   <span class="hljs-comment">// 因为this指向的是VueRouter(install是静态函数)，并不是Vue的一个实例</span>   _Vue.mixin(&#123;     beforeCreate () &#123;       <span class="hljs-comment">// 混入后所有Vue实例包括组件都会有beforeCreate，导致会运行很多次</span>       <span class="hljs-comment">// 所以我们需要判断，只对Vue实例执行，组件不需要执行</span>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.router) &#123;         <span class="hljs-comment">// 组件选项中没有router，注意router是初始化Vue的时候作为参数传入的</span>         <span class="hljs-comment">//（所有参数都会被放在$options对象里），就是一个VueRouter实例</span>         _Vue.prototype.$router = <span class="hljs-keyword">this</span>.$options.router         <span class="hljs-keyword">this</span>.$options.router.init()       &#125;     &#125;   &#125;) &#125;</code></pre></div><p>在intall方法里，首先要判断当前我们的插件是不是已经被运行过了，这一点很简单，使用一个闭包变量记录即可，可以把这个变量直接挂载到install这个静态方法上面。</p><p>然后需要使用Vue提供的mixin方法来把插件对象注入到Vue实例当中，这也是为什么我们可以直接在Vue组件里调用<code>this.$router</code>的原理，上面的代码也非常简明易懂。</p><p>在Vue初始化的时候我们会传入router对象（就是router.js，里面定义好了我们的路由规则）</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;  router, <span class="hljs-comment">// 这个router会被放到this.$options里面</span>  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)&#125;).$mount(<span class="hljs-string">'#app'</span>)</code></pre></div><p>然后我们通过在Vue的原型链上增加一个<code>$router</code>对象，把router赋值给它就行了。</p><div class="hljs"><pre><code class="hljs js">_Vue.prototype.$router = <span class="hljs-keyword">this</span>.$options.router</code></pre></div><p>另外值得一提的是，除了普通的在一开始import导入组件并赋值给route对象里面的component之外，我们还可以使用<code>component:() =&gt; import(&#39;component.vue&#39;)</code>的方式来动态按需加载。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> routes = [  &#123;    path: <span class="hljs-string">'/'</span>,    name: <span class="hljs-string">'Index'</span>,    component: Index  &#125;,  &#123;    path: <span class="hljs-string">'/blog'</span>,    name: <span class="hljs-string">'Blog'</span>,    <span class="hljs-comment">// route level code-splitting</span>    <span class="hljs-comment">// this generates a separate chunk (about.[hash].js) for this route</span>    <span class="hljs-comment">// which is lazy-loaded when the route is visited.</span>    component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "about" */</span> <span class="hljs-string">'../views/Blog.vue'</span>)  &#125;,  &#123;    path: <span class="hljs-string">'/photo'</span>,    name: <span class="hljs-string">'Photo'</span>,    <span class="hljs-comment">// route level code-splitting</span>    <span class="hljs-comment">// this generates a separate chunk (about.[hash].js) for this route</span>    <span class="hljs-comment">// which is lazy-loaded when the route is visited.</span>    component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: "about" */</span> <span class="hljs-string">'../views/Photo.vue'</span>)  &#125;]<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;  routes&#125;)</code></pre></div><h2 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h2><h3 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h3><p>既然是一个class，当然就必须有构造函数了。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">constructor</span> (options) &#123;  <span class="hljs-keyword">this</span>.options = options  <span class="hljs-keyword">this</span>.routeMap = &#123;&#125;  <span class="hljs-keyword">this</span>.data = _Vue.observable(&#123;    current: <span class="hljs-string">'/'</span>  &#125;)&#125;</code></pre></div><p>我们通过监听点击事件来改变<code>data.current</code>，也就是当前的路径，这个变量是我们能够动态改变视图的关键，它必须是一个响应式的属性，因此要使用Vue提供的api来创建，也就是<code>Vue.observable</code></p><p>当这个变量发生变化时，Vue就会重新渲染页面视图，因为另一个关键组件router-view依赖于它，这样我们就能得到新的页面了。</p><h3 id="2-2-创建RouteMap"><a href="#2-2-创建RouteMap" class="headerlink" title="2.2 创建RouteMap"></a>2.2 创建RouteMap</h3><p>定义方法<code>createRouteMap</code></p><p>接下来就是把传进来的router对象解析保存到RouteMap变量里</p><div class="hljs"><pre><code class="hljs js">createRouteMap () &#123;  <span class="hljs-comment">//* 建立路由键值对 &lt;路由 - 组件&gt; 储存到routeMap</span>  <span class="hljs-keyword">this</span>.options.routes.forEach(<span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> &#123;    <span class="hljs-keyword">this</span>.routeMap[route.path] = route.component  &#125;)&#125;</code></pre></div><p>以后我们就可以直接通过浏览器地址路径找到对应的组件了</p><h3 id="2-3-创建router-link和router-view组件"><a href="#2-3-创建router-link和router-view组件" class="headerlink" title="2.3 创建router-link和router-view组件"></a>2.3 创建router-link和router-view组件</h3><p>定义方法<code>initComponents</code></p><p>这一步在下面的组件分析里会单独展开。</p><h3 id="2-4-监听事件"><a href="#2-4-监听事件" class="headerlink" title="2.4 监听事件"></a>2.4 监听事件</h3><p>定义方法<code>initEvent</code></p><p>如果使用history模式的话，就需要监听<code>popstate</code>这个事件（浏览器地址栏前进后退），然后改变<code>data.current</code></p><p>如果是hash模式，就需要监听<code>hashchange</code>这个事件，然后改变<code>data.current</code></p><div class="hljs"><pre><code class="hljs js">initEvent() &#123;  <span class="hljs-comment">// 监听前进后退时浏览器触发的popstate事件</span>  <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'popstate'</span>, () =&gt; &#123;    <span class="hljs-keyword">this</span>.data.current = <span class="hljs-built_in">window</span>.location.pathname  &#125;)&#125;</code></pre></div><h3 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h3><p>最后我们可以用<code>init</code>方法来统一调用上述的三个方法</p><div class="hljs"><pre><code class="hljs js">init () &#123;  <span class="hljs-keyword">this</span>.createRouteMap()  <span class="hljs-keyword">this</span>.initComponents(_Vue)  <span class="hljs-keyword">this</span>.initEvent()&#125;</code></pre></div><h2 id="3-router-view组件"><a href="#3-router-view组件" class="headerlink" title="3. router-view组件"></a>3. router-view组件</h2><p>通过router-view组件的实现我们可以更方便的理解页面视图是如何更新的。</p><p>我们在使用VueRouter时，一般都会使用router-view组件来表示这里要根据路由渲染页面：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"nav"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>&gt;</span>Index<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> |  <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/blog"</span>&gt;</span>Blog<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span> |  <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/photo"</span>&gt;</span>Photo<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span></code></pre></div><p>而router-view就是VueRouter提供的一个内置组件，其实现也非常简单：</p><div class="hljs"><pre><code class="hljs js">Vue.component(<span class="hljs-string">'router-view'</span>, &#123;  render (h) &#123;    <span class="hljs-keyword">const</span> component = self.routeMap[self.data.current]    <span class="hljs-keyword">return</span> h(component)  &#125;&#125;)</code></pre></div><p>首先通过上面我们构建好的RouteMap找到要渲染的组件，然后调用h函数渲染就行了。</p><p>h函数是虚拟DOM技术里出镜率极高的函数，来源于<code>Snabbdom</code>这个虚拟DOM模块，作用就是渲染虚拟节点Vnode（这里就是Vue的组件）到页面上。</p><h2 id="4-router-link组件"><a href="#4-router-link组件" class="headerlink" title="4. router-link组件"></a>4. router-link组件</h2><div class="hljs"><pre><code class="hljs js">Vue.component(<span class="hljs-string">'router-link'</span>, &#123;  props: &#123;    to: <span class="hljs-built_in">String</span>  &#125;,  render (h) &#123;    <span class="hljs-comment">// 如果不使用完整版本的Vue预编译模板，就需要使用render函数而不是template</span>    <span class="hljs-keyword">return</span> h(      <span class="hljs-string">'a'</span>, <span class="hljs-comment">// 标签名</span>      &#123;        attrs: &#123;          <span class="hljs-comment">// html属性</span>          href: <span class="hljs-keyword">this</span>.to        &#125;,        on: &#123;          click: <span class="hljs-keyword">this</span>.clickHandler        &#125;      &#125;,      [ <span class="hljs-keyword">this</span>.$slots.default ] <span class="hljs-comment">// 生成的内容</span>    )  &#125;,  methods: &#123;    clickHandler(e) &#123;      <span class="hljs-comment">// 使用pushState改变地址栏，但不会向服务器发送请求</span>      history.pushState(&#123;&#125;, <span class="hljs-string">''</span>, <span class="hljs-keyword">this</span>.to)      <span class="hljs-keyword">this</span>.$router.data.current = <span class="hljs-keyword">this</span>.to      e.preventDefault()    &#125;  &#125;  <span class="hljs-comment">// template: '&lt;a :href="to"&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/a&gt;'</span>&#125;)</code></pre></div><p>router-link本质上就是创建一个a标签，把要跳转的地址设置到href属性上，并不复杂。</p><p>关键在于劫持点击事件，当点击发生时改变<code>data.current</code>的指向即可。</p>]]></content>
    
    
    <categories>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack进阶</title>
    <link href="/2020/July/Javascript-webpack-advance/"/>
    <url>/2020/July/Javascript-webpack-advance/</url>
    
    <content type="html"><![CDATA[<h1 id="Webpack进阶"><a href="#Webpack进阶" class="headerlink" title="Webpack进阶"></a>Webpack进阶</h1><h2 id="1-Dev-Server"><a href="#1-Dev-Server" class="headerlink" title="1. Dev-Server"></a>1. <code>Dev-Server</code></h2><p><code>webpack-dev-server</code>是使用率最高的webpack插件之一，其主要特点就是集成了打包和浏览器加载以及热更新这一套组合拳，特别是其打包后的文件是在内存中的，并不会真正生成到dist目录，避免了大量的重复磁盘读写。</p><p>安装：</p><div class="hljs"><pre><code class="hljs bash">yarn add webpack-dev-server --dev</code></pre></div><p>启动方式：</p><div class="hljs"><pre><code class="hljs bash">yarn webpack-dev-server // 默认从根目录打包</code></pre></div><p>老样子，安装后需要在<code>webpack.config.js</code>里配置</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  devServer: &#123;    contentBase: <span class="hljs-string">'./public'</span>,    proxy: &#123;      <span class="hljs-string">'/api'</span>: &#123;        <span class="hljs-comment">// http://localhost:8080/api/users -&gt; https://api.github.com/api/users</span>        target: <span class="hljs-string">'https://api.github.com'</span>,        <span class="hljs-comment">// http://localhost:8080/api/users -&gt; https://api.github.com/users</span>        pathRewrite: &#123;          <span class="hljs-string">'^/api'</span>: <span class="hljs-string">''</span>        &#125;,        <span class="hljs-comment">// 不能使用 localhost:8080 作为请求 GitHub 的主机名</span>        changeOrigin: <span class="hljs-literal">true</span>      &#125;    &#125;  &#125;&#125;</code></pre></div><p><code>contentBase</code>表示静态资源路径，这个目录下的文件不会被打包，有利于提高开发时的打包效率（静态文件一般只在最后打包上线时才应该被真正打包处理）</p><p><code>proxy</code>表示代理转发，这是一个非常有用的配置。在本地开发阶段时，一般本地我们的网站都是以<code>localhost:8080</code>这类网址来运行的，当需要请求一些api接口时就会出现跨域问题，这时就要通过<code>proxy</code>来转发。</p><h2 id="2-source-map"><a href="#2-source-map" class="headerlink" title="2. source-map"></a>2. <code>source-map</code></h2><p><code>source-map</code>是一种位置信息文件，主要保存了打包后的代码与源代码之间的对应关系，在调试的时候极为有用。</p><p>在webpack里配置<code>source-map</code>，主要使用devtool这个属性</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  devtool: <span class="hljs-string">'source-map'</span> <span class="hljs-comment">// 可以换成其他生成模式</span>&#125;</code></pre></div><p>然后就会生成<code>source-map</code>文件，比如<code>bundle.js.map</code></p><p>webpack支持多种<code>source-map</code>的生成方式，其性能和效率各有不同</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200715191338417.png" srcset="/img/loading.gif" alt="image-20200715191338417"></p><p>不同的模式从命名上就能看出基本的特点</p><ul><li>eval - 是否使用eval实行模块代码</li><li>cheap - 是否包含行信息</li><li>module - 是否能得到Loader处理之前的源代码</li><li>inline - 将<code>source-map</code>以data-url的形式嵌入到代码中（会增大代码文件体积）</li><li>hidden - 生成<code>source-map</code> 但是不在打包后的代码文件中引入（也就是提供<code>source-map</code>但是不用）</li><li>nosources - 不显示源代码（会显示错误位置的行列信息），主要用于生产环境里保护源代码不暴露</li></ul><hr><p>在开发环境下首先推荐使用的是<code>cheap-module-eval-source-map</code>这个模式</p><p>其优势如下：</p><ol><li><p>因为一般只要代码风格控制得当，每行不长，行信息就足够了，不需要列信息。</p></li><li><p>现在项目都会使用多个Loader多次打包，所以显示原始的源代码是有必要的。</p></li><li><p>这个模式首次打包慢但是rebuild很快，符合我们经常调试时频繁重新打包的需要</p></li></ol><p>而在生产环境下，建议选择<code>none</code>，不要提供<code>source-map</code></p><h2 id="3-Hot-Module-Replacement"><a href="#3-Hot-Module-Replacement" class="headerlink" title="3. Hot Module Replacement"></a>3. Hot Module Replacement</h2><p>HMR可以算是webpack中最为好用的功能之一，所谓HMR就是只替换有改动的文件而不用刷新整个页面，这极大地提高了开发效率。</p><p><code>webpack-dev-server</code>本身就支持HMR，可以通过命令参数开启</p><div class="hljs"><pre><code class="hljs bash">yarn webpack-dev-server --hot</code></pre></div><p>也可以通过配置，这时还需要引入webpack内置的<code>HotModuleReplacementPlugin</code>插件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>)<span class="hljs-built_in">module</span>.exports = &#123;  devServer: &#123;    hot: <span class="hljs-literal">true</span>  &#125;,  plugins: [    <span class="hljs-keyword">new</span> webpack.HotModuleReplacementPlugin()  ]&#125;</code></pre></div><p>但是这还不够，这只能保证css等样式代码自动HMR，js代码却不行，页面依然会刷新。</p><p>这是因为js代码过于灵活，webpack无法判断要如何执行HMR，必须要用户来指定更新方法。</p><p>我们需要使用<code>HotModuleReplacementPlugin</code>提供的<code>module.hot</code>API</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> createEditor <span class="hljs-keyword">from</span> <span class="hljs-string">'./editor'</span><span class="hljs-keyword">import</span> background <span class="hljs-keyword">from</span> <span class="hljs-string">'./better.png'</span><span class="hljs-keyword">import</span> <span class="hljs-string">'./global.css'</span><span class="hljs-keyword">const</span> editor = createEditor()<span class="hljs-built_in">document</span>.body.appendChild(editor)<span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> Image()img.src = background<span class="hljs-built_in">document</span>.body.appendChild(img)<span class="hljs-comment">// ============ 以下用于处理 HMR，与业务代码无关 ============</span><span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>.hot) &#123;  <span class="hljs-comment">// js模块的HMR</span>  <span class="hljs-keyword">let</span> lastEditor = editor <span class="hljs-comment">// 保存之前的页面数据</span>  <span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">'./editor'</span>, () =&gt; &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'editor 模块更新了，需要这里手动处理热替换逻辑'</span>)    <span class="hljs-keyword">const</span> value = lastEditor.innerHTML    <span class="hljs-built_in">document</span>.body.removeChild(lastEditor)    <span class="hljs-keyword">const</span> newEditor = createEditor()    newEditor.innerHTML = value <span class="hljs-comment">// 恢复更新前的页面数据</span>    <span class="hljs-built_in">document</span>.body.appendChild(newEditor)    lastEditor = newEditor  &#125;)  <span class="hljs-comment">// 图片的HMR</span>  <span class="hljs-built_in">module</span>.hot.accept(<span class="hljs-string">'./better.png'</span>, () =&gt; &#123;    img.src = background    <span class="hljs-built_in">console</span>.log(background)  &#125;)&#125;</code></pre></div><p>这些代码在webpack打包后会被移除，所以并不用担心影响生产环境。</p><p>但依然会发现原生的HMR虽然强大但是要编写这些替换逻辑比较繁琐，而这也是开发者现在更愿意使用<code>vue-cli</code>，<code>create-react-app</code>这些现成的集合框架，它们已经内置了替换逻辑，可以直接进行HMR</p><h2 id="4-多配置文件"><a href="#4-多配置文件" class="headerlink" title="4. 多配置文件"></a>4. 多配置文件</h2><p>在实际项目中，往往需要针对不对的环境配置相应的<code>webpack.config</code>文件</p><div class="hljs"><pre><code class="hljs reStructuredText">-- webpack.common.js-- webpack.dev.js-- webpack.prod.js</code></pre></div><p>比较常用的方法是将通用的部分抽出为<code>webpack.common.js</code>文件，然后在各自的配置里使用合并，这时我们可以使用<code>webpack-merge</code>这个插件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> merge = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-merge'</span>)<span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'clean-webpack-plugin'</span>)<span class="hljs-keyword">const</span> CopyWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'copy-webpack-plugin'</span>)<span class="hljs-keyword">const</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpack.common'</span>)<span class="hljs-built_in">module</span>.exports = merge(common, &#123;  mode: <span class="hljs-string">'production'</span>,  plugins: [    <span class="hljs-keyword">new</span> CleanWebpackPlugin(),    <span class="hljs-keyword">new</span> CopyWebpackPlugin([<span class="hljs-string">'public'</span>])  ]&#125;)</code></pre></div><p>其提供的<code>merge</code>函数可以把不同配置的属性针对性地合并，比如这里的<code>plugins</code>，我们并不想覆盖掉common里的插件数组，而是合并。</p><p>然后运行webpack的时候就要指定配置文件</p><div class="hljs"><pre><code class="hljs bash">yarn webpack --config webpack.prod.js</code></pre></div><p>也可以把这个命令集成到<code>package.json</code>的<code>scripts</code>里简化</p><div class="hljs"><pre><code class="hljs json">&#123;  <span class="hljs-attr">"scripts"</span>: &#123;    <span class="hljs-attr">"builid"</span>: <span class="hljs-string">"webpack --config webpack.prod.js"</span>  &#125;&#125;</code></pre></div><h2 id="4-Tree-Shaking"><a href="#4-Tree-Shaking" class="headerlink" title="4. Tree-Shaking"></a>4. Tree-Shaking</h2><p>Tree-Shaking可以在打包是去除未被使用到的代码，有效减小代码体积。webpack默认在production会自动进行Tree-Shaking，其他模式下要手动开启，主要就是使用<code>optimazation</code>属性。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  mode: <span class="hljs-string">'none'</span>， <span class="hljs-comment">// 非production模式</span>  entry: <span class="hljs-string">'./src/index.js'</span>,  output: &#123;   filename: <span class="hljs-string">'bundle.js'</span>  &#125;,  optimization: &#123;    usedExports: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 在打包时仅导出使用到的成员变量</span>    minimize: <span class="hljs-literal">true</span> <span class="hljs-comment">// 压缩移除掉未被引用到的代码</span>  &#125;&#125;</code></pre></div><p><code>usedExports</code>可以在打包阶段找到哪些是被引用到的成员，将其导出，而剩下的未被引用成员就会在<code>minimize</code>阶段被移除。</p><p><code>optimization</code>里还有一个<code>concatenateModules</code>选项，可以尽可能把代码合并到一个模块函数内，提升运行效率和再次减小代码体积，这个功能是webpack3加入的，也被称作<code>scope hoisting</code></p><div class="hljs"><pre><code class="hljs js">optimization: &#123;  concatenateModules: <span class="hljs-literal">true</span>&#125;</code></pre></div><hr><p>Tree-Shaking只能对ES Module起效，这点尤其需要注意，如果使用了Babel的话可能会因为js被编译成了CommonJS而导致Tree-Shaking失效。</p><p>目前新版的Babel不会导致这个问题，我们也可以通过强制指定编译模式来确保：</p><div class="hljs"><pre><code class="hljs js">rules: [  &#123;    test: <span class="hljs-regexp">/\.js$/</span>,    use: &#123;      loader: <span class="hljs-string">'babel-loader'</span>,      options: &#123;        presets: [          [<span class="hljs-string">'@babel/preset-env'</span>, &#123; <span class="hljs-attr">modules</span>: <span class="hljs-literal">false</span> &#125;]        ]      &#125;    &#125;  &#125;]</code></pre></div><p>注意presets的配置，添加选项对象时要嵌套两层数组</p><h2 id="5-SideEffect"><a href="#5-SideEffect" class="headerlink" title="5. SideEffect"></a>5. SideEffect</h2><p>Side-Effect顾名思义表示副总用，如果一个模块没有副作用，就表示除了export，其余代码不会造成任何额外变化（类似纯函数的概念），我们可以在模块对应的<code>package.json</code>里标注<code>sideEffects: false</code>来表示这点，然后webpack就会进一步移除掉未被引用的代码（这个功能在开发npm库时可能使用更多）</p><p>production环境下是默认开启的</p><div class="hljs"><pre><code class="hljs js">optimization: &#123;  sideEffects: <span class="hljs-literal">true</span>&#125;</code></pre></div><p>这个功能的意义在于Tree-Shaking是通过代码是否被引用来判断优化的，但有些时候代码可能被import了却并没有真正使用，比如下面这种整合了局部组件的情况，虽然最后可能只有Button被真正使用了，但Link由于也被引入了所以也会被一起打包进来。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> Button &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./button.js'</span><span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> Link &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./link.js'</span></code></pre></div><h2 id="6-代码分割-分包"><a href="#6-代码分割-分包" class="headerlink" title="6. 代码分割/分包"></a>6. 代码分割/分包</h2><p>在项目越来越大以后，我们不希望把所有代码都打包到一个bundle.js里面，这会严重拖慢加载速度。理想情况是用户打开了哪个页面就加载哪个部分，因此代码分割打包就势在必行。</p><h3 id="6-1-多入口打包"><a href="#6-1-多入口打包" class="headerlink" title="6.1 多入口打包"></a>6.1 多入口打包</h3><p>很简单，从多个js文件入口开始打包，生成各自的打包文件。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  entry: &#123;    index: <span class="hljs-string">'./src/index.js'</span>,    album: <span class="hljs-string">'./src/album.js'</span>  &#125;,  output: &#123;    filename: <span class="hljs-string">'[name].bundle.js'</span>  &#125;,&#125;</code></pre></div><p>这样之后还有个问题，假如我们使用了<code>HtmlWebpackPlugin</code>，每个生成的html都会把所有的打包js文件都导入一次，这显然不是我们所期望的。</p><p>所以我们还设置一个属性，就是chunks</p><div class="hljs"><pre><code class="hljs js">plugins: [  <span class="hljs-keyword">new</span> CleanWebpackPlugin(),  <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;    title: <span class="hljs-string">'Multi Entry'</span>,    template: <span class="hljs-string">'./src/index.html'</span>,    filename: <span class="hljs-string">'index.html'</span>,    chunks: [<span class="hljs-string">'index'</span>]  &#125;),  <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;    title: <span class="hljs-string">'Multi Entry'</span>,    template: <span class="hljs-string">'./src/album.html'</span>,    filename: <span class="hljs-string">'album.html'</span>,    chunks: [<span class="hljs-string">'album'</span>]  &#125;)]</code></pre></div><p>这样每个html都只会引入自己的bundle.js打包文件了。</p><p>我们还可以让webpack帮我们提取各个模块的公共部分，避免分割以后重复打包。</p><div class="hljs"><pre><code class="hljs js">optimization: &#123;  splitChunks: &#123;    chunks: <span class="hljs-string">'all'</span>  &#125;&#125;</code></pre></div><p>这样webpack会自动把公共部分打包到一个新文件里。</p><h3 id="6-2-动态导入"><a href="#6-2-动态导入" class="headerlink" title="6.2 动态导入"></a>6.2 动态导入</h3><p>也就是真正意义上的按需加载，使用ES Module的<code>import</code>函数，而不是在文件开头使用<code>import from</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// import posts from './posts/posts'</span><span class="hljs-comment">// import album from './album/album'</span><span class="hljs-keyword">const</span> render = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">const</span> hash = <span class="hljs-built_in">window</span>.location.hash || <span class="hljs-string">'#posts'</span>  <span class="hljs-keyword">const</span> mainElement = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.main'</span>)  mainElement.innerHTML = <span class="hljs-string">''</span>  <span class="hljs-keyword">if</span> (hash === <span class="hljs-string">'#posts'</span>) &#123;    <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: 'components' */</span><span class="hljs-string">'./posts/posts'</span>).then(<span class="hljs-function">(<span class="hljs-params">&#123; <span class="hljs-keyword">default</span>: posts &#125;</span>) =&gt;</span> &#123;      mainElement.appendChild(posts())    &#125;)  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hash === <span class="hljs-string">'#album'</span>) &#123;    <span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName: 'components' */</span><span class="hljs-string">'./album/album'</span>).then(<span class="hljs-function">(<span class="hljs-params">&#123; <span class="hljs-keyword">default</span>: album &#125;</span>) =&gt;</span> &#123;      mainElement.appendChild(album())    &#125;)  &#125;&#125;</code></pre></div><p>上面代码里在<code>import</code>内部还使用了注释代码</p><blockquote><p>/* webpackChunkName: ‘components’ */</p></blockquote><p>这样可以指定把动态导入的模块打包到哪里，不指定的话生成的bundle文件会以数字为序号。如果指定名一样的话就会打包到同一个文件里。</p><hr><p>然后我们还可以让css文件也按需加载，通过安装使用一个插件<code>MiniCssExtractPlugin</code>把css从打包中抽取出来单独构成一个文件。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>)<span class="hljs-built_in">module</span>.exports = &#123;  plugins: [    <span class="hljs-keyword">new</span> MiniCssExtractPlugin()  ]&#125;</code></pre></div><p>使用这个插件之后原来的<code>style-loader</code>就不需要了（因为css已经不在打包后的js里面了），我们要使用<code>MiniCssExtractPlugin</code>自带的loader</p><div class="hljs"><pre><code class="hljs js">&#123;  test: <span class="hljs-regexp">/\.css$/</span>,  use: [    MiniCssExtractPlugin.loader,    <span class="hljs-string">'css-loader'</span>  ]&#125;</code></pre></div><p>要注意的，如果css不是很大（未超过150kb），就没有必要单独提取出来，和js打包在一起的性能会更好一些。</p><p>最后我们还需要压缩这个独立的css文件（webpack默认只能压缩js文件）</p><p>需要使用官方推荐的<code>optimize-css-assets-webpack-plugin</code></p><p>安装后按照惯例配置插件：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>)<span class="hljs-keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'optimize-css-assets-webpack-plugin'</span>)<span class="hljs-built_in">module</span>.exports = &#123;  plugins: [    <span class="hljs-keyword">new</span> MiniCssExtractPlugin(),    <span class="hljs-keyword">new</span> OptimizeCssAssetsWebpackPlugin()  ]&#125;</code></pre></div><p>有意思的是，webpack其实建议把这个插件配置到minimizer数组里，而不是plugins数组。所有的压缩有关的插件都可以放到minimizer里面，使用参数统一控制是否压缩。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  optimization: &#123;    minimizer: &#123;      <span class="hljs-keyword">new</span> OptimizeCssAssetsWebpackPlugin()    &#125;  &#125;&#125;</code></pre></div><p>production打包时minimizer会自动开启</p><p>不过这样一来js就没法自动压缩了，因为minimizer这个自定义压缩配置会覆盖默认，所以还需要配置一个js的默认压缩插件</p><p>安装<code>terser-webpack-plugin</code>，这是webpack默认使用的js压缩插件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> TerserWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'terser-webpack-plugin'</span>)<span class="hljs-built_in">module</span>.exports = &#123;   optimization: &#123;    minimizer: &#123;      <span class="hljs-keyword">new</span> TerserWebpackPlugin(),      <span class="hljs-keyword">new</span> OptimizeCssAssetsWebpackPlugin()    &#125;  &#125;&#125;</code></pre></div><h2 id="7-Hash命名"><a href="#7-Hash命名" class="headerlink" title="7. Hash命名"></a>7. Hash命名</h2><p>我们可以看到很多项目打包后的bundle名字里都带了一串hash，这主要是为文件缓存服务的，hash编号可以区分文件是否有更新，如果不同则当做新文件缓存。这样可以解决新老文件同名时文件缓存不更新的问题。</p><p>一般常用的有三种hash命名方式：</p><table><thead><tr><th align="center">命名方式</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">‘[name]-[hash].bundle.js’</td><td align="center">每次打包整体重设hash</td></tr><tr><td align="center">‘[name]-[chunkhash].bundle.js’</td><td align="center">以chunk为单位，一个chunk共享一个hash</td></tr><tr><td align="center">‘[name]-[contenthash].bundle.js’</td><td align="center">文件级hash，最适合解决缓存问题</td></tr></tbody></table><p>基本上配置里配置文件输出名的地方都可以使用hash:</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 打包输出</span>output: &#123;  filename: <span class="hljs-string">'[name]-[contenthash:8].bundle.js'</span>&#125;<span class="hljs-comment">// 插件里面也可以</span>plugins: [  <span class="hljs-keyword">new</span> MiniCssExtractPlugin(&#123;    filename: <span class="hljs-string">'[name]-[contenthash:8].bundle.css'</span>  &#125;)]</code></pre></div><p>可以在hash属性后面增加<code>:number</code>来控制生成hash的长度，默认是20位。</p>]]></content>
    
    
    <categories>
      
      <category>前端学习笔记</category>
      
      <category>自动化工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack基础</title>
    <link href="/2020/July/Javascript-webpack-basic/"/>
    <url>/2020/July/Javascript-webpack-basic/</url>
    
    <content type="html"><![CDATA[<h1 id="Webpack基础"><a href="#Webpack基础" class="headerlink" title="Webpack基础"></a>Webpack基础</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>很简单，主要就是webpack和webpack-cli两个模块</p><div class="hljs"><pre><code class="hljs bash">yarn add webpack webpack-cli --dev</code></pre></div><p>然后就可以使用命令打包了</p><div class="hljs"><pre><code class="hljs bash">yarn webpack</code></pre></div><p>默认情况下webpack会把<code>src/index.html</code>作为打包入口，打包结果存放在dist文件夹下</p><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><p>在项目根目录下添加<code>webpack.config.js</code>，注意这个文件默认是在node环境下运行，所以采用CommonJS规范</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>)<span class="hljs-built_in">module</span>.exports = &#123;  entry: <span class="hljs-string">'./src/main.js'</span>, <span class="hljs-comment">// 打包入口文件，可以是相对路径</span>  output: &#123;    filename: <span class="hljs-string">'bundle.js'</span>, <span class="hljs-comment">// 输出文件名称</span>    path: path.join(__dirname, <span class="hljs-string">'dist'</span>) <span class="hljs-comment">// 输出文件目录，必须是绝对路径</span>  &#125;&#125;</code></pre></div><p>webpack默认的打包模式为production，会自动进行代码合并压缩等优化操作</p><p>可以通过<code>--mode</code>来设置打包模式</p><p>除了production还有devlopment和none两种模式</p><div class="hljs"><pre><code class="hljs bash">yarn webpack --mode development/none</code></pre></div><ul><li><p>development模式下webpack会优化打包速度和添加一些辅助调试的代码</p></li><li><p>none模式是最原始基础的打包</p></li></ul><p>当然也可以在配置中预先设置打包模式</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  mode: <span class="hljs-string">'development'</span>&#125;</code></pre></div><h2 id="3-loader加载器"><a href="#3-loader加载器" class="headerlink" title="3. loader加载器"></a>3. loader加载器</h2><p><strong>webpack默认只能处理js文件</strong>，其他文件需要安装对应的loader来处理，这也是webpack的核心所在。</p><p>loader的工作机制类似管道，所以可以把不同的loader组合起来使用，但要注意的是webpack要求最后的Result一定要是js代码。</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200714154649412.png" srcset="/img/loading.gif" alt="image-20200714154649412"></p><h3 id="3-1-loader分类"><a href="#3-1-loader分类" class="headerlink" title="3.1 loader分类"></a>3.1 loader分类</h3><p>基本上webpack的loader有三类</p><ul><li>把代码转换为js格式，比如<code>css-loader</code></li><li>处理拷贝文件，导出文件路径，比如<code>file-loader</code></li><li>辅助功能，代码校验，比如<code>eslint-loader</code></li></ul><h3 id="3-2-css-loader-style-loader"><a href="#3-2-css-loader-style-loader" class="headerlink" title="3.2 css-loader/style-loader"></a>3.2 <code>css-loader</code>/<code>style-loader</code></h3><p>比如要处理css文件就需要安装<code>css-loader</code></p><div class="hljs"><pre><code class="hljs bash">yarn add css-loader --dev</code></pre></div><p>然后需要在module属性的rules里配置规则，rules是一个数组，一个rule需要包括两个属性：</p><ul><li><code>test</code> 匹配目标文件路径，一般使用regex</li><li><code>use</code> 需要使用的loader，不仅可以是名字，也可以是路径，和require类似</li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-built_in">module</span>: &#123;    rules: [      &#123;        test: <span class="hljs-regexp">/.css$/</span>,        use: <span class="hljs-string">'css-loader'</span>      &#125;    ]  &#125;&#125;</code></pre></div><p>然后还需要安装<code>style-loader</code>，因为<code>css-loader</code>只是把css转换为js数组，我们还需要一个loader来把转换好的css加载到页面上。</p><div class="hljs"><pre><code class="hljs bash">yarn add style-loader --dev</code></pre></div><p>然后更改use为一个数组</p><div class="hljs"><pre><code class="hljs js">rules: [  &#123;    test: <span class="hljs-regexp">/.css$/</span>,    use: [      <span class="hljs-string">'style-loader'</span>,      <span class="hljs-string">'css-loader'</span>    ]  &#125;]</code></pre></div><p>注意当use为数组时，执行顺序为从下往上</p><p>这里我们希望先执行<code>css-loader</code>之后再执行<code>style-loader</code>，所以把<code>style-loader</code>放上面。</p><p>webpack推荐以js文件为打包入口，在js里import引入css等其他所需的文件，这样有利于tree-shaking清理未被使用的代码，同时也符合webpack的设计思想—<code>围绕js来进行打包服务，当js需要使用其他资源时，应该就地引入</code>。这更贴近于现代组件化的前端开发模式（比如React，Vue等都是把css样式和组件放在一起，甚至直接使用css-in-js）</p><h3 id="3-3-file-loader"><a href="#3-3-file-loader" class="headerlink" title="3.3 file-loader"></a>3.3 <code>file-loader</code></h3><p>打包图片等静态文件资源需要安装<code>file-loader</code></p><div class="hljs"><pre><code class="hljs bash">yarn add file-loader --dev</code></pre></div><p>然后同样的，需要设置rule</p><div class="hljs"><pre><code class="hljs js">&#123;  test: <span class="hljs-regexp">/.png$/</span>,  use: <span class="hljs-string">'file-loader'</span>&#125;</code></pre></div><p>要注意的是webpack默认的资源路径是项目的根目录，并不是我们设置输出目录dist。也就是说，webpack默认打包文件输出的地方就应该是项目运行的根目录（很好理解，理想情况下dist就是最后部署运行的唯一目录）</p><p>所以一些情况下如果dist不是根目录，比如本地开发时我们可能仍然在原来的目录下去引用dist里面的打包文件，这时就要告诉webpack这个打包目录相对于真正的根目录在哪。</p><p>否则一些需要使用这些资源的地方就会报错。</p><p>打包过的bundle.js里可以看到图片文件的路径：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = __webpack_require__.p + <span class="hljs-string">"aaa0e8af..3e18.png"</span> <span class="hljs-comment">// 文件名被替换成了hash，可以防止名字重复</span></code></pre></div><p>里面的<code>__webpack_require__.p</code>就是我们需要设置的资源路径publicPath</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  output: &#123;    filename: <span class="hljs-string">'bundle.js'</span>,    path: path.join(__dirname, <span class="hljs-string">'dist'</span>),    publicPath: <span class="hljs-string">'dist/'</span> <span class="hljs-comment">// 注意斜杠不能省略，因为会直接被拼接到路径里</span>  &#125;&#125;</code></pre></div><p>publicPath是很有用的属性，可以结合env来设置不同的值，比如有些时候我们希望发布后托管资源到云端或者其他地方，就可以根据需求修改publicPath</p><h3 id="3-4-url-loader"><a href="#3-4-url-loader" class="headerlink" title="3.4 url-loader"></a>3.4 <code>url-loader</code></h3><p><code>url-loader</code>可以把资源文件直接转换为url，这样就可以避免使用http的方式去请求文件。</p><p>这是因为url本身也是可以保存数据的</p><div class="hljs"><pre><code class="hljs html">data: [<span class="hljs-tag">&lt;<span class="hljs-name">mediatype</span>&gt;</span>][;base64],<span class="hljs-tag">&lt;<span class="hljs-name">data</span>&gt;</span> 协议     媒体类型编码文件内容</code></pre></div><p>比如下面的一个url，就直接传输了一个html页面数据</p><div class="hljs"><pre><code class="hljs html">data:text/html;charset=UTF-8,<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>html content<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre></div><p>把小文件转换为url是很有用的（大文件不应该使用url，因为转换后的js文件也会过大），比较好的方式是把10kb以下的文件转化为url，超过的则照常使用<code>file-loader</code></p><p>首先安装<code>url-loader</code></p><div class="hljs"><pre><code class="hljs bash">yarn add url-loader --dev</code></pre></div><p>然后配置rule，不过这次use既不是字符串也不是一个数组，我们要使用一个对象，这样就可以在里面使用options来配置细节。</p><div class="hljs"><pre><code class="hljs js">&#123;  test: <span class="hljs-regexp">/.png$/</span>,  use: &#123;    loader: <span class="hljs-string">'url-loader'</span>,    options: &#123;      limit: <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> <span class="hljs-comment">// 单位是字节，这里表示10kb</span>    &#125;  &#125;&#125;</code></pre></div><p>现在<code>url-loader</code>就回自动对10kb以下的文件进行url转换了，不过要注意的是，<code>url-loader</code>对超过大小的文件默认还是会调用<code>file-loader</code>，所以仍然需要安装<code>file-loader</code></p><h3 id="3-5-babel-loader"><a href="#3-5-babel-loader" class="headerlink" title="3.5 babel-loader"></a>3.5 <code>babel-loader</code></h3><p>由于webpack本身并不能识别ES6的新特性（除了import/export这两个打包必需的），当需要转换兼容js代码时，就又轮到了大名鼎鼎的<code>babel</code>出场（<code>bable</code>可能会迟到，但永远不会缺席…）</p><p><code>babel-loader</code>还需要依赖<code>babel</code>的核心组件和插件，所以我们要安装以下三个：</p><div class="hljs"><pre><code class="hljs bash">yarn add babel-loader @babel/core @babel/preset-env --dev</code></pre></div><p>然后当然还是要配置</p><div class="hljs"><pre><code class="hljs js">&#123;  test: <span class="hljs-regexp">/.js$/</span>,  use: &#123;    loader: <span class="hljs-string">'babel-loader'</span>,    options: &#123;      presets: [<span class="hljs-string">'@babel/preset-env'</span>]    &#125;  &#125;,  include: [ path.resolve(__dirname, <span class="hljs-string">'src'</span>) ]&#125;</code></pre></div><p>这里的配置基本和模块化一章中一样，关键依然是要指定presets，也就是告诉<code>babel</code>要使用什么插件（<code>preset-env</code>本身就是包含了新特性的一组插件集合）</p><p>注意还要使用<code>include/exclude</code>限定要处理的js文件路径，官方推荐的配置里使用了<code>exclude</code>来排除node_modules。在实际测试中，不使用限定的话运行打包后的代码时会报错。</p><blockquote><p>exclude: /(node_modules|bower_components)/</p></blockquote><h3 id="3-6-html-loader"><a href="#3-6-html-loader" class="headerlink" title="3.6 html-loader"></a>3.6 <code>html-loader</code></h3><p><code>html-loader</code>用于打包html文件</p><div class="hljs"><pre><code class="hljs bash">yarn add html-loader --dev</code></pre></div><p>要注意的是，webpack的任何loader或者多个loader管道式运行后最后生成的一定是js代码，所以<code>html-loader</code>的目的是把js中引用的html文件打包到js里面。</p><p>我们还需要配置如何处理html里面的资源引用问题。</p><div class="hljs"><pre><code class="hljs js">&#123;  test: <span class="hljs-regexp">/.html$/</span>,  use: &#123;    loader: <span class="hljs-string">'html-loader'</span>,    options: &#123;      attr: [<span class="hljs-string">'img:src'</span>, <span class="hljs-string">'a:href'</span>]    &#125;  &#125;&#125;</code></pre></div><p>默认情况下，<code>html-loader</code>只会对img的src属性进行处理，href里面引用的资源是不会被打包的，所以需要按照上面的格式来配置。</p><h3 id="3-7-Webpack资源打包原理"><a href="#3-7-Webpack资源打包原理" class="headerlink" title="3.7 Webpack资源打包原理"></a>3.7 Webpack资源打包原理</h3><p>webpack的资源打包也是有规则的，它类似一个爬虫，从入口文件开始爬取需要加载进来的资源。</p><p>默认情况下webpack会自动打包：</p><ul><li>ES Modules的import声明</li><li>CommonJS的require</li><li>AMD的define和require</li><li>样式代码(css)中的@import和url函数</li><li>html代码中图片标签的src属性</li></ul><h3 id="4-插件Plugin"><a href="#4-插件Plugin" class="headerlink" title="4. 插件Plugin"></a>4. 插件Plugin</h3><p>插件是让webpack变得如此强大的另一个重要原因。插件可以解决打包任务之外的很多自动化操作需求，让webpack开始抢占gulp等传统自动化工具的地盘。</p><h4 id="4-1-clean-webpack-plugin"><a href="#4-1-clean-webpack-plugin" class="headerlink" title="4.1 clean-webpack-plugin"></a>4.1 <code>clean-webpack-plugin</code></h4><p>我们先来试试<code>clean-webpack-plugin</code>，它的作用是在每次打包前清理dist目录</p><div class="hljs"><pre><code class="hljs bash">yarn add clean-webpack-plugin --dev</code></pre></div><p>在<code>webpack.config.js</code>里进行配置</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'clean-webpack-plugin'</span>)<span class="hljs-built_in">module</span>.exports = &#123;  plugins: [    <span class="hljs-keyword">new</span> CleanWebpackPlugin()  ]&#125;</code></pre></div><p>现在每次打包前dist目录就会被自动清理了</p><h4 id="4-2-html-webpack-plugin"><a href="#4-2-html-webpack-plugin" class="headerlink" title="4.2 html-webpack-plugin"></a>4.2 <code>html-webpack-plugin</code></h4><p><code>html-webpack-plugin</code>可以在打包目录下生成一个自动导入所有打包模块的html文件，</p><div class="hljs"><pre><code class="hljs bash">yarn add html-webpack-plugin --dev</code></pre></div><p>然后配置</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>) <span class="hljs-comment">// 直接使用default导出即可</span><span class="hljs-built_in">module</span>.exports = &#123;  plugins: [    <span class="hljs-keyword">new</span> HtmlWebpackPlugin()  ]&#125;</code></pre></div><p>在打包后，dist目录下会自动生成一个html文件，有一点要注意的是，生成的html里对资源的引用路径和配置里的<code>publicPath</code>有关，对这个生成的html来说，因为已经在dist目录下了，就不需要<code>publicPath</code>了，需要删除这项配置。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"&lt;publicPath&gt; + bundle.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>这个插件的好处在于可以动态生成导入了bundle.js的html文件，方便直接从dist目录启动项目。</p><p>如果想要进一步配置这个html文件，可以传参给<code>HtmlWebpackPlugin</code>函数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  plugins: [    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;      title: <span class="hljs-string">'Webpack Plugin Sample'</span>,      meta: &#123;        viewport: <span class="hljs-string">'width=device-width'</span>      &#125;,      template: <span class="hljs-string">'./src/index.html'</span> <span class="hljs-comment">// 可以使用自定义的html模板</span>    &#125;)  ]&#125;</code></pre></div><p>在自定义的模板里可以使用模板语法添加属性</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">%=</span> <span class="hljs-attr">htmlWebpackPlugin.options.title</span> %&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre></div><p>同时，如果想要生成多个html文件也是可以的，只要再增加一个<code>HtmlWebpackPlugin</code>插件实例就行了。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  plugins: [    <span class="hljs-comment">// 默认的index.html文件</span>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;      title: <span class="hljs-string">'Webpack Plugin Sample'</span>,      meta: &#123;        viewport: <span class="hljs-string">'width=device-width'</span>      &#125;,      template: <span class="hljs-string">'./src/index.html'</span>    &#125;),    <span class="hljs-comment">// 再生成一个about.html文件</span>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;      filename: <span class="hljs-string">'about.html'</span> <span class="hljs-comment">// 默认值就是index.html</span>    &#125;)  ]&#125;</code></pre></div><p>其他配置详见官网</p><p><a href="https://github.com/jantimon/html-webpack-plugin#options" target="_blank" rel="noopener">https://github.com/jantimon/html-webpack-plugin#options</a></p><h4 id="4-3-copy-webpack-plugin"><a href="#4-3-copy-webpack-plugin" class="headerlink" title="4.3 copy-webpack-plugin"></a>4.3 <code>copy-webpack-plugin</code></h4><p>这个插件用于拷贝静态文件到dist目录</p><div class="hljs"><pre><code class="hljs bash">yarn add copy-webpack-plugin --dev</code></pre></div><p>进行配置，要注意的是<code>CopyWebpackPlugin()</code>接受的是一个数组，成员是要拷贝文件的路径，可以是通配符或者文件夹，也可以是相对路径。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> CopyWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'copy-webpack-plugin'</span>)<span class="hljs-built_in">module</span>.exports = &#123;  plugins: [   <span class="hljs-keyword">new</span> CopyWebpackPlugin(&#123;      patterns: [ &#123; <span class="hljs-attr">from</span>: <span class="hljs-string">'public/**/*'</span> &#125; ]    &#125;)  ]&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>前端学习笔记</category>
      
      <category>自动化工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS模块化</title>
    <link href="/2020/July/Javascript-module/"/>
    <url>/2020/July/Javascript-module/</url>
    
    <content type="html"><![CDATA[<h1 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h1><h2 id="1-ES-Module基本特性"><a href="#1-ES-Module基本特性" class="headerlink" title="1. ES Module基本特性"></a>1. ES Module基本特性</h2><ul><li>自动采用严格模式，忽略<code>use strict</code></li><li>每个ESM模块都是单独的私有作用域</li><li>ESM是通过CORS去请求外部JS模块的（所以使用链接请求远程JS时要注意对方是否支持）</li><li>ESM的script标签会延迟执行脚本（类似html的defer属性）</li></ul><p>如下就是在html里使用ES Module，就是把type定义为module</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"module"</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">var</span> foo = <span class="hljs-number">100</span></span><span class="javascript">    <span class="hljs-built_in">console</span>.log(foo)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h2 id="2-ES-Module导入导出"><a href="#2-ES-Module导入导出" class="headerlink" title="2. ES Module导入导出"></a>2. ES Module导入导出</h2><p>基本的export/import用法网上很多，这里仅总结几个容易用错的地方。</p><h3 id="2-1-export导出的并非对象字面量"><a href="#2-1-export导出的并非对象字面量" class="headerlink" title="2.1 export导出的并非对象字面量"></a>2.1 export导出的并非对象字面量</h3><p>最常见的错误就是认为export就是导出一个对象：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">'Yihan'</span><span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span><span class="hljs-keyword">export</span> &#123;name, age&#125;</code></pre></div><p>其实<code>export {}</code>只是一种语法，同理<code>import {}</code>也是，并非对象字面量，<strong>导入的时候也不是ES6的对象解构</strong></p><p>所以如果试图像下面那么用就会报错：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> &#123; <span class="hljs-attr">a</span>:<span class="hljs-number">11</span> &#125; <span class="hljs-comment">// Uncaught SyntaxError: Unexpected token ':'</span></code></pre></div><p>但如果使用export default就可以，这时相当于导出了default这个对象，而default等于后面跟的那个对象：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; <span class="hljs-attr">a</span>:<span class="hljs-number">11</span> &#125; <span class="hljs-comment">// it works</span></code></pre></div><h3 id="2-2-default作为导出名"><a href="#2-2-default作为导出名" class="headerlink" title="2.2 default作为导出名"></a>2.2 default作为导出名</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 基本的default使用</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; foo &#125;<span class="hljs-comment">// 或者使用as</span><span class="hljs-keyword">export</span> &#123;    foo <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>,    bar <span class="hljs-keyword">as</span> baz&#125;</code></pre></div><p>如果希望在导入时重命名默认导出default，那么就需要在<code>import {}</code>括号内使用as</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span></code></pre></div><h3 id="2-3-导出的是变量引用，而且只读"><a href="#2-3-导出的是变量引用，而且只读" class="headerlink" title="2.3 导出的是变量引用，而且只读"></a>2.3 导出的是变量引用，而且只读</h3><p>import进来的变量或者方法只是对模块内导出对象的引用，而不是拷贝。所以当模块内发生变化时，这些import进来的变量也会改变，同时要注意它们都是只读的，无法在模块外部被修改。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; age &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span>age = <span class="hljs-number">5</span><span class="hljs-built_in">console</span>.log(age) <span class="hljs-comment">// Uncaught TypeError: Assignment to constant variable.</span></code></pre></div><h3 id="2-4-export-from"><a href="#2-4-export-from" class="headerlink" title="2.4 export from"></a>2.4 export from</h3><p>这个用法可以直接导出刚导入的变量，一般可以在一个组件或模块的汇总文件里使用。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> &#123; Button &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./button.js'</span><span class="hljs-keyword">export</span> &#123; Page &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./page.js'</span></code></pre></div><h3 id="2-5-导入"><a href="#2-5-导入" class="headerlink" title="2.5 导入"></a>2.5 导入</h3><p>ES模块在导入时必须使用完整的路径和文件名。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> x <span class="hljs-keyword">from</span> <span class="hljs-string">'./module'</span> <span class="hljs-comment">// 不行，文件后缀名不能省略</span><span class="hljs-keyword">import</span> x <span class="hljs-keyword">from</span> <span class="hljs-string">'module.js'</span> <span class="hljs-comment">// 不行，相对路径不能省略./ ES会认为你要加载第三方模块</span><span class="hljs-keyword">import</span> x <span class="hljs-keyword">from</span> <span class="hljs-string">'/package/module.js'</span> <span class="hljs-comment">// 可以，从项目根目录开始</span><span class="hljs-keyword">import</span> x <span class="hljs-keyword">from</span> <span class="hljs-string">'http://localhost:3000/package/module.js'</span> <span class="hljs-comment">// 可以，允许使用地址</span><span class="hljs-keyword">import</span> &#123;&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./module.js'</span> <span class="hljs-comment">// 可以，不引入只是执行模块</span></code></pre></div><p>import只能出现在最顶层，不允许直接动态导入。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> path = <span class="hljs-string">'./module.js'</span><span class="hljs-keyword">import</span> x <span class="hljs-keyword">from</span> path <span class="hljs-comment">// 不行</span></code></pre></div><p>想动态加载就必须使用import函数。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span>(path).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">module</span>) </span>&#123; <span class="hljs-comment">// ES模块加载是异步的</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">module</span>)&#125;)</code></pre></div><h2 id="3-在Node里使用ES模块"><a href="#3-在Node里使用ES模块" class="headerlink" title="3. 在Node里使用ES模块"></a>3. 在Node里使用ES模块</h2><h3 id="3-1-Babel"><a href="#3-1-Babel" class="headerlink" title="3.1 Babel"></a>3.1 Babel</h3><p>最常用的方式就是通过万能的Babel来转换</p><p>Babel通过插件来转换每种ES新特性，所以一般需要安装：</p><div class="hljs"><pre><code class="hljs bash">@babel/node  @babel/core  @babel/preset-env</code></pre></div><p>其中preset-env是包含了新特性的一组插件，Babel本身就是通过不同的插件来完成代码转换的。</p><p>然后就可以通过<code>babel-node</code>命令来运行js文件了。</p><div class="hljs"><pre><code class="hljs bash">yarn babel-node index.js --presets=@babel/preset-env</code></pre></div><p>如果不想手动传入presets参数，可以在根目录下创建一个<code>.babelrc</code>文件来配置。</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"presets"</span>: [<span class="hljs-string">"@babel/preset-env"</span>]&#125;</code></pre></div><p>注意我们其实也可以自己来安装特定的插件然后使用</p><p>比如可以单独安装<code>@babel/plugin-transform-modules-commonjs</code></p><p>然后在<code>.babelrc</code>里面配置，这时候可以不使用presets，而是plugins直接配置要用的每个插件。</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"plugins"</span>: [<span class="hljs-string">"@babel/plugin-transform-modules-commonjs"</span>]&#125;</code></pre></div><h3 id="3-2-Node内置的功能"><a href="#3-2-Node内置的功能" class="headerlink" title="3.2 Node内置的功能"></a>3.2 Node内置的功能</h3><p>其实Node较新的版本（高于8.9.0）已经提供了对ES模块的支持，只不过截止目前为止仍然是作为实验特性。</p><div class="hljs"><pre><code class="hljs bash">node --experimental-modules index.mjs</code></pre></div><p>要注意的是需要把模块文件重命名为<code>.mjs</code>文件，如果不想这么麻烦可以在<code>package.json</code>里配置type项：</p><div class="hljs"><pre><code class="hljs json">&#123;    <span class="hljs-attr">"type"</span>: <span class="hljs-string">"module"</span>&#125;</code></pre></div><p>但这样以后所有的js文件都会默认以ES Module的规范加载，也就是说不能再使用CommonJS的那套语法了（比如<code>require</code>）</p><p>这个时候如果还想保留CommonJS的用法，需要把使用CommonJS的模块重命名为<code>.cjs</code>文件。</p>]]></content>
    
    
    <categories>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动化构建工具Gulp</title>
    <link href="/2020/July/Javascript-gulp/"/>
    <url>/2020/July/Javascript-gulp/</url>
    
    <content type="html"><![CDATA[<h1 id="自动化构建工具Gulp"><a href="#自动化构建工具Gulp" class="headerlink" title="自动化构建工具Gulp"></a>自动化构建工具Gulp</h1><p>Gulp作为当下最流行的前端自动化构建工具，功能强大，插件丰富而且简单易上手。虽然最近Gulp的功能被全能的Webpack蚕食了不少，很多项目已经完全依赖Webpack构建了，但Gulp本身还是非常好用的，值得一学。</p><h2 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h2><p>通过yarn/npm安装gulp之后，需要配置的有两个地方，一个是gulp的入口文件gulpfile.js，另一个则是安装gulp的一系列插件</p><p>gulp自带的最常用的命令：</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>src</code></td><td>从指定目录构建一个输入流</td></tr><tr><td><code>dest</code></td><td>构建一个输出流到指定目录</td></tr><tr><td><code>parallel</code></td><td>并行执行任务</td></tr><tr><td><code>series</code></td><td>顺序执行任务</td></tr><tr><td><code>watch</code></td><td>跟踪一个路径内的文件变化，有变化时触发指定的任务</td></tr></tbody></table><p>我们来构建一个最基本的gulp任务：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> style = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> src(<span class="hljs-string">'src/assets/styles/*.scss'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'src'</span> &#125;) <span class="hljs-comment">// base可以指定要忽略的路径符，之后的路径会被完整复制到目标路径</span>    .pipe(plugins.sass(&#123; <span class="hljs-attr">outputStyle</span>: <span class="hljs-string">'expanded'</span> &#125;)) <span class="hljs-comment">// outputStyle控制编译后的css文件风格</span>    .pipe(dest(<span class="hljs-string">'temp'</span>))&#125;</code></pre></div><p>一个任务就是一个函数，需要return一个函数执行，一般我们使用gulp的目的就是自动化打包文件，所以常常先使用<code>src</code>构造一个文件输入流，从目录读取文件，经过处理后再通过<code>dest</code>输出到指定的打包目录。gulp对文件流使用了类似管道pipe的处理概念，使用<code>pipe()</code>可以使用gulp的插件或者自定义方法对文件流进行任意操作。</p><p>同理，下面这样也是一个gulp任务</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> clean = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> del([ <span class="hljs-string">'dist'</span>, <span class="hljs-string">'temp'</span> ])&#125;</code></pre></div><p>使用node自带的del库对目标文件夹进行清理</p><h2 id="2-自动加载插件"><a href="#2-自动加载插件" class="headerlink" title="2. 自动加载插件"></a>2. 自动加载插件</h2><p>一般安装插件后我们需要<code>require</code>来使用，但通过安装一个专门用于加载插件的插件<code>gulp-load-plugins</code>，我们可以把这个过程进一步简化，因为gulp的插件都有固定的命名方式<code>gulp-&lt;name&gt;</code>，通过<code>gulp-load-plugins</code>可以使用<code>plugins.name</code>的方法来直接调用（命名转为驼峰式）</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> loadPlugins = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-load-plugins'</span>)<span class="hljs-keyword">const</span> plugins = loadPlugins() <span class="hljs-comment">// 之后便可在pipe里使用plugins.sass/plugins/babel这样来使用</span></code></pre></div><p>当然不要忘了先安装这些插件，<code>gulp-load-plugins</code>本身并不会帮你安装任何插件，只是把加载方式简化了。</p><h2 id="3-使用Brower-Sync调试"><a href="#3-使用Brower-Sync调试" class="headerlink" title="3. 使用Brower-Sync调试"></a>3. 使用Brower-Sync调试</h2><p>在gulp打包编译完成之后一般我们会打开浏览器进行调试预览，通过<code>brower-sync</code>这个库可以很好地简化这个流程，<code>brower-sync</code>本身并不依赖于gulp，二者是完全独立的库，gulp可以非常轻松地和其结合使用。</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200709221730499.png" srcset="/img/loading.gif" alt="image-20200709221730499"></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> browserSync = <span class="hljs-built_in">require</span>(<span class="hljs-string">'browser-sync'</span>)<span class="hljs-keyword">const</span> bs = browserSync.create()bs.init(&#123;    notify: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 不弹窗提示</span>    port: <span class="hljs-number">2080</span>, <span class="hljs-comment">// 端口号</span>    open: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否马上打开浏览器页面</span>    server: &#123;        baseDir: [ <span class="hljs-string">'temp'</span>, <span class="hljs-string">'src'</span>, <span class="hljs-string">'public'</span> ], <span class="hljs-comment">// 项目目录</span>        <span class="hljs-comment">// 额外配置特定路由的转发</span>        <span class="hljs-comment">// 比如一些html文件里通过src='path'导入的路径/node_modules并不在上面三个目录里面</span>        <span class="hljs-comment">// 所以要转发到我们开发根目录下的node_modules</span>        routes: &#123;            <span class="hljs-string">'/node_modules'</span>: <span class="hljs-string">'node_modules'</span>          &#125;    &#125;&#125;)</code></pre></div><p>配置可以见官网</p><p><a href="https://browsersync.io/docs/options" target="_blank" rel="noopener">https://browsersync.io/docs/options</a></p><h2 id="4-使用watch跟踪文件变化"><a href="#4-使用watch跟踪文件变化" class="headerlink" title="4. 使用watch跟踪文件变化"></a>4. 使用watch跟踪文件变化</h2><p>非常简单，watch的第一个参数是要跟踪的路径，可以使用通配符，第二个就是要执行的任务。</p><div class="hljs"><pre><code class="hljs js">watch(<span class="hljs-string">'src/assets/styles/*.scss'</span>, style)</code></pre></div><p>要注意的是watch的函数签名为</p><div class="hljs"><pre><code class="hljs js">watch(globs, [options], [task])</code></pre></div><p>所以可以最多接受三个参数，路径可以是一个数组，比如<code>[&#39;input/*.js&#39;, &#39;!input/something.js&#39;]</code>，task是一个定义好的任务，可以用在这里用<code>series</code>和<code>parallel</code>来组合任务。</p><h2 id="5-Useref替换资源路径"><a href="#5-Useref替换资源路径" class="headerlink" title="5. Useref替换资源路径"></a>5. Useref替换资源路径</h2><p>在开发过程中，一些资源有时候我们可能是分散引入的，比如从node_modules下面引入，或者从多个js/css文件中引入。我们在打包时希望把这些用到的文件全部整合到一起然后放到一个指定的目录下面，useref插件就是做这个的。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> useref = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> (    src(<span class="hljs-string">'temp/**/*.html'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'temp'</span> &#125;)      .pipe(plugins.useref(&#123; <span class="hljs-attr">searchPath</span>: [ <span class="hljs-string">'temp'</span>, <span class="hljs-string">'.'</span> ] &#125;)) <span class="hljs-comment">// 引用资源搜索的目录，useref会先到temp下面找，找不到就到下一个路径，以此类推</span>      <span class="hljs-comment">// html js css</span>      .pipe(plugins.if(<span class="hljs-regexp">/\.js$/</span>, plugins.uglify())) <span class="hljs-comment">// 在进行打包的过程中还可以使用其他插件来压缩转化</span>      .pipe(plugins.if(<span class="hljs-regexp">/\.css$/</span>, plugins.cleanCss())) <span class="hljs-comment">// 这里的plugins.if也是一个gulp插件</span>      .pipe(        plugins.if(          /\.html$/,          plugins.htmlmin(&#123;            collapseWhitespace: <span class="hljs-literal">true</span>,            minifyCSS: <span class="hljs-literal">true</span>,            minifyJS: <span class="hljs-literal">true</span>          &#125;)        )      )      .pipe(dest(<span class="hljs-string">'dist'</span>))  )&#125;</code></pre></div><p>要注意的是到底合并哪些文件其实是需要在html内指定的</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- build:js assets/scripts/vendor.js --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/node_modules/jquery/dist/jquery.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/node_modules/popper.js/dist/umd/popper.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/node_modules/bootstrap/dist/js/bootstrap.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!-- endbuild --&gt;</span><span class="hljs-comment">&lt;!-- build:js assets/scripts/main.js --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"assets/scripts/main.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!-- endbuild --&gt;</span></code></pre></div><p>上面的注释非常重要，<code>build</code>和<code>endbuild</code>之间就是一个build block，其中的所有文件都会被useref提取打包整合成一个文件，而整合后的文件的文件名和存放路径也在注释中，比如上面的<code>vendor.js</code>和<code>main.js</code></p><h2 id="6-一个完整的gulpfile-js文件"><a href="#6-一个完整的gulpfile-js文件" class="headerlink" title="6. 一个完整的gulpfile.js文件"></a>6. 一个完整的gulpfile.js文件</h2><p>最后我们来看一个完整的定义文件</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; src, dest, parallel, series, watch &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp'</span>)<span class="hljs-keyword">const</span> del = <span class="hljs-built_in">require</span>(<span class="hljs-string">'del'</span>)<span class="hljs-keyword">const</span> browserSync = <span class="hljs-built_in">require</span>(<span class="hljs-string">'browser-sync'</span>)<span class="hljs-keyword">const</span> loadPlugins = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-load-plugins'</span>)<span class="hljs-keyword">const</span> plugins = loadPlugins()<span class="hljs-keyword">const</span> bs = browserSync.create()<span class="hljs-keyword">const</span> clean = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> del([ <span class="hljs-string">'dist'</span>, <span class="hljs-string">'temp'</span> ])&#125;<span class="hljs-keyword">const</span> style = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> src(<span class="hljs-string">'src/assets/styles/*.scss'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'src'</span> &#125;)    .pipe(plugins.sass(&#123; <span class="hljs-attr">outputStyle</span>: <span class="hljs-string">'expanded'</span> &#125;))    .pipe(dest(<span class="hljs-string">'temp'</span>))    .pipe(bs.reload(&#123; <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> &#125;))&#125;<span class="hljs-keyword">const</span> script = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> src(<span class="hljs-string">'src/assets/scripts/*.js'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'src'</span> &#125;)    .pipe(plugins.babel(&#123; <span class="hljs-attr">presets</span>: [ <span class="hljs-string">'@babel/preset-env'</span> ] &#125;))    .pipe(dest(<span class="hljs-string">'temp'</span>))    .pipe(bs.reload(&#123; <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> &#125;))&#125;<span class="hljs-keyword">const</span> page = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> src(<span class="hljs-string">'src/**/*.html'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'src'</span> &#125;)    .pipe(plugins.swig(&#123; data, <span class="hljs-attr">defaults</span>: &#123; <span class="hljs-attr">cache</span>: <span class="hljs-literal">false</span> &#125; &#125;))    .pipe(dest(<span class="hljs-string">'temp'</span>))    .pipe(bs.reload(&#123; <span class="hljs-attr">stream</span>: <span class="hljs-literal">true</span> &#125;))&#125;<span class="hljs-keyword">const</span> image = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> src(<span class="hljs-string">'src/assets/images/**'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'src'</span> &#125;)    .pipe(plugins.imagemin())    .pipe(dest(<span class="hljs-string">'dist'</span>))&#125;<span class="hljs-keyword">const</span> font = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> src(<span class="hljs-string">'src/assets/fonts/**'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'src'</span> &#125;)    .pipe(plugins.imagemin())    .pipe(dest(<span class="hljs-string">'dist'</span>))&#125;<span class="hljs-keyword">const</span> extra = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> src(<span class="hljs-string">'public/**'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'public'</span> &#125;).pipe(dest(<span class="hljs-string">'dist'</span>))&#125;<span class="hljs-keyword">const</span> start = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-comment">// 代码文件</span>  watch(<span class="hljs-string">'src/assets/styles/*.scss'</span>, style)  watch(<span class="hljs-string">'src/assets/scripts/*.js'</span>, script)  watch(<span class="hljs-string">'src/**/*.html'</span>, page)  <span class="hljs-comment">// 资源文件</span>  watch(    [ <span class="hljs-string">'src/assets/images/**'</span>, <span class="hljs-string">'src/assets/fonts/**'</span>, <span class="hljs-string">'public/**'</span> ],    bs.reload  )  bs.init(&#123;    notify: <span class="hljs-literal">false</span>,    port: <span class="hljs-number">2080</span>,    open: <span class="hljs-literal">true</span>,    server: &#123;      baseDir: [ <span class="hljs-string">'temp'</span>, <span class="hljs-string">'src'</span>, <span class="hljs-string">'public'</span> ],      routes: &#123;        <span class="hljs-string">'/node_modules'</span>: <span class="hljs-string">'node_modules'</span>      &#125;    &#125;  &#125;)&#125;<span class="hljs-keyword">const</span> useref = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">return</span> (    src(<span class="hljs-string">'temp/**/*.html'</span>, &#123; <span class="hljs-attr">base</span>: <span class="hljs-string">'temp'</span> &#125;)      .pipe(plugins.useref(&#123; <span class="hljs-attr">searchPath</span>: [ <span class="hljs-string">'temp'</span>, <span class="hljs-string">'.'</span> ] &#125;))      <span class="hljs-comment">// html js css</span>      .pipe(plugins.if(<span class="hljs-regexp">/\.js$/</span>, plugins.uglify()))      .pipe(plugins.if(<span class="hljs-regexp">/\.css$/</span>, plugins.cleanCss()))      .pipe(        plugins.if(          /\.html$/,          plugins.htmlmin(&#123;            collapseWhitespace: <span class="hljs-literal">true</span>,            minifyCSS: <span class="hljs-literal">true</span>,            minifyJS: <span class="hljs-literal">true</span>          &#125;)        )      )      .pipe(dest(<span class="hljs-string">'dist'</span>))  )&#125;<span class="hljs-comment">// 并行执行文件编译</span><span class="hljs-keyword">const</span> compile = parallel(style, script, page)<span class="hljs-comment">// 打包上线之前执行的任务</span><span class="hljs-keyword">const</span> build = series(clean, parallel(compile, image, font, extra), useref)<span class="hljs-comment">// 开发编译并打开Broswer</span><span class="hljs-keyword">const</span> serve = series(compile, start)<span class="hljs-built_in">module</span>.exports = &#123;  clean,  build,  start,  serve&#125;</code></pre></div><h3 id="基础任务"><a href="#基础任务" class="headerlink" title="基础任务"></a>基础任务</h3><table><thead><tr><th>任务名</th><th>功能</th></tr></thead><tbody><tr><td><code>clean</code></td><td>清理temp和dist文件夹</td></tr><tr><td><code>style</code></td><td>编译scss样式文件为css文件</td></tr><tr><td><code>script</code></td><td>编译js文件，通过pipe先进行eslint语法校验再进行babel转译</td></tr><tr><td><code>page</code></td><td>编译html模板文件，渲染swig内容</td></tr><tr><td><code>image</code></td><td>打包静态图片资源</td></tr><tr><td><code>font</code></td><td>打包静态字体资源</td></tr><tr><td><code>extra</code></td><td>打包public目录下的其他静态资源</td></tr><tr><td><code>start</code></td><td>启动浏览器显示项目，并使用watch跟踪src目录下的html/js/css文件变化进行热更新</td></tr><tr><td><code>useref</code></td><td>对html文档中build block注释内的js/css资源导入进行处理，把引用到的文件进行合并打包，并在生成的html内替换</td></tr></tbody></table><h3 id="高级任务"><a href="#高级任务" class="headerlink" title="高级任务"></a>高级任务</h3><table><thead><tr><th>任务名</th><th>功能</th></tr></thead><tbody><tr><td><code>compile</code></td><td>并行执行style/script/page任务，编译scss/js/html文件</td></tr><tr><td><code>build</code></td><td>先进行clean，然后并行执行compile/image/font/extra任务，最后执行useref进行引用替换</td></tr><tr><td><code>serve</code></td><td>先执行compile在执行start，用于开发调试</td></tr></tbody></table><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>使用<code>yarn serve</code>命令即可编译项目并自动打开浏览器预览</p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>使用<code>yarn build</code>命令即可编译并打包所有资源到发布目录dist</p>]]></content>
    
    
    <categories>
      
      <category>前端学习笔记</category>
      
      <category>自动化工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>gulp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript性能优化</title>
    <link href="/2020/June/Javascript-performance/"/>
    <url>/2020/June/Javascript-performance/</url>
    
    <content type="html"><![CDATA[<h1 id="Javascript性能优化"><a href="#Javascript性能优化" class="headerlink" title="Javascript性能优化"></a>Javascript性能优化</h1><h2 id="GC常见算法"><a href="#GC常见算法" class="headerlink" title="GC常见算法"></a>GC常见算法</h2><p>常用的内存回收(Garbage Collection)算法整理：</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/GC%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" alt="GC回收算法"></p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>可以使用Jsperf来进行Javascript代码的性能测试和对比</p><p><a href="https://jsperf.com/yif-global-variable" target="_blank" rel="noopener">https://jsperf.com/yif-global-variable</a></p><h3 id="1-慎用全局变量"><a href="#1-慎用全局变量" class="headerlink" title="1. 慎用全局变量"></a>1. 慎用全局变量</h3><ul><li>全局变量定义在全局执行上下文，是所有作用域链的顶端（根作用域）</li><li>由于一直存在于根作用域，难以被GC（内存回收）清理，会一直存在知道程序退出</li><li>容易被局部作用域的同名变量遮蔽或者污染</li></ul><h3 id="2-将使用中无法避免的全局变量放入缓存"><a href="#2-将使用中无法避免的全局变量放入缓存" class="headerlink" title="2. 将使用中无法避免的全局变量放入缓存"></a>2. 将使用中无法避免的全局变量放入缓存</h3><p>例如为了获取获取dom元素节点，在需要大量获取document节点的函数中缓存全局变量document可以增加性能</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 不使用对象缓存</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBtnWithoutCache</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> btn1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn1'</span>)    <span class="hljs-keyword">let</span> btn2 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn2'</span>)    <span class="hljs-keyword">let</span> btn3 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn3'</span>)&#125;<span class="hljs-comment">// 使用对象缓存</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBtnWitCache</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">document</span>    <span class="hljs-keyword">let</span> btn1 = obj.getElementById(<span class="hljs-string">'btn1'</span>)    <span class="hljs-keyword">let</span> btn2 = obj.getElementById(<span class="hljs-string">'btn2'</span>)    <span class="hljs-keyword">let</span> btn3 = obj.getElementById(<span class="hljs-string">'btn3'</span>)&#125;</code></pre></div><p>其原理是通过缓存加快对document全局变量的访问速度，不需要每次都从根作用域重新查找</p><h3 id="3-通过原型链添加方法"><a href="#3-通过原型链添加方法" class="headerlink" title="3. 通过原型链添加方法"></a>3. 通过原型链添加方法</h3><p>原型链是所有对象共享的，比起在每个对象的this上增加方法，使用原型链的性能会更好</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200630155359315.png" srcset="/img/loading.gif" alt="image-20200630155359315"></p><h3 id="4-避免闭包陷阱"><a href="#4-避免闭包陷阱" class="headerlink" title="4. 避免闭包陷阱"></a>4. 避免闭包陷阱</h3><p>闭包会产生额外的对象引用，会使得本身应该被释放回收的对象由于闭包内的引用而无法被回收</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn'</span>)  el.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)  &#125;&#125;foo()</code></pre></div><p>上面的el由于onclick函数的闭包会一直存在，使得即便btn节点已经从dom中被移除了也不会被回收，因为el一直对其进行引用</p><h3 id="5-避免属性访问方法"><a href="#5-避免属性访问方法" class="headerlink" title="5. 避免属性访问方法"></a>5. 避免属性访问方法</h3><p>Javascript中没有传统面向对象语言的属性访问限制，一个对象里所有属性都是对外暴露的（这里没有讨论ES2015之后的class），在这种情况下，使用对象访问方法反而会降低性能</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">'Me'</span>    <span class="hljs-keyword">this</span>.age = <span class="hljs-number">18</span>    <span class="hljs-keyword">this</span>.getAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age    &#125;&#125;</code></pre></div><p>上面的<code>getAge</code>就是一种属性访问方法，我们可以和直接的属性访问对比：</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200630162233394.png" srcset="/img/loading.gif" alt="image-20200630162233394"></p><p>可以发现直接访问性能明显更好，这也是符合直觉的</p><h3 id="6-For循环优化"><a href="#6-For循环优化" class="headerlink" title="6. For循环优化"></a>6. For循环优化</h3><p>如果for循环的终止条件是一个定值，最好直接把它取出来缓存成一个变量</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 使用len变量来直接获取数组长度，避免重复访问</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;    <span class="hljs-built_in">console</span>.log(i)&#125;</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200630164130926.png" srcset="/img/loading.gif" alt="image-20200630164130926"></p><p>再对比一下常用的四种for方法</p><p><a href="https://jsperf.com/yif-for-loop-performance" target="_blank" rel="noopener">https://jsperf.com/yif-for-loop-performance</a></p><ul><li>forEach (ES5引入)</li><li>for</li><li>for in</li><li>for of (ES2015引入，只能遍历可迭代对象，如数组，不能直接遍历对象，可以遍历<code>Object.values()</code>或者<code>Object.keys()</code>)</li></ul><p>测试的数组</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arrList = []<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;    arrList.push(i)&#125;</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200630180407937.png" srcset="/img/loading.gif" alt="image-20200630180407937"></p><p>可以发现forEach的速度是最快的（但这个结果或许并不准确，关于forEach和for的对比争论在stackoverflow上很多，两者其实在不同场景各有胜负，不过从语义角度而言，forEach作为比较新的语法表达更简洁易读，但要注意的是forEach不能使用break/continue来中断，而ES2015/ES6新加入的for of则可以）</p><h3 id="7-使用文档碎片优化节点添加"><a href="#7-使用文档碎片优化节点添加" class="headerlink" title="7. 使用文档碎片优化节点添加"></a>7. 使用文档碎片优化节点添加</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 直接往body上添加节点元素</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-keyword">let</span> oP = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'p'</span>)    oP.innerHTML = i    <span class="hljs-built_in">document</span>.body.appendChild(oP)&#125;<span class="hljs-comment">// 使用documentFragment</span><span class="hljs-keyword">const</span> fragEle = <span class="hljs-built_in">document</span>.createDocumentFragment()<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-keyword">let</span> oP = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'p'</span>)    oP.innerHTML = i    fragEle.appendChild(oP)&#125;<span class="hljs-built_in">document</span>.body.appendChild(fragEle)</code></pre></div><p>早期批量操作dom的开销比较大，使用<code>Fragment</code>可以很好的降低开销，因为是先把文档操作放到虚拟的<code>Fragment</code>上再一次性插入到document，<code>Fragment</code>就相当于占位符，在插入之后本身就会销毁</p><p>现代浏览器已经对这类批量文档操作做了优化，实际的运行速度上使用文档碎片并不会有很大的优势了，但是从语义上讲文档碎片依然是很好的选择，因为它表明了不需要马上对页面dom进行更新操作</p><h3 id="7-使用克隆节点代替创造节点"><a href="#7-使用克隆节点代替创造节点" class="headerlink" title="7. 使用克隆节点代替创造节点"></a>7. 使用克隆节点代替创造节点</h3><p>当需要插入新节点时，另一个优化的方法是使用<code>cloneNode</code>函数，复制一个已有的同类节点再进行更改</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;    <span class="hljs-keyword">let</span> newP = oldP.cloneNode(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 参数表示是否进行深拷贝</span>    newP.innerHTML = i    <span class="hljs-built_in">document</span>.body.appendChild(newP)&#125;</code></pre></div><p><code>cloneNode</code>比使用<code>createElement</code>性能更好，尤其批量创造同类节点</p><h3 id="8-直接量替换new-Object"><a href="#8-直接量替换new-Object" class="headerlink" title="8. 直接量替换new Object"></a>8. 直接量替换new Object</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 使用new</span><span class="hljs-keyword">let</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>)a1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>a1[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>a1[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span><span class="hljs-comment">// 直接量</span><span class="hljs-keyword">let</span> a2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</code></pre></div><p>这个非常好理解，使用直接量的性能更好</p>]]></content>
    
    
    <categories>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES2015</title>
    <link href="/2020/June/Javascript-ES2015/"/>
    <url>/2020/June/Javascript-ES2015/</url>
    
    <content type="html"><![CDATA[<h1 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h1><h2 id="1-let和const的块作用域"><a href="#1-let和const的块作用域" class="headerlink" title="1. let和const的块作用域"></a>1. let和const的块作用域</h2><p>let和const的块级作用域是JS很大的一个进步，尤其是let在循环中的使用很有意思</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;      <span class="hljs-built_in">console</span>.log(i)    &#125;&#125;</code></pre></div><p>像上面那样在循坏的内外层使用同名变量i但却不会相互覆盖</p><p>同时我们也可以这样</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> elements = [&#123;&#125;, &#123;&#125;, &#123;&#125;]<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;elements.length;i++) &#123;  elements[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(i)  &#125;&#125;elements[<span class="hljs-number">0</span>].onclick() <span class="hljs-comment">// 0</span></code></pre></div><p>这里通过闭包每个i都被单独地记住了</p><p>另外一个值得注意的地方是</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;  <span class="hljs-keyword">let</span> i = <span class="hljs-string">'foo'</span>  <span class="hljs-built_in">console</span>.log(i)&#125; <span class="hljs-comment">// 输出三次foo</span></code></pre></div><p>这里循环逻辑内部的i也不受影响，我们可以这样来理解，上面的代码其实等同于：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-keyword">let</span> i = <span class="hljs-string">'foo'</span> <span class="hljs-comment">// 块作用域内部的i的独立的</span>  <span class="hljs-built_in">console</span>.log(i)&#125;i++<span class="hljs-comment">// 以上重复三次</span></code></pre></div><p>最后let和const都不会自动提升，必须声明后才能使用，否则抛出RefError</p><p>但要特别注意的是：<strong>所谓的不会提升(hoist)指的是初始化不会提升，而不是声明不会提升</strong></p><p>let和const的声明依然会被提升，这是Javascript的底层机制决定的，Javascript引擎会在进入每个作用域时寻找该作用域内部的所有变量声明并创建它们</p><p>唯一的区别就是，var还会执行初始化（undefined），而let和const不会，这就是为何在赋值前使用let和const会抛出异常的真正原因</p><p><a href="https://www.jianshu.com/p/0f49c88cf169" target="_blank" rel="noopener">参考资料: let存在变量提升吗？</a></p><h2 id="2-Proxy"><a href="#2-Proxy" class="headerlink" title="2. Proxy"></a>2. Proxy</h2><p>Proxy专门用于对对象进行代理操作，是比Object.defineProperty更灵活便捷的方法。Proxy内置了13个代理方法handler，又称为捕捉器，比如最常用的set和get</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;    name: <span class="hljs-string">'Tom'</span>,    age: <span class="hljs-number">20</span>&#125;<span class="hljs-keyword">const</span> personProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(person, &#123;    <span class="hljs-keyword">get</span>(target, property) &#123;        <span class="hljs-keyword">return</span> property <span class="hljs-keyword">in</span> target ? target[property] : <span class="hljs-string">'default'</span>    &#125;,    <span class="hljs-keyword">set</span>(target, property, value) &#123;      <span class="hljs-comment">// 捕捉set进来的属性和值，可以进行任意额外的操作</span>      <span class="hljs-keyword">if</span> (property === <span class="hljs-string">'age'</span>) &#123;          <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Number</span>.isInteger(value)) &#123;              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;value&#125;</span> is not an integer`</span>)          &#125;      &#125;      target[property] = value      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// set方法需要返回一个bool值表示是否成功</span>    &#125;&#125;)</code></pre></div><p>Proxy比Object.defineProperty更为强大，事实上Proxy本身就自带了一个defineProperty的捕捉器</p><p>更重要的，Proxy可以方便地劫持数组操作，这也是Vue3.0使用Proxy代替了defineProperty的原因之一</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> list = []<span class="hljs-keyword">const</span> listProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(list, &#123;  <span class="hljs-keyword">set</span>(target, property, value) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'set'</span>, property, value)    target[property] = value    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  &#125;&#125;)listProxy.push(<span class="hljs-number">100</span>)<span class="hljs-comment">// set 0 100</span><span class="hljs-comment">// set length 1</span></code></pre></div><p>第一行的0表示数组下标0， 第二行的length表示对数组长度的操作。可见Proxy自己内部知道数组是如何被操作的，不再需要我们进行干涉，这比defineProperty方便了很多</p><p>Proxy对于对象的劫持是非侵入性的，可以任意代理一个已经被定义好的对象和其中的变量，而defineProperty则是一开始就需要声明好</p><h2 id="3-Reflect"><a href="#3-Reflect" class="headerlink" title="3. Reflect"></a>3. Reflect</h2><p>Reflect本身提供了一整套对象操作的拦截函数，可以说和Proxy有点相辅相成的感觉(特别是两者的自带方法都是13个)</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;    name: <span class="hljs-string">'Tom'</span>,    age: <span class="hljs-number">20</span>&#125;<span class="hljs-keyword">const</span> personProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(person, &#123;    <span class="hljs-keyword">get</span>(target, property) &#123;      <span class="hljs-built_in">console</span>.log(target, property)      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, property)    &#125;&#125;)</code></pre></div><p>Reflect可以统一对象的操作方式。传统的JS里针对对象的操作种类繁多，而且语法差异很大，非常不规范，如下例</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;    name: <span class="hljs-string">'Tom'</span>,    age: <span class="hljs-number">20</span>&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'name'</span> <span class="hljs-keyword">in</span> person) <span class="hljs-comment">// 判断是否存在属性</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">delete</span> person[<span class="hljs-string">'age'</span>]) <span class="hljs-comment">// 删除特定的属性</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(person)) <span class="hljs-comment">// 获取所有属性名</span><span class="hljs-comment">// 使用Reflect统一操作</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.has(person, <span class="hljs-string">'name'</span>))<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.deleteProperty(person, <span class="hljs-string">'age'</span>))<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.ownKeys(person))</code></pre></div><h2 id="4-Set"><a href="#4-Set" class="headerlink" title="4. Set"></a>4. Set</h2><p>Set类似Python等语言中的集合，是数学概念集合的实现，最有用的地方就是去重</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()s.add(<span class="hljs-number">1</span>).add(<span class="hljs-number">2</span>).add(<span class="hljs-number">2</span>).add(<span class="hljs-number">3</span>)<span class="hljs-built_in">console</span>.log(s) <span class="hljs-comment">// Set &#123;1, 2, 3&#125;</span>s.forEach(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))<span class="hljs-comment">// 注意Set是一个对象，并没有索引，所以不能使用for in</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> s) &#123;  <span class="hljs-built_in">console</span>.log(s)&#125;<span class="hljs-built_in">console</span>.log(s.size) <span class="hljs-comment">// 获取大小</span><span class="hljs-built_in">console</span>.log(s.has(<span class="hljs-number">100</span>)) <span class="hljs-comment">// 是否具有某个元素</span><span class="hljs-built_in">console</span>.log(s.delete(<span class="hljs-number">3</span>)) <span class="hljs-comment">// 成功删除返回true，否则false</span><span class="hljs-built_in">console</span>.log(s.clear()) <span class="hljs-comment">// 清空集合</span><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]<span class="hljs-keyword">const</span> result = [ ... new <span class="hljs-built_in">Set</span>(arr)]<span class="hljs-built_in">console</span>.log(result)</code></pre></div><h2 id="5-Map"><a href="#5-Map" class="headerlink" title="5. Map"></a>5. Map</h2><p>即便有计算属性这个对象字面量的增强版，可以给对象添加动态的属性名，比如</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  [<span class="hljs-built_in">Math</span>.ramdom()] : <span class="hljs-number">10</span>,  [<span class="hljs-number">1</span> + <span class="hljs-number">1</span>] : <span class="hljs-number">20</span>&#125;</code></pre></div><p>这种机制仍然有一个很大的限制，就是无法使用对象作为变量名</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  [&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">2</span>&#125;] : <span class="hljs-number">10</span>,  [&#123;<span class="hljs-attr">b</span>: <span class="hljs-number">3</span>&#125;]: <span class="hljs-number">30</span>&#125;<span class="hljs-built_in">console</span>.log(obj) <span class="hljs-comment">// &#123; '[object Object]': 30 &#125;</span><span class="hljs-built_in">console</span>.log(obj[&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">2</span>&#125;]) <span class="hljs-comment">// 30 错误值</span></code></pre></div><p>可以看到两个属性名其实都被toString之后再当做属性名，导致彼此覆盖掉了，因为任何对象toString = <code>[object Object]</code>。也就是说，传统的JS里对象的属性名只能为字符串。</p><p>Map就可以解决这个问题</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<span class="hljs-keyword">const</span> tom = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">10</span>&#125;m.set(tom, <span class="hljs-number">10</span>)<span class="hljs-built_in">console</span>.log(m) <span class="hljs-comment">// Map &#123; &#123; a: 10 &#125; =&gt; 10 &#125;</span><span class="hljs-built_in">console</span>.log(m.get(tom)) <span class="hljs-comment">// 10 正确值</span><span class="hljs-comment">// 和Set一样具有常用的基本操作</span><span class="hljs-comment">// m.has()</span><span class="hljs-comment">// m.delete()</span><span class="hljs-comment">// m.clear()</span></code></pre></div><h2 id="6-Symbol"><a href="#6-Symbol" class="headerlink" title="6. Symbol"></a>6. Symbol</h2><p>Symbol是很有意思的一个数据类型，类似传统静态语言中常用的UID，专门用于生成一个不会重复的变量</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'Hi'</span>) <span class="hljs-comment">// 使用for来注册一个全局Symbol</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>.keyFor(x)) <span class="hljs-comment">// Hi</span></code></pre></div><p>如果不使用Symbol.for来注册，每次Symbol都会生成一个不同的新值</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'Hi'</span>)<span class="hljs-keyword">let</span> y = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'Hi'</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'x'</span>) === <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'x'</span>)) <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(x === y) <span class="hljs-comment">// true</span></code></pre></div><p>Symbol的特性可以用来创造对象内部的私有成员</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-built_in">Symbol</span>()<span class="hljs-keyword">const</span> person = &#123;  [name]: <span class="hljs-string">'Yikhan'</span>,  say() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>[name])  &#125;&#125;person.say() <span class="hljs-comment">// Yikhan</span></code></pre></div><p>进一步来说，因为这个功能Symbol也成为了JS的一些内置接口名称，比如<code>[Symbol.toStringTag]</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  [<span class="hljs-built_in">Symbol</span>.toStringTag]: <span class="hljs-string">'Awesome Name'</span>,  foo: <span class="hljs-number">10</span>&#125;<span class="hljs-built_in">console</span>.log(obj.toString()) <span class="hljs-comment">// [object Awesome Name]</span></code></pre></div><p>通过Symbol定义的属性，无论是使用for in还是<code>Object.keys()</code>，亦或是<code>JSON.stringify()</code>都是获取不到的，会直接被这些方法忽略掉</p><h2 id="7-Iterator"><a href="#7-Iterator" class="headerlink" title="7. Iterator"></a>7. Iterator</h2><p>迭代器接口直接和for of操作符相关，只有实现了这个接口才能调用for of来遍历元素</p><p>要注意的是for of不能直接遍历普通的Object，只能遍历<code>Object.values(obj)</code></p><p>迭代器接口的关键字就是在对象中实现<code>[Symbol.iterator]</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  store: [ <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'baz'</span> ],  [<span class="hljs-built_in">Symbol</span>.iterator]: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> &#123;      next: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> result = &#123;          value: <span class="hljs-keyword">this</span>.store[index],          done: index &gt;= <span class="hljs-keyword">this</span>.store.length        &#125;        index++        <span class="hljs-keyword">return</span> result      &#125;    &#125;  &#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> obj) &#123;  <span class="hljs-built_in">console</span>.log(item) <span class="hljs-comment">// foo bar baz</span>&#125;</code></pre></div><p>如果结合生成器generator，还可以进一步简化这个方法</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  store: [ <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'baz'</span> ],  [<span class="hljs-built_in">Symbol</span>.iterator]: <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.store) &#123;      <span class="hljs-keyword">yield</span> item    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise 异步操作的九阳神功</title>
    <link href="/2020/June/Javascript-promise/"/>
    <url>/2020/June/Javascript-promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise-异步操作的九阳神功"><a href="#Promise-异步操作的九阳神功" class="headerlink" title="Promise 异步操作的九阳神功"></a>Promise 异步操作的九阳神功</h1><h2 id="1-Promise中的值穿透"><a href="#1-Promise中的值穿透" class="headerlink" title="1. Promise中的值穿透"></a>1. Promise中的值穿透</h2><p>假如有下面这样的代码，结果会打印出什么呢？</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>).then(<span class="hljs-number">2</span>).then(<span class="hljs-built_in">console</span>.log)</code></pre></div><p>答案是1，这是因为如果<code>then</code>的参数不是一个函数，就会把上一层传入的值直接传递给下一层 (类似直接 <code>return this</code>)，这就是值穿透现象。</p><p>通过具体的代码实现，可以比较容易地理解：</p><div class="hljs"><pre><code class="hljs js">successCallback =  <span class="hljs-keyword">typeof</span> successCallback === <span class="hljs-string">'function'</span>    ? successCallback    : <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value <span class="hljs-comment">// 如果callback不是函数，则构造一个函数返回传入的值</span>failCallback =  <span class="hljs-keyword">typeof</span> failCallback === <span class="hljs-string">'function'</span>    ? failCallback    : <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> reason <span class="hljs-comment">// 如果callback不是函数，则构造一个函数返回传入的值</span></code></pre></div><h2 id="2-await的执行顺序"><a href="#2-await的执行顺序" class="headerlink" title="2. await的执行顺序"></a>2. await的执行顺序</h2><h3 id="2-1-理解await"><a href="#2-1-理解await" class="headerlink" title="2.1 理解await"></a>2.1 理解await</h3><p>在异步编程里面常见的知识点有两个，一个是微任务和宏任务的异步执行顺序，另一个就是以<code>Promise</code>为主的异步理解。其中个人觉得最容易被错误理解的不是<code>Promise</code>本身，而是<code>await</code>这个语法糖。众所周知，<code>await</code>关键字本质上还是生成器<code>generator</code>（而一个<code>async</code>函数默认会返回一个<code>Promise</code>）。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 start'</span>)&#125;<span class="hljs-keyword">let</span> r = fn1() <span class="hljs-comment">// fn1 start</span><span class="hljs-built_in">console</span>.log(r) <span class="hljs-comment">// Promise &#123; undefined &#125;</span></code></pre></div><p>如果没有<code>await</code>，在函数内部即使有异步操作也不会以异步的方式执行，<code>await</code>就好比<code>generator</code>中的<code>yield</code>关键字，我们下面用一个完整的例子来具体分析<code>await</code>。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 start'</span>)  fn2()  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 end'</span>)&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn2 start'</span>)  <span class="hljs-keyword">await</span> fn3()  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn2 end'</span>)&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn3</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn3 start'</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;fn1()<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'Promise'</span>).then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(value))<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>)</code></pre></div><p>当fn1当中不使用await时，执行顺序为：</p><div class="hljs"><pre><code class="hljs text">fn1 startfn2 startfn3 startfn1 endfinallyfn2 endPromise</code></pre></div><p>我们可以注意到fn1 end和fn2 end的输出区别，在fn2中由于使用了await，后面的log语句被放到了<code>Promise</code>中执行，也就是进入了异步队列，因此最后主程序的finally打印之后才打印fn2 end。</p><p>而fn1 end是直接打印的，这正是因为我们没有在fn1中使用<code>await</code>，所以fn2()后面的log是以同步的方式运行的。理解了这一点之后，我们可以很容易发现<code>await</code>其实就是<code>Promise.resolve</code>，两者在语义上是一致的，任何在<code>await</code>之后的代码都会被放到<code>Promise</code>中，在<code>then</code>里面才会运行。</p><p><a href="https://www.zhihu.com/question/268007969" target="_blank" rel="noopener"><strong>值得注意的是，关于await具体的实现V8引擎也几经更改，可参考这个知乎回答</strong></a></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 start'</span>)  <span class="hljs-keyword">await</span> fn2()  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 end'</span>)&#125;<span class="hljs-comment">// 等价于（注意仅仅是语义上等价，await并不是用Promise.resolve来实现的！）</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 start'</span>)  <span class="hljs-built_in">Promise</span>.resolve(fn2())    .then(<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 end'</span>))&#125;</code></pre></div><p>当我们把<code>await</code>和<code>Promise.resolve</code>联系起来之后，就会很容易理解一个面试题的常考点，就是<code>await</code>同一行的函数会被立即执行，之后的代码才会被放到<code>then</code>里面，所以fn2 start和fn3 start都是马上就打印出来了。</p><p>如果我们在<code>fn2()</code>前面加个<code>await</code>的话，打印顺序就不一样了：</p><div class="hljs"><pre><code class="hljs text">fn1 startfn2 startfn3 startfinallyfn2 endPromisefn1 end</code></pre></div><p>可以发现fn1 end现在最后才会打印，甚至晚于fn2 end。这是也因为<code>await</code>同一行的函数会被立即执行，就好比<code>Promise.resolve(fn2())</code>里的fn2是马上执行的，其返回值就是resolve出去的对象一样。</p><p>当执行fn2时，fn2内部也有一个<code>await</code>，所以fn3被马上执行，而后面的打印函数被放入了<code>then</code>里面，所以这里fn2中先产生了<code>Promise</code>，率先进入异步队列。而当执行栈再次回到fn1之后，才把fn1后面的log放入<code>then</code>，要晚于fn2。</p><p>最后为什么fn1 end要晚于Promise打印？因为fn2由于内部有<code>await</code>还没有执行完，主线程回到fn1的时候<code>await fn2()</code>产生的<code>Promise</code>还没能resolve，所以并不会把后面的代码放入异步队列（具体会在第4节的<code>Promise</code>源码部分），然后主线程继续执行后面的同步代码，于是Promise的打打印先进入异步队列。</p><h3 id="2-2-await和Promise-resolve的区别"><a href="#2-2-await和Promise-resolve的区别" class="headerlink" title="2.2 await和Promise.resolve的区别"></a>2.2 await和Promise.resolve的区别</h3><p>上一节我们提到了<code>await</code>和<code>Promise.resolve</code>在语义上的相似之处，但是也强调了两者并不完全等同，最重要的区别是由于<code>await</code>本质上是生成器，所以可以真正做到“暂停”程序，而<code>Promise.resolve</code>则没有这个能力。</p><p>来看一个例子：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 start'</span>)  <span class="hljs-built_in">Promise</span>.resolve(fn2()).then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(value)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 end'</span>)  &#125;)&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn2 start'</span>)  <span class="hljs-built_in">Promise</span>.resolve(fn3()).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn2 end'</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>  &#125;)&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn3</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn3 start'</span>)&#125;fn1()<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'Promise'</span>).then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(value))<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>)</code></pre></div><p>这个例子和2.1中的例题基本一样，区别在于我们不使用<code>await</code>而是用<code>Promise.resolve</code>代替，来看看结果：</p><div class="hljs"><pre><code class="hljs text">fn1 startfn2 startfn3 startfinallyfn2 endundefinedfn1 endPromise</code></pre></div><p>这里可以发现顺序和2.1有所出入</p><ol><li>首先fn1 end先于Promise打印，也就是说其实fn1并没有真正“等待”fn2执行完毕就已经把后面的then放入异步队列了。</li><li>fn1中打印的fn2的返回值是<code>undefined</code>，从侧面佐证了fn1没有真正“等待”fn2，否则返回值应该是2</li></ol><p>所以可以发现<code>Promise.resolve</code>并没有“暂停”代码执行的能力，一个函数内部如果有<code>Promise.resolve</code>也无法真正做到“延迟”返回，只不过是把返回放到了异步队列里，对于接受返回值的调用者来说返回仍然是同步代码决定的，而因为同步代码部分没有定义返回值，所以默认返回<code>undefined</code>，fn2就是这样的一个例子。</p><p>所以对于fn1中的<code>Promise.resolve(fn2())</code>而言，fn2的返回值仅仅取决于它的同步代码，<code>Promise.resolve</code>不会去等待fn2中的异步任务。</p><p>我们再把fn2用<code>await</code>改写一下，结果就会迥然不同：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn2 start'</span>)  <span class="hljs-comment">// Promise.resolve(fn3()).then(() =&gt; &#123;</span>  <span class="hljs-comment">//   console.log('fn2 end')</span>  <span class="hljs-comment">//   return 2</span>  <span class="hljs-comment">// &#125;)</span>  <span class="hljs-keyword">await</span> fn3()  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>&#125;</code></pre></div><p>现在的结果是：</p><div class="hljs"><pre><code class="hljs text">fn1 startfn2 startfn3 startfinallyPromise2fn1 end</code></pre></div><p><code>await</code>背后的生成器可以真正做到“暂停”代码。</p><p>我们知道<code>async</code>函数返回的是一个<code>Promise</code>，所以<code>Promise.resolve(fn2())</code>里面fn2本身返回了一个<code>Promise</code>，如果这个<code>Promise</code>状态是fulfilled了才会把后续的<code>then</code>放入异步队列，而这时由于fn2中使用了<code>await</code>，fn2在运行完之前这个返回的<code>Promise</code>一直是pending状态，所以<code>Promise.resolve(fn2())</code>后面的<code>then</code>无法马上进入异步队列，只能等待fn2继续执行完<code>await</code>之后的所有代码。</p><p>这也是<code>await</code>强大的地方，因为它从真正意义上做到了“等待异步执行”，而不是仅仅把后续代码放入异步队列而已！这个区别非常重要。</p><p>最后值得一提的是，<code>Promise.resolve</code>有一个特性，如果resolve的值本来就是一个<code>Promise</code>，就会直接返回这个<code>Promise</code>而不是新生成一个。</p><h2 id="3-深入理解then"><a href="#3-深入理解then" class="headerlink" title="3. 深入理解then"></a>3. 深入理解then</h2><p>下面我们来看更复杂一些的例子</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'外部promise'</span>)  resolve()&#125;)  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'外部第一个then'</span>)    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'内部promise'</span>)      resolve()    &#125;)      .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'内部第一个then'</span>)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve()      &#125;)      .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'内部第二个then'</span>)      &#125;)  &#125;)  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'外部第二个then'</span>)  &#125;)  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'外部第三个then'</span>)  &#125;)  .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'外部第四个then'</span>)  &#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'外部结束'</span>)</code></pre></div><p>我们知道<code>then</code>方法里面的回调函数会被放入微任务队列，当主线任务执行完毕后下一次事件轮询才会执行，大多数人在没有真正从源码层面理解的情况下，对<code>then</code>的认知就止步于此了，于是上面这道题目马上就会掉坑。</p><p>这道题目的正确答案（以chrome浏览器运行环境为准）</p><div class="hljs"><pre><code class="hljs text">外部promise外部结束外部第一个then内部promise内部第一个then外部第二个then外部第三个then外部第四个then内部第二个then</code></pre></div><p>诡异的地方来了，内层的第二个<code>then</code>居然是最后才执行的！</p><p>我们来分析一下代码的运行过程：</p><ol><li><p>第一个<code>Promise</code>内部打印 <code>外部promise</code>并直接调用<code>resolve()</code>（这里要注意的一点就是<code>Promise</code>构造时传入的函数是同步执行的），状态变成fulfilled，外层的第一个<code>then</code>被放入微任务队列，外层的其余<code>then</code>都要等待第一个<code>then</code>完成后才会被执行，所以不用考虑。然后主任务直接执行到剩下的最后一行，打印<code>外部结束</code>。</p><ul><li>此时微任务队列<code>[外部第一个then]</code></li></ul></li><li><p>由于主任务没有代码要执行了，微任务队列的第一个任务进栈处理，外部第一个<code>then</code>执行，内部又声明了一个<code>Promise</code>，并执行里面的函数，打印<code>内部promise</code>，然后这个<code>Promise</code>也直接被resolve了，内部的第一个<code>then</code>进入微任务队列，内部第二个<code>then</code>要等待内部第一个<code>then</code>执行结束，暂时不会进入微任务队列。</p><p>此时外部第一个<code>then</code>的同步代码部分就执行结束了，由于它没有定义返回值，相当于就是返回了一个<code>undefined</code>，这个值就会被作为这个<code>Promise</code>的返回值被resolve（这个部分在下面的源码部分我们详细来看），于是外部第二个<code>then</code>也被放入微任务队列。</p><ul><li>此时微任务队列<code>[内部第一个then，外部第二个then]</code></li></ul></li><li><p>主任务清空，开始执行微任务队列，先取出内部第一个<code>then</code>处理，它的回调函数直接返回了一个 <code>Promise.resolve()</code>，也就是一个处于fulfilled状态的<code>Promise</code>。接下来就是真正考察功力的时候了，我们需要思考的问题是<code>Promise</code>在resolve一个普通值和一个<code>Promise</code>的时候，有什么差别呢？这里面的差别非常大，如果resolve的是普通值，直接就会注册后面的<code>then</code>方法，也就是把<code>then</code>当中的回调函数放入微任务队列。而当resolve的对象也是一个<code>Promise</code>的时候，并不会直接返回这个<code>Promise</code>，而是会返回一个<code>NewPromiseResolveThenableJob</code>，这是ECMA-262标准里规定的，这个Job内部会去执行要返回<code>Promise</code>的<code>then</code>方法，同时这个Job本身会被放入到微任务队列里。</p><p>这里的细节一下子多了很多，我们分别列举出来一个个看：</p><ol><li>如果<code>Promise1</code>要返回一个<code>Promise2</code>（也可以理解成<code>Promise2</code>会resolve<code>Promise1</code>，即把<code>Promise1</code>的状态变成fulfilled），会生成一个<code>NewPromiseResolveThenableJob</code>放入微任务队列。</li><li>这个Job里会调用<code>Promise2.then(resolve, reject)</code>，要注意这里传入的<code>resolve</code>和<code>reject</code>是<code>Promise1</code>自己的！它们处理的是<code>Promise1</code>，也就是说<code>Promise2.then</code>里面的执行结果会决定<code>Promise1</code>的状态。</li><li>等到这个Job被执行了，<code>Promise2.then</code>的回调被放入微任务。</li><li>等到<code>Promise2.then</code>的回调被执行了，<code>Promise1</code>终于状态改变，它自己的<code>then</code>才能开始被处理。</li><li>从1-4，一共经过了3次事件轮询！所以当<code>then</code>返回一个<code>Promise</code>的时候，后面的链式<code>then</code>并不会马上被放入微任务，第一次放入的是<code>NewPromiseResolveThenableJob</code>，第二次放入的是<code>Promise2.then</code>，第三次才是链式的<code>then</code>。</li></ol><p>回到3我们刚刚讨论到的地方：</p><ul><li>回到此时微任务队列<code>[外部第二个then，NewPromiseResolveThenableJob]</code></li></ul></li><li><p>执行外部第二个<code>then</code>，打印<code>外部第二个then</code>。这个<code>then</code>没有返回值也没有异步代码，所以直接返回<code>undefined</code>，和2里面我们讨论过的一样，外部第三个<code>then</code>顺利被放入微任务队列。</p><ul><li><code>[NewPromiseResolveThenableJob，外部第三个then]</code></li></ul></li><li><p>执行<code>NewPromiseResolveThenableJob</code>，把<code>Promise.resolve().then</code>放入微任务队列。</p><ul><li>此时微任务队列<code>[外部第三个then，Promise.resolve().then]</code></li></ul></li><li><p>执行外部第三个<code>then</code>，打印<code>外部第三个then</code>，把外部第四个<code>then</code>放入微任务队列。</p><ul><li>此时微任务队列<code>[Promise.resolve().then，外部第四个then]</code></li></ul></li><li><p>执行<code>Promise.resolve().then</code>，没有任何返回值（<code>undefined</code>），但是把内部第一个<code>then</code>返回的<code>Promise</code>状态变为fulfilled，相当于内部第一个<code>then</code>最后返回了<code>undefined</code>，这时把内部第二个<code>then</code>放入微任务队列。</p><ul><li>此时微任务队列<code>[外部第四个then，内部第二then]</code></li></ul></li><li><p>后面就很好理解了，依次执行剩下的两个<code>then</code>，分别打印<code>外部第四个then</code>和<code>内部第二个then</code>。</p></li></ol><h2 id="4-Promise源码理解"><a href="#4-Promise源码理解" class="headerlink" title="4. Promise源码理解"></a>4. Promise源码理解</h2><p>我们来看下模拟部分Promise源码的简单实现</p><div class="hljs"><pre><code class="hljs js">then (successCallback, failCallback) &#123;  <span class="hljs-comment">// 判断传入的回调是不是函数</span>  successCallback =    <span class="hljs-keyword">typeof</span> successCallback === <span class="hljs-string">'function'</span> ? successCallback : <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value  failCallback =    <span class="hljs-keyword">typeof</span> failCallback === <span class="hljs-string">'function'</span> ? failCallback : <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> reason  <span class="hljs-keyword">let</span> promiseReturned = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-comment">// 判断状态，如果已经变化了就立即调用回调函数</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === FULFILLED) &#123;      setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">let</span> x = successCallback(<span class="hljs-keyword">this</span>.value)          <span class="hljs-comment">// 检查x是否是也是一个MyPromise对象</span>          resolvePromise(promiseReturned, x, resolve, reject)        &#125; <span class="hljs-keyword">catch</span> (error) &#123;          reject(error)        &#125;      &#125;, <span class="hljs-number">0</span>)    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === REJECTED) &#123;      setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">let</span> x = failCallback(<span class="hljs-keyword">this</span>.reason)          <span class="hljs-comment">// 检查x是否是也是一个MyPromise对象</span>          resolvePromise(promiseReturned, x, resolve, reject)        &#125; <span class="hljs-keyword">catch</span> (error) &#123;          reject(error)        &#125;      &#125;, <span class="hljs-number">0</span>)    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 等待，状态还没有变化</span>      <span class="hljs-comment">// 将成功和失败的回调函数储存起来</span>      <span class="hljs-keyword">this</span>.successCallback.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;          <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">let</span> x = successCallback(<span class="hljs-keyword">this</span>.value)            <span class="hljs-comment">// 检查x是否是也是一个MyPromise对象</span>            resolvePromise(promiseReturned, x, resolve, reject)          &#125; <span class="hljs-keyword">catch</span> (error) &#123;            reject(error)          &#125;        &#125;, <span class="hljs-number">0</span>)      &#125;)      <span class="hljs-keyword">this</span>.failCallback.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;          <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">let</span> x = failCallback(<span class="hljs-keyword">this</span>.reason)            <span class="hljs-comment">// 检查x是否是也是一个MyPromise对象</span>            resolvePromise(promiseReturned, x, resolve, reject)          &#125; <span class="hljs-keyword">catch</span> (error) &#123;            reject(error)          &#125;        &#125;, <span class="hljs-number">0</span>)      &#125;)    &#125;  &#125;)  <span class="hljs-keyword">return</span> promiseReturned&#125;</code></pre></div><p>从上面的代码中可以明显的看到几个特点：</p><p>一是果然所有的<code>then</code>都会在内部声明并返回一个<code>Promise</code>： <code>promiseReturned</code></p><p>二是<code>then</code>是如何把回调函数放入异步队列的（代码里使用了<code>setTimeout</code>来模拟），包括如果当前<code>Promise</code>还处于pending状态时，会把回调函数包裹在一个异步任务里再放入数组中保存。</p><p>三是回调函数的返回值就是<code>Promise</code>要resolve的值，也就是<code>x</code>，但是具体怎么resolve或者reject还要经过一个函数<code>resolvePromise</code>。</p><p>首先我们先看看<code>resolve</code>函数是怎么工作的（要注意这里的<code>resolve</code>方法不是<code>Promise.resolve</code>！后者是一个独立的静态方法，这里没有讨论）：</p><div class="hljs"><pre><code class="hljs js">resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status != PENDING) <span class="hljs-keyword">return</span>  <span class="hljs-keyword">this</span>.status = FULFILLED  <span class="hljs-keyword">this</span>.value = value  <span class="hljs-comment">// 判断成功回调是否存在，如果存在就调用</span>  <span class="hljs-comment">// this.successCallback &amp;&amp; this.successCallback(this.value)</span>  <span class="hljs-comment">// 现在回调函数是一个数组</span>  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.successCallback.length) &#123;    <span class="hljs-keyword">let</span> callback = <span class="hljs-keyword">this</span>.successCallback.shift()    callback()  &#125;&#125;</code></pre></div><p>当调用<code>resolve</code>的时候，不仅会改变<code>Promise</code>的状态，同时也会把数组中保存的回调任务按顺序全部执行了，<code>reject</code>函数的原理完全一样。</p><p>最后我们再来看看<code>resolvePromise</code>和<code>resolve</code>有什么不同：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span> (<span class="hljs-params">promiseReturned, x, resolve, reject</span>) </span>&#123;  <span class="hljs-comment">//! 不允许返回自身 会造成无限then嵌套</span>  <span class="hljs-keyword">if</span> (promiseReturned === x) &#123;    reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'Chaining cycle detected for promise'</span>))  &#125;  <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> MyPromise) &#123;    <span class="hljs-comment">// 是一个 MyPromise对象</span>    <span class="hljs-comment">// 这里模拟了ECMA标准里的NewPromiseResolveThenableJob(promiseToResolve, thenable, then)</span>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      x.then(resolve, reject)    &#125;, <span class="hljs-number">0</span>)  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 普通值</span>    resolve(x)  &#125;&#125;</code></pre></div><p>可以看到，<code>resolvePromise</code>相当于包裹了<code>resolve</code>，只不过处理了返回值的各种情况，而且要注意其参数设计别有用意：</p><ul><li><code>promiseReturned</code>： 当前<code>then</code>要返回的<code>Promise</code>（还记得吗，所有的<code>then</code>默认都返回一个<code>Promise</code>）</li><li><code>x</code>：当前<code>then</code>内部回调函数的返回值，用于resolve当前这个<code>promiseReturned</code></li><li><code>resolve</code>：<code>resolvePromise</code>自己的resolve方法</li><li><code>reject</code>：<code>resolvePromise</code>自己的reject方法</li></ul><p>当返回值是一个普通值的时候，直接调用<code>resolve</code>；而如果也是一个<code>Promise</code>，就会出现我们之前分析的那种情况，构造一个新的异步任务，在这个里任务里面去调用x的<code>then</code>方法，在这个<code>then</code>方法里再去调用传入的<code>resolve</code>和<code>reject</code>，也就是说<code>x</code>会决定<code>promiseReturned</code>的状态，但不是这一时刻同步决定的，而是下一次异步轮询。</p><p>最后还有一点是，由于<code>resolve</code>和<code>reject</code>函数被这么传来传去，所以为了保持它们内部的<code>this</code>指向，必须要通过箭头函数的方法来定义，否则还得各种使用闭包去记录原本的<code>this</code>。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>最后我们再来稍微改造一下2里面的例子，把fn3改为：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn3</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn3 start'</span>)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve()&#125;</code></pre></div><p>现在运行的结果是什么样的呢？我们现在已经知道了<code>Promise</code>内部如果resolve另一个<code>Promise</code>要花费三个微任务才能真正完成，所以最后的打印结果：</p><div class="hljs"><pre><code class="hljs text">fn1 startfn2 startfn3 startfinallyPromisefn2 endfn1 end</code></pre></div><p>外部的Promise打印会最先进入异步队列，fn2和fn1变得更晚了。</p><p>经此一役，相信你对<code>Promise</code>的理解已经远超凡人，不会再有什么题目能轻易难道你了！</p>]]></content>
    
    
    <categories>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数式编程</title>
    <link href="/2020/June/Javascript-exp/"/>
    <url>/2020/June/Javascript-exp/</url>
    
    <content type="html"><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="1-柯里化"><a href="#1-柯里化" class="headerlink" title="1. 柯里化"></a>1. 柯里化</h2><p>函数式编程的基础，使用了高阶函数的思想，利用闭包把接受多个参数的函数封装成单参数函数，配合组合使用函数compose构成了函数式编程的重点技术</p><p>如何实现curry</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curriedFunc</span>(<span class="hljs-params">...args</span>) </span>&#123;    <span class="hljs-comment">//* 使用fn.length获得fn定义时的参数数量，fn通过闭包被缓存</span>    <span class="hljs-keyword">if</span> (args.length &lt; fn.length) &#123;      <span class="hljs-comment">//* 参数数量不够，应该返回柯里化后的函数</span>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...localArgs</span>) </span>&#123;        <span class="hljs-comment">//* 继续递归返回</span>        <span class="hljs-comment">//* 把上一层递归的args和这个函数会接收到的参数合并</span>        <span class="hljs-keyword">return</span> curriedFunc(...args.concat([ ...localArgs ]))      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//* 参数数量够了，可以运行fn了</span>      <span class="hljs-keyword">return</span> fn(...args)    &#125;  &#125;&#125;</code></pre></div><h2 id="2-组合函数"><a href="#2-组合函数" class="headerlink" title="2. 组合函数"></a>2. 组合函数</h2><p>把一组需要组合的函数按照从右到左的顺序依次执行，注意要组合的函数必须都是单参数函数，也就是一元函数，所以常常需要和curry化配合使用</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//* 组合函数原理模拟</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params">...funcs</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;    <span class="hljs-keyword">return</span> funcs.reduceRight(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">acc, func</span>) </span>&#123;      <span class="hljs-keyword">return</span> func(acc)    &#125;, value)  &#125;&#125;<span class="hljs-keyword">const</span> reverse = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> arr.reverse()<span class="hljs-keyword">const</span> first = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> arr[<span class="hljs-number">0</span>]<span class="hljs-keyword">const</span> toUpperCase = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> str.toUpperCase()<span class="hljs-keyword">const</span> f = compose(toUpperCase, first, reverse)<span class="hljs-built_in">console</span>.log(f([ <span class="hljs-string">'ant'</span>, <span class="hljs-string">'bat'</span>, <span class="hljs-string">'cab'</span> ])) <span class="hljs-comment">// C B A</span></code></pre></div><h2 id="3-Point-free"><a href="#3-Point-free" class="headerlink" title="3. Point-free"></a>3. Point-free</h2><p>在组合函数的基础上，为了使函数更方便组合，可以约定让函数的第一个参数接受方法，第二个参数接受数据，这种方法优先的模式使得组合函数非常简单直接</p><p>当我们组合一系列的函数时，我们实际上就是在按一定的步骤组合方法，并没有提及数据，这和传统的过程式编程完全不同，也是函数式编程个人觉得最有魅力的地方，其简洁和老程序猿嗤之以鼻的面条代码刚好是两个极端</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 可以很直观地知道我们先要执行的步骤，而完全没有提及变量或者数据本身</span><span class="hljs-keyword">const</span> firstLetterToUpper = fp.flowRight(  fp.join(<span class="hljs-string">'. '</span>),  fp.map(fp.flowRight(fp.toUpper, fp.first())),  fp.split(<span class="hljs-string">' '</span>))</code></pre></div><p>lodash/fp这个库里实现了lodash里功能函数的Point-free版本(所以专门放在了fp这个模块下)</p><h2 id="4-函子Functor"><a href="#4-函子Functor" class="headerlink" title="4. 函子Functor"></a>4. 函子Functor</h2><h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>函子是我以前比较陌生的概念，基本从未看到其真正的使用</p><p>函子的本质类似面向对象里面的私有变量封装，传统的函数式编程要求函数为纯函数(Pure Function)，也就是没有任何副作用的函数</p><blockquote><p>副作用：函数执行时不引起其他变量的变化，函数没有中间中间状态</p></blockquote><p>在实际应用中，除了功能单一的功能性函数，大部分业务函数都不是纯函数，副作用无可避免，所以函子的概念应运而生</p><p>函子把要被改变的变量和改变它的方法封装为一个class，和面向对象不同的是，这个改变它的方法并不是一个确定的函数，而是从外部传入一个函数</p><p>同时每次操作都会返回一个新的函子，这样就可以进行链式操作</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//* SECTION 容器 - 用于封装会被改变的值，以及改变它的方法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(value) &#123;    <span class="hljs-keyword">this</span>._value = value  &#125;  <span class="hljs-comment">//* 使用静态函数封装构造函数，这样外面调用的时候就不需要使用new</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span>(value) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Container(value)  &#125;  <span class="hljs-comment">//* map封装了任何试图改动_value的行为，并且总是返回一个新的容器</span>  map(fn) &#123;    <span class="hljs-keyword">return</span> Container.of(fn(<span class="hljs-keyword">this</span>._value))  &#125;&#125;<span class="hljs-comment">//* !SECTION</span><span class="hljs-comment">//* 测试 基本的函子</span><span class="hljs-keyword">let</span> r = Container.of(<span class="hljs-number">5</span>) <span class="hljs-comment">// 初始化</span>  .map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x + <span class="hljs-number">1</span>) <span class="hljs-comment">// map会返回一个新的容器，所以可以链式调用</span>  .map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x * x) <span class="hljs-comment">// 结果应该是36</span></code></pre></div><h3 id="4-2-Maybe函子"><a href="#4-2-Maybe函子" class="headerlink" title="4.2 Maybe函子"></a>4.2 Maybe函子</h3><p>基本的函子里面没有判断value和传入的修改方法是否兼容，所以我们可以在容器内加入判断，比如value为空值的时候直接返回一个新函子(value值还是原来的)，并不进行计算</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MayBe</span> </span>&#123;  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span>(value) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MayBe(value)  &#125;  <span class="hljs-keyword">constructor</span>(value) &#123;    <span class="hljs-keyword">this</span>._value = value  &#125;  <span class="hljs-comment">// 如果对空值变形的话直接返回 值为 null 的函子</span>  map(fn) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNothing() ? MayBe.of(<span class="hljs-literal">null</span>) : MayBe.of(fn(<span class="hljs-keyword">this</span>._value))  &#125;  isNothing() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._value === <span class="hljs-literal">null</span> || <span class="hljs-keyword">this</span>._value === <span class="hljs-literal">undefined</span>  &#125;&#125;<span class="hljs-comment">// 传入具体值</span>MayBe.of(<span class="hljs-string">'Hello World'</span>).map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.toUpperCase())<span class="hljs-comment">// 传入 null 的情况</span>MayBe.of(<span class="hljs-literal">null</span>).map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.toUpperCase())<span class="hljs-comment">// =&gt; MayBe &#123; _value: null &#125;</span></code></pre></div><h3 id="4-3-其他函子"><a href="#4-3-其他函子" class="headerlink" title="4.3 其他函子"></a>4.3 其他函子</h3><p>常用的函子还有Either函子，IO函子，Task函子等</p><p>尤其是Task函子也是一种异步机制，具体可参考folktale函数式编程库</p><p><a href="https://folktale.origamitower.com/" target="_blank" rel="noopener">folktale</a></p><h2 id="5-一些题目"><a href="#5-一些题目" class="headerlink" title="5. 一些题目"></a>5. 一些题目</h2><h3 id="5-1-map函数和parseInt之间的故事"><a href="#5-1-map函数和parseInt之间的故事" class="headerlink" title="5.1 map函数和parseInt之间的故事"></a>5.1 map函数和parseInt之间的故事</h3><p>这也是一道经典的题目了</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">'23'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'10'</span>]<span class="hljs-built_in">console</span>.log(array.map(<span class="hljs-built_in">parseInt</span>))<span class="hljs-comment">//! 结果是[ 23, NaN, 2 ]</span></code></pre></div><p>这是因为map函数在传递形参时，一共会传递三个参数 <code>callback(currentValue[, index[, array]])</code> 第二个是索引，第三个是数组本身<br>而parseInt其实可以接受两个参数string, radix，第二个radix表示进制，取值范围是2-36。</p><p>有意思的地方来了，radix大部分时候都没有人用，一般都会被留空，而当radix为 <code>0, undefined, null</code> 时，并不是默认以10进制来解析的：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt#%E6%8F%8F%E8%BF%B0" target="_blank" rel="noopener">根据MDN的资料</a></p><ul><li><p>如果输入的 string以 “0x”或 “0x”（一个0，后面是小写或大写的X）开头，那么radix被假定为16，字符串的其余部分被解析为十六进制数。</p></li><li><p>如果输入的 string以 “0”（0）开头， radix被假定为8（八进制）或10（十进制）。具体选择哪一个radix取决于实现。ECMAScript 5 澄清了应该使用 10 (十进制)，但不是所有的浏览器都支持。因此，在使用 parseInt 时，一定要指定一个 radix。</p></li><li><p>如果输入的 string 以任何其他值开头， radix 是 10 (十进制)。</p></li></ul><p>所以上面的例子，其真实的执行情况是：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'23'</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// parseInt没有第三个参数，所以map传递进来第三个参数array可以被忽略</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'8'</span>, <span class="hljs-number">1</span>)<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'10'</span>, <span class="hljs-number">2</span>)</code></pre></div><p>第一个23是字符串，且不是以0x开头的特殊情况，所以使用默认10进制解析，答案为23<br>第二个因为parseInt的radix取值是2-36，1是非法值，所以结果为NaN<br>第三个10是字符串，以2进制解析，答案是2</p><p>这里的细节确实是普通程序猿绝对不会留意到的，这个题目出的的确刁钻</p>]]></content>
    
    
    <categories>
      
      <category>前端学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建总结</title>
    <link href="/2020/June/blog-build/"/>
    <url>/2020/June/blog-build/</url>
    
    <content type="html"><![CDATA[<p>折腾了一番，博客顺利搭建完毕。不得不说到了2020年的今天Hexo确实很强大了，以往个人博客比较难配置的一些站长功能都已经有了现成的集成，特别是主流的几个Theme模版都囊括了常用的几乎所有博客功能，只要自己愿意玩玩技术，不需要多少编程能力就能独立搭好不弱于任何主流社区的个人博客了，巴适得很。</p><p>总结一下几个比较容易踩坑的地方：</p><h3 id="git-repo-嵌套问题"><a href="#git-repo-嵌套问题" class="headerlink" title="git repo 嵌套问题"></a>git repo 嵌套问题</h3><p>推荐直接下载主题到本地，解压放到theme目录下，不要使用submodule，就不用折腾了……</p><p>这个问题应该所有想用git管理博客的blogger都会遇到，而且如果不擅长查资料的话会非常坑，因为官方基本没怎么提这个问题。</p><p>当我们搭建博客项目的时候，一般博客本身就是一个repo，而Hexo会把你下载的主题放在themes这个子文件中，如果你是用 git clone 来下载的话，就会发现当你试图build博客的时候，本地运行一切正常，但一旦你deploy到Github Pages就会收到下面的邮件：</p><blockquote><p>You are attempting to use a Jekyll theme, which is not supported by GitHub Pages. Please visit <a href="https://pages.github.com/themes/" target="_blank" rel="noopener">https://pages.github.com/themes/</a> for a list of supported themes. If you are using the “theme” configuration variable for something other than a Jekyll theme, we recommend you rename this variable throughout your site. For more information, see <a href="https://help.github.com/en/articles/adding-a-jekyll-theme-to-your-github-pages-site." target="_blank" rel="noopener">https://help.github.com/en/articles/adding-a-jekyll-theme-to-your-github-pages-site.</a></p></blockquote><p>这个问题乍一看好像是Github不识别Jekyll主题，但很明显我们用的是Hexo而不是Jekyll模版，如果你直接搜索这些关键词会找到很多几年前很类似的问题。当时Github会默认使用Jekyll去解析网页项目，所以需要在项目里放一个空的 .nojekyll 文件来让Github知道不需要进行解析，但这个问题已经被解决了。</p><p>真正导致这一问题的关键在于repo的嵌套导致的deploy失败，由于你clone的主题本身就是一个repo，而你的博客项目是另外一个repo，两个repo有了嵌套关系就会导致Github不知道如何处理deploy上来的文件。</p><p>所以要用 git submodule 来导入主题，而不是 git clone</p><div class="hljs"><pre><code class="hljs bash">git submodule add https://github.com/geektutu/hexo-theme-geektutu.git themes/geektutu</code></pre></div><p>这样theme模版项目作为一个子模块加载到博客项目里面来，层次逻辑就不会混乱了。</p><p>当你要更新模版时也很简单：</p><div class="hljs"><pre><code class="hljs bash">git submodule upate</code></pre></div><h3 id="css等资源加载失败"><a href="#css等资源加载失败" class="headerlink" title="css等资源加载失败"></a>css等资源加载失败</h3><p>deploy成功之后可能还会发现下面的情况：</p><p><img src="https://raw.githubusercontent.com/Yikhan/ImageHost/master/blog/1564116640441.png" srcset="/img/loading.gif" alt="css error"></p><p>css和js等资源文件统统加载失败，博客只有内容而没有样式。</p><p>404问题一般都是由于访问路径错误导致的，可以看一下这些文件是在访问什么路径的时候失败的，比如:</p><div class="hljs"><pre><code class="hljs bash">正确的:yourname.github.io/blog/css/1.css实际访问:yourname.github.io/css/1.css</code></pre></div><p>其实Hexo文档里面已经提示过你了：</p><blockquote><p>If your site is put in a subdirectory, set url as ‘<a href="http://yoursite.com/child&#39;">http://yoursite.com/child&#39;</a> and root as ‘/child/‘</p></blockquote><p>当你的博客网址不是第一路径时（就是网址中带有/，有/就表示你的博客在一个子路径里面），你要密切注意子路径的配置方式。很多人的博客项目实际网址是 yourname.github.io/blog/ 这样的形式，这时候你就必须要在 _config.yml 文件里面严格按照下面的方式来配置:</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">url:</span> <span class="hljs-string">https://yourname.github.io/blog/</span><span class="hljs-attr">root:</span> <span class="hljs-string">/blog/</span></code></pre></div><p>这是我在搭建博客时候碰到的两个坑，总结一下方便其他朋友绕坑。</p><h3 id="如何删除submodule"><a href="#如何删除submodule" class="headerlink" title="如何删除submodule"></a>如何删除submodule</h3><p>如果想停止使用submodule的方式引入主题，可以使用下面的命令：</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># Remove the submodule entry from .git/config</span>git submodule deinit -f path/to/submodule<span class="hljs-comment"># Remove the submodule directory from the superproject's .git/modules directory</span>rm -rf .git/modules/path/to/submodule<span class="hljs-comment"># Remove the entry in .gitmodules and remove the submodule directory located at path/to/submodule</span>git rm -f path/to/submodule</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
