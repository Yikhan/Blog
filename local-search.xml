<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端学习笔记 (chap.2) - Javascript性能优化</title>
    <link href="/2020/June/Javascript-performance/"/>
    <url>/2020/June/Javascript-performance/</url>
    
    <content type="html"><![CDATA[<h1 id="Javascript性能优化"><a href="#Javascript性能优化" class="headerlink" title="Javascript性能优化"></a>Javascript性能优化</h1><h2 id="GC常见算法"><a href="#GC常见算法" class="headerlink" title="GC常见算法"></a>GC常见算法</h2><p>常用的内存回收(Garbage Collection)算法整理：</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/GC%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95.png" srcset="/img/loading.gif" alt="GC回收算法"></p><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>可以使用Jsperf来进行Javascript代码的性能测试和对比</p><p><a href="https://jsperf.com/yif-global-variable" target="_blank" rel="noopener">https://jsperf.com/yif-global-variable</a></p><h3 id="1-慎用全局变量"><a href="#1-慎用全局变量" class="headerlink" title="1. 慎用全局变量"></a>1. 慎用全局变量</h3><ul><li>全局变量定义在全局执行上下文，是所有作用域链的顶端（根作用域）</li><li>由于一直存在于根作用域，难以被GC（内存回收）清理，会一直存在知道程序退出</li><li>容易被局部作用域的同名变量遮蔽或者污染</li></ul><h3 id="2-将使用中无法避免的全局变量放入缓存"><a href="#2-将使用中无法避免的全局变量放入缓存" class="headerlink" title="2. 将使用中无法避免的全局变量放入缓存"></a>2. 将使用中无法避免的全局变量放入缓存</h3><p>例如为了获取获取dom元素节点，在需要大量获取document节点的函数中缓存全局变量document可以增加性能</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 不使用对象缓存</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBtnWithoutCache</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> btn1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn1'</span>)    <span class="hljs-keyword">let</span> btn2 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn2'</span>)    <span class="hljs-keyword">let</span> btn3 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn3'</span>)&#125;<span class="hljs-comment">// 使用对象缓存</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getBtnWitCache</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">document</span>    <span class="hljs-keyword">let</span> btn1 = obj.getElementById(<span class="hljs-string">'btn1'</span>)    <span class="hljs-keyword">let</span> btn2 = obj.getElementById(<span class="hljs-string">'btn2'</span>)    <span class="hljs-keyword">let</span> btn3 = obj.getElementById(<span class="hljs-string">'btn3'</span>)&#125;</code></pre></div><p>其原理是通过缓存加快对document全局变量的访问速度，不需要每次都从根作用域重新查找</p><h3 id="3-通过原型链添加方法"><a href="#3-通过原型链添加方法" class="headerlink" title="3. 通过原型链添加方法"></a>3. 通过原型链添加方法</h3><p>原型链是所有对象共享的，比起在每个对象的this上增加方法，使用原型链的性能会更好</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200630155359315.png" srcset="/img/loading.gif" alt="image-20200630155359315"></p><h3 id="4-避免闭包陷阱"><a href="#4-避免闭包陷阱" class="headerlink" title="4. 避免闭包陷阱"></a>4. 避免闭包陷阱</h3><p>闭包会产生额外的对象引用，会使得本身应该被释放回收的对象由于闭包内的引用而无法被回收</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> el = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'btn'</span>)  el.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)  &#125;&#125;foo()</code></pre></div><p>上面的el由于onclick函数的闭包会一直存在，使得即便btn节点已经从dom中被移除了也不会被回收，因为el一直对其进行引用</p><h3 id="5-避免属性访问方法"><a href="#5-避免属性访问方法" class="headerlink" title="5. 避免属性访问方法"></a>5. 避免属性访问方法</h3><p>Javascript中没有传统面向对象语言的属性访问限制，一个对象里所有属性都是对外暴露的（这里没有讨论ES2015之后的class），在这种情况下，使用对象访问方法反而会降低性能</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">'Me'</span>    <span class="hljs-keyword">this</span>.age = <span class="hljs-number">18</span>    <span class="hljs-keyword">this</span>.getAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age    &#125;&#125;</code></pre></div><p>上面的<code>getAge</code>就是一种属性访问方法，我们可以和直接的属性访问对比：</p><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200630162233394.png" srcset="/img/loading.gif" alt="image-20200630162233394"></p><p>可以发现直接访问性能明显更好，这也是符合直觉的</p><h3 id="6-For循环优化"><a href="#6-For循环优化" class="headerlink" title="6. For循环优化"></a>6. For循环优化</h3><p>如果for循环的终止条件是一个定值，最好直接把它取出来缓存成一个变量</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 使用len变量来直接获取数组长度，避免重复访问</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;    <span class="hljs-built_in">console</span>.log(i)&#125;</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200630164130926.png" srcset="/img/loading.gif" alt="image-20200630164130926"></p><p>再对比一下常用的四种for方法</p><p><a href="https://jsperf.com/yif-for-loop-performance" target="_blank" rel="noopener">https://jsperf.com/yif-for-loop-performance</a></p><ul><li>forEach (ES5引入)</li><li>for</li><li>for in</li><li>for of (ES2015引入，只能遍历可迭代对象，如数组，不能直接遍历对象，可以遍历<code>Object.values()</code>或者<code>Object.keys()</code>)</li></ul><p>测试的数组</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arrList = []<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;    arrList.push(i)&#125;</code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/Yikhan/ImageHost/blog/image-20200630180407937.png" srcset="/img/loading.gif" alt="image-20200630180407937"></p><p>可以发现forEach的速度是最快的</p><h3 id="7-使用文档碎片优化节点添加"><a href="#7-使用文档碎片优化节点添加" class="headerlink" title="7. 使用文档碎片优化节点添加"></a>7. 使用文档碎片优化节点添加</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 直接往body上添加节点元素</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-keyword">let</span> oP = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'p'</span>)    oP.innerHTML = i    <span class="hljs-built_in">document</span>.body.appendChild(oP)&#125;<span class="hljs-comment">// 使用documentFragment</span><span class="hljs-keyword">const</span> fragEle = <span class="hljs-built_in">document</span>.createDocumentFragment()<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">10</span>; i++) &#123;    <span class="hljs-keyword">let</span> oP = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'p'</span>)    oP.innerHTML = i    fragEle.appendChild(oP)&#125;<span class="hljs-built_in">document</span>.body.appendChild(fragEle)</code></pre></div><p>早期批量操作dom的开销比较大，使用<code>Fragment</code>可以很好的降低开销，因为是先把文档操作放到虚拟的<code>Fragment</code>上再一次性插入到document，<code>Fragment</code>就相当于占位符，在插入之后本身就会销毁</p><p>现代浏览器已经对这类批量文档操作做了优化，实际的运行速度上使用文档碎片并不会有很大的优势了，但是从语义上讲文档碎片依然是很好的选择，因为它表明了不需要马上对页面dom进行更新操作</p><h3 id="7-使用克隆节点代替创造节点"><a href="#7-使用克隆节点代替创造节点" class="headerlink" title="7. 使用克隆节点代替创造节点"></a>7. 使用克隆节点代替创造节点</h3><p>当需要插入新节点时，另一个优化的方法是使用<code>cloneNode</code>函数，复制一个已有的同类节点再进行更改</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;    <span class="hljs-keyword">let</span> newP = oldP.cloneNode(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 参数表示是否进行深拷贝</span>    newP.innerHTML = i    <span class="hljs-built_in">document</span>.body.appendChild(newP)&#125;</code></pre></div><p><code>cloneNode</code>比使用<code>createElement</code>性能更好，尤其批量创造同类节点</p><h3 id="8-直接量替换new-Object"><a href="#8-直接量替换new-Object" class="headerlink" title="8. 直接量替换new Object"></a>8. 直接量替换new Object</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 使用new</span><span class="hljs-keyword">let</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>)a1[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>a1[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>a1[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span><span class="hljs-comment">// 直接量</span><span class="hljs-keyword">let</span> a2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]</code></pre></div><p>这个非常好理解，使用直接量的性能更好</p>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习笔记 (chap.2) - ES2015</title>
    <link href="/2020/June/Javascript-ES2015/"/>
    <url>/2020/June/Javascript-ES2015/</url>
    
    <content type="html"><![CDATA[<h1 id="ES2015"><a href="#ES2015" class="headerlink" title="ES2015"></a>ES2015</h1><h2 id="1-let和const的块作用域"><a href="#1-let和const的块作用域" class="headerlink" title="1. let和const的块作用域"></a>1. let和const的块作用域</h2><p>let和const的块级作用域是JS很大的一个进步，尤其是let在循环中的使用很有意思</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;      <span class="hljs-built_in">console</span>.log(i)    &#125;&#125;</code></pre></div><p>像上面那样在循坏的内外层使用同名变量i但却不会相互覆盖</p><p>同时我们也可以这样</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> elements = [&#123;&#125;, &#123;&#125;, &#123;&#125;]<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;elements.length;i++) &#123;  elements[i].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(i)  &#125;&#125;elements[<span class="hljs-number">0</span>].onclick() <span class="hljs-comment">// 0</span></code></pre></div><p>这里通过闭包每个i都被单独地记住了</p><p>另外一个值得注意的地方是</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;  <span class="hljs-keyword">let</span> i = <span class="hljs-string">'foo'</span>  <span class="hljs-built_in">console</span>.log(i)&#125; <span class="hljs-comment">// 输出三次foo</span></code></pre></div><p>这里循环逻辑内部的i也不受影响，我们可以这样来理解，上面的代码其实等同于：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-keyword">let</span> i = <span class="hljs-string">'foo'</span> <span class="hljs-comment">// 块作用域内部的i的独立的</span>  <span class="hljs-built_in">console</span>.log(i)&#125;i++<span class="hljs-comment">// 以上重复三次</span></code></pre></div><p>最后let和const都不会自动提升，必须声明后才能使用，否则抛出RefError，但要特别注意的是：<strong>所谓的不会提升(hoist)指的是初始化不会提升，而不是声明不会提升</strong></p><p>let和const的声明依然会被提升，这是Javascript的底层机制决定的，Javascript引擎会在进入每个作用域时寻找该作用域内部的所有变量声明并创建它们</p><p>唯一的区别就是，var还会执行初始化（undefined），而let和const不会，这就是为何在赋值前使用let和const会抛出异常的真正原因</p><p><a href="https://www.jianshu.com/p/0f49c88cf169" target="_blank" rel="noopener">参考资料:let存在变量提升吗？</a></p><h2 id="2-Proxy"><a href="#2-Proxy" class="headerlink" title="2. Proxy"></a>2. Proxy</h2><p>Proxy专门用于对对象进行代理操作，是比Object.defineProperty更灵活便捷的方法。Proxy内置了13个代理方法handler，又称为捕捉器，比如最常用的set和get</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;    name: <span class="hljs-string">'Tom'</span>,    age: <span class="hljs-number">20</span>&#125;<span class="hljs-keyword">const</span> personProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(person, &#123;    <span class="hljs-keyword">get</span>(target, property) &#123;        <span class="hljs-keyword">return</span> property <span class="hljs-keyword">in</span> target ? target[property] : <span class="hljs-string">'default'</span>    &#125;,    <span class="hljs-keyword">set</span>(target, property, value) &#123;      <span class="hljs-comment">// 捕捉set进来的属性和值，可以进行任意额外的操作</span>      <span class="hljs-keyword">if</span> (property === <span class="hljs-string">'age'</span>) &#123;          <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Number</span>.isInteger(value)) &#123;              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;value&#125;</span> is not an integer`</span>)          &#125;      &#125;      target[property] = value      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// set方法需要返回一个bool值表示是否成功</span>    &#125;&#125;)</code></pre></div><p>Proxy比Object.defineProperty更为强大，事实上Proxy本身就自带了一个defineProperty的捕捉器</p><p>更重要的，Proxy可以方便地劫持数组操作，这也是Vue3.0使用Proxy代替了defineProperty的原因之一</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> list = []<span class="hljs-keyword">const</span> listProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(list, &#123;  <span class="hljs-keyword">set</span>(target, property, value) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'set'</span>, property, value)    target[property] = value    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  &#125;&#125;)listProxy.push(<span class="hljs-number">100</span>)<span class="hljs-comment">// set 0 100</span><span class="hljs-comment">// set length 1</span></code></pre></div><p>第一行的0表示数组下标0， 第二行的length表示对数组长度的操作。可见Proxy自己内部知道数组是如何被操作的，不再需要我们进行干涉，这比defineProperty方便了很多</p><p>Proxy对于对象的劫持是非侵入性的，可以任意代理一个已经被定义好的对象和其中的变量，而defineProperty则是一开始就需要声明好</p><h2 id="3-Reflect"><a href="#3-Reflect" class="headerlink" title="3. Reflect"></a>3. Reflect</h2><p>Reflect本身提供了一整套对象操作的拦截函数，可以说和Proxy有点相辅相成的感觉(特别是两者的自带方法都是13个)</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;    name: <span class="hljs-string">'Tom'</span>,    age: <span class="hljs-number">20</span>&#125;<span class="hljs-keyword">const</span> personProxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(person, &#123;    <span class="hljs-keyword">get</span>(target, property) &#123;      <span class="hljs-built_in">console</span>.log(target, property)      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, property)    &#125;&#125;)</code></pre></div><p>Reflect可以统一对象的操作方式。传统的JS里针对对象的操作种类繁多，而且语法差异很大，非常不规范，如下例</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> person = &#123;    name: <span class="hljs-string">'Tom'</span>,    age: <span class="hljs-number">20</span>&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'name'</span> <span class="hljs-keyword">in</span> person) <span class="hljs-comment">// 判断是否存在属性</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">delete</span> person[<span class="hljs-string">'age'</span>]) <span class="hljs-comment">// 删除特定的属性</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.keys(person)) <span class="hljs-comment">// 获取所有属性名</span><span class="hljs-comment">// 使用Reflect统一操作</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.has(person, <span class="hljs-string">'name'</span>))<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.deleteProperty(person, <span class="hljs-string">'age'</span>))<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Reflect</span>.ownKeys(person))</code></pre></div><h2 id="4-Set"><a href="#4-Set" class="headerlink" title="4. Set"></a>4. Set</h2><p>Set类似Python等语言中的集合，是数学概念集合的实现，最有用的地方就是去重</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()s.add(<span class="hljs-number">1</span>).add(<span class="hljs-number">2</span>).add(<span class="hljs-number">2</span>).add(<span class="hljs-number">3</span>)<span class="hljs-built_in">console</span>.log(s) <span class="hljs-comment">// Set &#123;1, 2, 3&#125;</span>s.forEach(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(v))<span class="hljs-comment">// 注意Set是一个对象，并没有索引，所以不能使用for in</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> s) &#123;  <span class="hljs-built_in">console</span>.log(s)&#125;<span class="hljs-built_in">console</span>.log(s.size) <span class="hljs-comment">// 获取大小</span><span class="hljs-built_in">console</span>.log(s.has(<span class="hljs-number">100</span>)) <span class="hljs-comment">// 是否具有某个元素</span><span class="hljs-built_in">console</span>.log(s.delete(<span class="hljs-number">3</span>)) <span class="hljs-comment">// 成功删除返回true，否则false</span><span class="hljs-built_in">console</span>.log(s.clear()) <span class="hljs-comment">// 清空集合</span><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]<span class="hljs-keyword">const</span> result = [ ... new <span class="hljs-built_in">Set</span>(arr)]<span class="hljs-built_in">console</span>.log(result)</code></pre></div><h2 id="5-Map"><a href="#5-Map" class="headerlink" title="5. Map"></a>5. Map</h2><p>即便有计算属性这个对象字面量的增强版，可以给对象添加动态的属性名，比如</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  [<span class="hljs-built_in">Math</span>.ramdom()] : <span class="hljs-number">10</span>,  [<span class="hljs-number">1</span> + <span class="hljs-number">1</span>] : <span class="hljs-number">20</span>&#125;</code></pre></div><p>这种机制仍然有一个很大的限制，就是无法使用对象作为变量名</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  [&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">2</span>&#125;] : <span class="hljs-number">10</span>,  [&#123;<span class="hljs-attr">b</span>: <span class="hljs-number">3</span>&#125;]: <span class="hljs-number">30</span>&#125;<span class="hljs-built_in">console</span>.log(obj) <span class="hljs-comment">// &#123; '[object Object]': 30 &#125;</span><span class="hljs-built_in">console</span>.log(obj[&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">2</span>&#125;]) <span class="hljs-comment">// 30 错误值</span></code></pre></div><p>可以看到两个属性名其实都被toString之后再当做属性名，导致彼此覆盖掉了，因为任何对象toString = <code>[object Object]</code>。也就是说，传统的JS里对象的属性名只能为字符串。</p><p>Map就可以解决这个问题</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<span class="hljs-keyword">const</span> tom = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">10</span>&#125;m.set(tom, <span class="hljs-number">10</span>)<span class="hljs-built_in">console</span>.log(m) <span class="hljs-comment">// Map &#123; &#123; a: 10 &#125; =&gt; 10 &#125;</span><span class="hljs-built_in">console</span>.log(m.get(tom)) <span class="hljs-comment">// 10 正确值</span><span class="hljs-comment">// 和Set一样具有常用的基本操作</span><span class="hljs-comment">// m.has()</span><span class="hljs-comment">// m.delete()</span><span class="hljs-comment">// m.clear()</span></code></pre></div><h2 id="6-Symbol"><a href="#6-Symbol" class="headerlink" title="6. Symbol"></a>6. Symbol</h2><p>Symbol是很有意思的一个数据类型，类似传统静态语言中常用的UID，专门用于生成一个不会重复的变量</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'Hi'</span>) <span class="hljs-comment">// 使用for来注册一个全局Symbol</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>.keyFor(x)) <span class="hljs-comment">// Hi</span></code></pre></div><p>如果不使用Symbol.for来注册，每次Symbol都会生成一个不同的新值</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'Hi'</span>)<span class="hljs-keyword">let</span> y = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">'Hi'</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'x'</span>) === <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'x'</span>)) <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(x === y) <span class="hljs-comment">// true</span></code></pre></div><p>Symbol的特性可以用来创造对象内部的私有成员</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> name = <span class="hljs-built_in">Symbol</span>()<span class="hljs-keyword">const</span> person = &#123;  [name]: <span class="hljs-string">'Yikhan'</span>,  say() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>[name])  &#125;&#125;person.say() <span class="hljs-comment">// Yikhan</span></code></pre></div><p>进一步来说，因为这个功能Symbol也成为了JS的一些内置接口名称，比如<code>[Symbol.toStringTag]</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  [<span class="hljs-built_in">Symbol</span>.toStringTag]: <span class="hljs-string">'Awesome Name'</span>,  foo: <span class="hljs-number">10</span>&#125;<span class="hljs-built_in">console</span>.log(obj.toString()) <span class="hljs-comment">// [object Awesome Name]</span></code></pre></div><p>通过Symbol定义的属性，无论是使用for in还是<code>Object.keys()</code>，亦或是<code>JSON.stringify()</code>都是获取不到的，会直接被这些方法忽略掉</p><h2 id="7-Iterator"><a href="#7-Iterator" class="headerlink" title="7. Iterator"></a>7. Iterator</h2><p>迭代器接口直接和for of操作符相关，只有实现了这个接口才能调用for of来遍历元素</p><p>要注意的是for of不能直接遍历普通的Object，只能遍历<code>Object.values(obj)</code></p><p>迭代器接口的关键字就是在对象中实现<code>[Symbol.iterator]</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  store: [ <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'baz'</span> ],  [<span class="hljs-built_in">Symbol</span>.iterator]: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> &#123;      next: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        <span class="hljs-keyword">const</span> result = &#123;          value: <span class="hljs-keyword">this</span>.store[index],          done: index &gt;= <span class="hljs-keyword">this</span>.store.length        &#125;        index++        <span class="hljs-keyword">return</span> result      &#125;    &#125;  &#125;&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> obj) &#123;  <span class="hljs-built_in">console</span>.log(item) <span class="hljs-comment">// foo bar baz</span>&#125;</code></pre></div><p>如果结合生成器generator，还可以进一步简化这个方法</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  store: [ <span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>, <span class="hljs-string">'baz'</span> ],  [<span class="hljs-built_in">Symbol</span>.iterator]: <span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> <span class="hljs-keyword">this</span>.store) &#123;      <span class="hljs-keyword">yield</span> item    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习笔记 (chap.1) - Promise</title>
    <link href="/2020/June/Javascript-promise/"/>
    <url>/2020/June/Javascript-promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="1-为什么不能把Promise-resolve当做函数变量来使用"><a href="#1-为什么不能把Promise-resolve当做函数变量来使用" class="headerlink" title="1. 为什么不能把Promise.resolve当做函数变量来使用"></a>1. 为什么不能把Promise.resolve当做函数变量来使用</h2><p>如果试图直接调用：</p><div class="hljs"><pre><code class="hljs js">FunctionThatNeedsCallback(Prmose.resolve) <span class="hljs-comment">// TypeError: PromiseResolve called on non-object</span></code></pre></div><p>最简单的复现方法是：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>).then(<span class="hljs-built_in">Promise</span>.resolve) <span class="hljs-comment">// TypeError: PromiseResolve called on non-object</span></code></pre></div><p>因为Promise.resolve是一个需要context的函数，好比一个里面使用了this的函数，是不允许脱离context使用的。<br>所以要么直接在一个对象上使用 <code>v =&gt; Prmose.resolve(v)</code>，要么就要手动绑定 <code>Promise.resolve.bind(Promise)</code></p><h2 id="2-Promise中的值穿透"><a href="#2-Promise中的值穿透" class="headerlink" title="2. Promise中的值穿透"></a>2. Promise中的值穿透</h2><p>和上面那个例子相关，假如有下面这样的代码，结果会打印出什么呢？</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>).then(<span class="hljs-number">2</span>).then(<span class="hljs-built_in">console</span>.log)</code></pre></div><p>答案是1，这是因为如果then的参数不是一个函数，就会把上一层传入的值直接传递给下一层 (类似直接 <code>return this</code>)，这就是值穿透现象。</p><p>通过具体的代码实现，可以比较容易地理解：</p><div class="hljs"><pre><code class="hljs js">successCallback =  <span class="hljs-keyword">typeof</span> successCallback === <span class="hljs-string">'function'</span>    ? successCallback    : <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value <span class="hljs-comment">// 如果callback不是函数，则返回传入的值</span>failCallback =  <span class="hljs-keyword">typeof</span> failCallback === <span class="hljs-string">'function'</span>    ? failCallback    : <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> reason <span class="hljs-comment">// 如果callback不是函数，则返回传入的值</span></code></pre></div><h2 id="3-await的执行顺序"><a href="#3-await的执行顺序" class="headerlink" title="3. await的执行顺序"></a>3. await的执行顺序</h2><p>在异步编程里面常见的知识点有两个，一个是微任务和宏任务的异步执行顺序，另一个就是以Promise为主的异步理解。其中个人觉得最容易被错误理解的不是Promise本身，而是await这个语法糖。众所周知，async-await关键字本质上还是generator和Promise，一个async函数默认会返回一个Promise</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 start'</span>)&#125;<span class="hljs-keyword">let</span> r = fn1() <span class="hljs-comment">// fn1 start</span><span class="hljs-built_in">console</span>.log(r) <span class="hljs-comment">// Promise &#123; undefined &#125;</span></code></pre></div><p>如果没有await，在函数内部即使有异步操作也不会以异步的方式执行，await就好比generator中的yield关键字，我们下面用一个完整的例子来具体分析await</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 start'</span>)  fn2()  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 end'</span>)&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn2 start'</span>)  <span class="hljs-keyword">await</span> fn3()  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn2 end'</span>)&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn3</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn3 start'</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;fn1()<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'Promise'</span>).then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(value))<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finally'</span>)</code></pre></div><p>当fn1当中不使用await时，执行顺序为：</p><div class="hljs"><pre><code class="hljs ps">fn1 startfn2 startfn3 startfn1 <span class="hljs-keyword">end</span><span class="hljs-keyword">finally</span>fn2 <span class="hljs-keyword">end</span>Promise</code></pre></div><p>我们可以注意到fn1 end和fn2 end的输出区别，在fn2中由于使用了await，后面的log语句被放到了Promise中执行，也就是进入了异步队列，因此最后主程序的finally打印之后才打印fn2 end</p><p>而fn1 end是直接打印的，这正是因为我们没有在fn1中使用await，所以fn2()后面的log是以同步的方式运行的。理解了这一点之后，我们可以很容易发现await其实就是Promise.resolve，两者在语义上是一致的，任何在await之后的代码都会被放到Promise中，在then里面才会运行</p><p><a href="https://www.zhihu.com/question/268007969" target="_blank" rel="noopener"><strong>值得注意的是，关于await具体的实现V8引擎也几经更改，可参考这个知乎回答</strong></a></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 start'</span>)  <span class="hljs-keyword">await</span> fn2()  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 end'</span>)&#125;<span class="hljs-comment">// 等价于</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 start'</span>)  <span class="hljs-built_in">Promise</span>.resolve(fn2())    .then(<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'fn1 end'</span>))&#125;</code></pre></div><p>当我们把await和Promise.resolve联系起来之后，就会很容易理解一个面试题的常考点，就是await同一行的函数会被立即执行，之后的代码才会被放到then里面，所以fn2 start和fn3 start都是马上就打印出来了</p><p>如果我们在<code>fn2()</code>前面加个await的话，打印顺序就不一样了</p><div class="hljs"><pre><code class="hljs ps">fn1 startfn2 startfn3 start<span class="hljs-keyword">finally</span>fn2 <span class="hljs-keyword">end</span>Promisefn1 <span class="hljs-keyword">end</span></code></pre></div><p>可以发现fn1 end现在最后才会打印，甚至晚于fn2 end。这是也因为await同一行的函数会被立即执行，就好比<code>Promise.resolve(fn2())</code>里的fn2是马上执行的，其返回值就是resolve出去的对象一样，当执行fn2时，fn2内部也有一个await，所以fn3被马上执行，而后面的打印函数被放入了then里面，所以这里fn2中先产生了Promise，率先进入异步队列。而当执行栈再次回到fn1之后，才把fn1后面的log放入then，要晚于fn2</p>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习笔记 (chap.1) - 函数式编程</title>
    <link href="/2020/June/Javascript-exp/"/>
    <url>/2020/June/Javascript-exp/</url>
    
    <content type="html"><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="1-柯里化"><a href="#1-柯里化" class="headerlink" title="1. 柯里化"></a>1. 柯里化</h2><p>函数式编程的基础，使用了高阶函数的思想，利用闭包把接受多个参数的函数封装成单参数函数，配合组合使用函数compose构成了函数式编程的重点技术</p><p>如何实现curry</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span>(<span class="hljs-params">fn</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curriedFunc</span>(<span class="hljs-params">...args</span>) </span>&#123;    <span class="hljs-comment">//* 使用fn.length获得fn定义时的参数数量，fn通过闭包被缓存</span>    <span class="hljs-keyword">if</span> (args.length &lt; fn.length) &#123;      <span class="hljs-comment">//* 参数数量不够，应该返回柯里化后的函数</span>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...localArgs</span>) </span>&#123;        <span class="hljs-comment">//* 继续递归返回</span>        <span class="hljs-comment">//* 把上一层递归的args和这个函数会接收到的参数合并</span>        <span class="hljs-keyword">return</span> curriedFunc(...args.concat([ ...localArgs ]))      &#125;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//* 参数数量够了，可以运行fn了</span>      <span class="hljs-keyword">return</span> fn(...args)    &#125;  &#125;&#125;</code></pre></div><h2 id="2-组合函数"><a href="#2-组合函数" class="headerlink" title="2. 组合函数"></a>2. 组合函数</h2><p>把一组需要组合的函数按照从右到左的顺序依次执行，注意要组合的函数必须都是单参数函数，也就是一元函数，所以常常需要和curry化配合使用</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//* 组合函数原理模拟</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params">...funcs</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;    <span class="hljs-keyword">return</span> funcs.reduceRight(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">acc, func</span>) </span>&#123;      <span class="hljs-keyword">return</span> func(acc)    &#125;, value)  &#125;&#125;<span class="hljs-keyword">const</span> reverse = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> arr.reverse()<span class="hljs-keyword">const</span> first = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> arr[<span class="hljs-number">0</span>]<span class="hljs-keyword">const</span> toUpperCase = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> str.toUpperCase()<span class="hljs-keyword">const</span> f = compose(toUpperCase, first, reverse)<span class="hljs-built_in">console</span>.log(f([ <span class="hljs-string">'ant'</span>, <span class="hljs-string">'bat'</span>, <span class="hljs-string">'cab'</span> ])) <span class="hljs-comment">// C B A</span></code></pre></div><h2 id="3-Point-free"><a href="#3-Point-free" class="headerlink" title="3. Point-free"></a>3. Point-free</h2><p>在组合函数的基础上，为了使函数更方便组合，可以约定让函数的第一个参数接受方法，第二个参数接受数据，这种方法优先的模式使得组合函数非常简单直接</p><p>当我们组合一系列的函数时，我们实际上就是在按一定的步骤组合方法，并没有提及数据，这和传统的过程式编程完全不同，也是函数式编程个人觉得最有魅力的地方，其简洁和老程序猿嗤之以鼻的面条代码刚好是两个极端</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 可以很直观地知道我们先要执行的步骤，而完全没有提及变量或者数据本身</span><span class="hljs-keyword">const</span> firstLetterToUpper = fp.flowRight(  fp.join(<span class="hljs-string">'. '</span>),  fp.map(fp.flowRight(fp.toUpper, fp.first())),  fp.split(<span class="hljs-string">' '</span>))</code></pre></div><p>lodash/fp这个库里实现了lodash里功能函数的Point-free版本(所以专门放在了fp这个模块下)</p><h2 id="4-函子Functor"><a href="#4-函子Functor" class="headerlink" title="4. 函子Functor"></a>4. 函子Functor</h2><h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>函子是我以前比较陌生的概念，基本从未看到其真正的使用</p><p>函子的本质类似面向对象里面的私有变量封装，传统的函数式编程要求函数为纯函数(Pure Function)，也就是没有任何副作用的函数</p><blockquote><p>副作用：函数执行时不引起其他变量的变化，函数没有中间中间状态</p></blockquote><p>在实际应用中，除了功能单一的功能性函数，大部分业务函数都不是纯函数，副作用无可避免，所以函子的概念应运而生</p><p>函子把要被改变的变量和改变它的方法封装为一个class，和面向对象不同的是，这个改变它的方法并不是一个确定的函数，而是从外部传入一个函数</p><p>同时每次操作都会返回一个新的函子，这样就可以进行链式操作</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//* SECTION 容器 - 用于封装会被改变的值，以及改变它的方法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(value) &#123;    <span class="hljs-keyword">this</span>._value = value  &#125;  <span class="hljs-comment">//* 使用静态函数封装构造函数，这样外面调用的时候就不需要使用new</span>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span>(value) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Container(value)  &#125;  <span class="hljs-comment">//* map封装了任何试图改动_value的行为，并且总是返回一个新的容器</span>  map(fn) &#123;    <span class="hljs-keyword">return</span> Container.of(fn(<span class="hljs-keyword">this</span>._value))  &#125;&#125;<span class="hljs-comment">//* !SECTION</span><span class="hljs-comment">//* 测试 基本的函子</span><span class="hljs-keyword">let</span> r = Container.of(<span class="hljs-number">5</span>) <span class="hljs-comment">// 初始化</span>  .map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x + <span class="hljs-number">1</span>) <span class="hljs-comment">// map会返回一个新的容器，所以可以链式调用</span>  .map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x * x) <span class="hljs-comment">// 结果应该是36</span></code></pre></div><h3 id="4-2-Maybe函子"><a href="#4-2-Maybe函子" class="headerlink" title="4.2 Maybe函子"></a>4.2 Maybe函子</h3><p>基本的函子里面没有判断value和传入的修改方法是否兼容，所以我们可以在容器内加入判断，比如value为空值的时候直接返回一个新函子(value值还是原来的)，并不进行计算</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MayBe</span> </span>&#123;  <span class="hljs-keyword">static</span> <span class="hljs-keyword">of</span>(value) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MayBe(value)  &#125;  <span class="hljs-keyword">constructor</span>(value) &#123;    <span class="hljs-keyword">this</span>._value = value  &#125;  <span class="hljs-comment">// 如果对空值变形的话直接返回 值为 null 的函子</span>  map(fn) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isNothing() ? MayBe.of(<span class="hljs-literal">null</span>) : MayBe.of(fn(<span class="hljs-keyword">this</span>._value))  &#125;  isNothing() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._value === <span class="hljs-literal">null</span> || <span class="hljs-keyword">this</span>._value === <span class="hljs-literal">undefined</span>  &#125;&#125;<span class="hljs-comment">// 传入具体值</span>MayBe.of(<span class="hljs-string">'Hello World'</span>).map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.toUpperCase())<span class="hljs-comment">// 传入 null 的情况</span>MayBe.of(<span class="hljs-literal">null</span>).map(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.toUpperCase())<span class="hljs-comment">// =&gt; MayBe &#123; _value: null &#125;</span></code></pre></div><h3 id="4-3-其他函子"><a href="#4-3-其他函子" class="headerlink" title="4.3 其他函子"></a>4.3 其他函子</h3><p>常用的函子还有Either函子，IO函子，Task函子等</p><p>尤其是Task函子也是一种异步机制，具体可参考folktale函数式编程库</p><p><a href="https://folktale.origamitower.com/" target="_blank" rel="noopener">folktale</a></p><h2 id="5-一些题目"><a href="#5-一些题目" class="headerlink" title="5. 一些题目"></a>5. 一些题目</h2><h3 id="5-1-map函数和parseInt之间的故事"><a href="#5-1-map函数和parseInt之间的故事" class="headerlink" title="5.1 map函数和parseInt之间的故事"></a>5.1 map函数和parseInt之间的故事</h3><p>这也是一道经典的题目了</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> array = [<span class="hljs-string">'23'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'10'</span>]<span class="hljs-built_in">console</span>.log(array.map(<span class="hljs-built_in">parseInt</span>))<span class="hljs-comment">//! 结果是[ 23, NaN, 2 ]</span></code></pre></div><p>这是因为map函数在传递形参时，一共会传递三个参数 <code>callback(currentValue[, index[, array]])</code> 第二个是索引，第三个是数组本身<br>而parseInt其实可以接受两个参数string, radix，第二个radix表示进制，取值范围是2-36。</p><p>有意思的地方来了，radix大部分时候都没有人用，一般都会被留空，而当radix为 <code>0, undefined, null</code> 时，并不是默认以10进制来解析的：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt#%E6%8F%8F%E8%BF%B0" target="_blank" rel="noopener">根据MDN的资料</a></p><ul><li><p>如果输入的 string以 “0x”或 “0x”（一个0，后面是小写或大写的X）开头，那么radix被假定为16，字符串的其余部分被解析为十六进制数。</p></li><li><p>如果输入的 string以 “0”（0）开头， radix被假定为8（八进制）或10（十进制）。具体选择哪一个radix取决于实现。ECMAScript 5 澄清了应该使用 10 (十进制)，但不是所有的浏览器都支持。因此，在使用 parseInt 时，一定要指定一个 radix。</p></li><li><p>如果输入的 string 以任何其他值开头， radix 是 10 (十进制)。</p></li></ul><p>所以上面的例子，其真实的执行情况是：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'23'</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// parseInt没有第三个参数，所以map传递进来第三个参数array可以被忽略</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'8'</span>, <span class="hljs-number">1</span>)<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'10'</span>, <span class="hljs-number">2</span>)</code></pre></div><p>第一个23是字符串，且不是以0x开头的特殊情况，所以使用默认10进制解析，答案为23<br>第二个因为parseInt的radix取值是2-36，1是非法值，所以结果为NaN<br>第三个10是字符串，以2进制解析，答案是2</p><p>这里的细节确实是普通程序猿绝对不会留意到的，这个题目出的的确刁钻</p>]]></content>
    
    
    <categories>
      
      <category>编程技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建总结</title>
    <link href="/2020/June/blog-build/"/>
    <url>/2020/June/blog-build/</url>
    
    <content type="html"><![CDATA[<p>折腾了一番，博客顺利搭建完毕。不得不说到了2020年的今天Hexo确实很强大了，以往个人博客比较难配置的一些站长功能都已经有了现成的集成，特别是主流的几个Theme模版都囊括了常用的几乎所有博客功能，只要自己愿意玩玩技术，不需要多少编程能力就能独立搭好不弱于任何主流社区的个人博客了，巴适得很。</p><p>总结一下几个比较容易踩坑的地方：</p><h3 id="git-repo-嵌套问题"><a href="#git-repo-嵌套问题" class="headerlink" title="git repo 嵌套问题"></a>git repo 嵌套问题</h3><p>推荐直接下载主题到本地，解压放到theme目录下，不要使用submodule，就不用折腾了……</p><p>这个问题应该所有想用git管理博客的blogger都会遇到，而且如果不擅长查资料的话会非常坑，因为官方基本没怎么提这个问题。</p><p>当我们搭建博客项目的时候，一般博客本身就是一个repo，而Hexo会把你下载的主题放在themes这个子文件中，如果你是用 git clone 来下载的话，就会发现当你试图build博客的时候，本地运行一切正常，但一旦你deploy到Github Pages就会收到下面的邮件：</p><blockquote><p>You are attempting to use a Jekyll theme, which is not supported by GitHub Pages. Please visit <a href="https://pages.github.com/themes/" target="_blank" rel="noopener">https://pages.github.com/themes/</a> for a list of supported themes. If you are using the “theme” configuration variable for something other than a Jekyll theme, we recommend you rename this variable throughout your site. For more information, see <a href="https://help.github.com/en/articles/adding-a-jekyll-theme-to-your-github-pages-site." target="_blank" rel="noopener">https://help.github.com/en/articles/adding-a-jekyll-theme-to-your-github-pages-site.</a></p></blockquote><p>这个问题乍一看好像是Github不识别Jekyll主题，但很明显我们用的是Hexo而不是Jekyll模版，如果你直接搜索这些关键词会找到很多几年前很类似的问题。当时Github会默认使用Jekyll去解析网页项目，所以需要在项目里放一个空的 .nojekyll 文件来让Github知道不需要进行解析，但这个问题已经被解决了。</p><p>真正导致这一问题的关键在于repo的嵌套导致的deploy失败，由于你clone的主题本身就是一个repo，而你的博客项目是另外一个repo，两个repo有了嵌套关系就会导致Github不知道如何处理deploy上来的文件。</p><p>所以要用 git submodule 来导入主题，而不是 git clone</p><div class="hljs"><pre><code class="hljs bash">git submodule add https://github.com/geektutu/hexo-theme-geektutu.git themes/geektutu</code></pre></div><p>这样theme模版项目作为一个子模块加载到博客项目里面来，层次逻辑就不会混乱了。</p><p>当你要更新模版时也很简单：</p><div class="hljs"><pre><code class="hljs bash">git submodule upate</code></pre></div><h3 id="css等资源加载失败"><a href="#css等资源加载失败" class="headerlink" title="css等资源加载失败"></a>css等资源加载失败</h3><p>deploy成功之后可能还会发现下面的情况：</p><p><img src="https://raw.githubusercontent.com/Yikhan/ImageHost/master/blog/1564116640441.png" srcset="/img/loading.gif" alt="css error"></p><p>css和js等资源文件统统加载失败，博客只有内容而没有样式。</p><p>404问题一般都是由于访问路径错误导致的，可以看一下这些文件是在访问什么路径的时候失败的，比如:</p><div class="hljs"><pre><code class="hljs bash">正确的:yourname.github.io/blog/css/1.css实际访问:yourname.github.io/css/1.css</code></pre></div><p>其实Hexo文档里面已经提示过你了：</p><blockquote><p>If your site is put in a subdirectory, set url as ‘<a href="http://yoursite.com/child&#39;">http://yoursite.com/child&#39;</a> and root as ‘/child/‘</p></blockquote><p>当你的博客网址不是第一路径时（就是网址中带有/，有/就表示你的博客在一个子路径里面），你要密切注意子路径的配置方式。很多人的博客项目实际网址是 yourname.github.io/blog/ 这样的形式，这时候你就必须要在 _config.yml 文件里面严格按照下面的方式来配置:</p><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-attr">url:</span> <span class="hljs-string">https://yourname.github.io/blog/</span><span class="hljs-attr">root:</span> <span class="hljs-string">/blog/</span></code></pre></div><p>这是我在搭建博客时候碰到的两个坑，总结一下方便其他朋友绕坑。</p><h3 id="如何删除submodule"><a href="#如何删除submodule" class="headerlink" title="如何删除submodule"></a>如何删除submodule</h3><p>如果想停止使用submodule的方式引入主题，可以使用下面的命令：</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># Remove the submodule entry from .git/config</span>git submodule deinit -f path/to/submodule<span class="hljs-comment"># Remove the submodule directory from the superproject's .git/modules directory</span>rm -rf .git/modules/path/to/submodule<span class="hljs-comment"># Remove the entry in .gitmodules and remove the submodule directory located at path/to/submodule</span>git rm -f path/to/submodule</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
